<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
    <!-- Generated by javadoc (version 1.6.0_34) on Wed Mar 04 17:44:05 MSK 2015 -->
    <title>Core</title>
    <meta name="date" content="2015-03-04">
    <link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Core";
    }
//-->

</script>
<noscript>
    <div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
    <!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
    <!--   -->
</a>
    <ul class="navList" title="Navigation">
        <li><a href="../../../overview-summary.html">Overview</a></li>
        <li><a href="package-summary.html">Package</a></li>
        <li class="navBarCell1Rev">Class</li>
        <li><a href="package-tree.html">Tree</a></li>
        <li><a href="../../../index-all.html">Index</a></li>
        <li><a href="../../../help-doc.html">Help</a></li>
    </ul>
    <div class="aboutLanguage"><em>OpenCV 2.4.11</em></div>
</div>
<div class="subNav">
    <ul class="navList">
        <li><a href="../../../org/opencv/core/Algorithm.html" title="class in org.opencv.core"><span
                class="strong">PREV CLASS</span></a></li>
        <li><a href="../../../org/opencv/core/Core.MinMaxLocResult.html"
               title="class in org.opencv.core"><span class="strong">NEXT CLASS</span></a></li>
    </ul>
    <ul class="navList">
        <li><a href="../../../index.html?org/opencv/core/Core.html" target="_top">FRAMES</a></li>
        <li><a href="Core.html" target="_top">NO FRAMES</a></li>
    </ul>
    <ul class="navList" id="allclasses_navbar_top">
        <li><a href="../../../allclasses-noframe.html">All Classes</a></li>
    </ul>
    <div>
        <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->

        </script>
    </div>
    <div>
        <ul class="subNavList">
            <li>SUMMARY:&nbsp;</li>
            <li><a href="#nested_class_summary">NESTED</a>&nbsp;|&nbsp;</li>
            <li><a href="#field_summary">FIELD</a>&nbsp;|&nbsp;</li>
            <li><a href="#constructor_summary">CONSTR</a>&nbsp;|&nbsp;</li>
            <li><a href="#method_summary">METHOD</a></li>
        </ul>
        <ul class="subNavList">
            <li>DETAIL:&nbsp;</li>
            <li><a href="#field_detail">FIELD</a>&nbsp;|&nbsp;</li>
            <li><a href="#constructor_detail">CONSTR</a>&nbsp;|&nbsp;</li>
            <li><a href="#method_detail">METHOD</a></li>
        </ul>
    </div>
    <a name="skip-navbar_top">
        <!--   -->
    </a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
    <p class="subTitle">org.opencv.core</p>

    <h2 title="Class Core" class="title">Class Core</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
    <li>java.lang.Object</li>
    <li>
        <ul class="inheritance">
            <li>org.opencv.core.Core</li>
        </ul>
    </li>
</ul>
<div class="description">
    <ul class="blockList">
        <li class="blockList">
            <hr>
            <br>
<pre>public class <strong>Core</strong>
extends java.lang.Object</pre>
        </li>
    </ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<ul class="blockList">
    <li class="blockList"><a name="nested_class_summary">
        <!--   -->
    </a>

        <h3>Nested Class Summary</h3>
        <table class="overviewSummary" border="0" cellpadding="3" cellspacing="0"
               summary="Nested Class Summary table, listing nested classes, and an explanation">
            <caption><span>Nested Classes</span><span class="tabEnd">&nbsp;</span></caption>
            <tr>
                <th class="colFirst" scope="col">Modifier and Type</th>
                <th class="colLast" scope="col">Class and Description</th>
            </tr>
            <tr class="altColor">
                <td class="colFirst"><code>static class&nbsp;</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/core/Core.MinMaxLocResult.html"
                        title="class in org.opencv.core">Core.MinMaxLocResult</a></strong></code>&nbsp;
                </td>
            </tr>
        </table>
    </li>
</ul>
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_summary">
    <!--   -->
</a>

<h3>Field Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0"
       summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
    <th class="colFirst" scope="col">Modifier and Type</th>
    <th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#CMP_EQ">CMP_EQ</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#CMP_GE">CMP_GE</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#CMP_GT">CMP_GT</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#CMP_LE">CMP_LE</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#CMP_LT">CMP_LT</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#CMP_NE">CMP_NE</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#COVAR_COLS">COVAR_COLS</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#COVAR_NORMAL">COVAR_NORMAL</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#COVAR_ROWS">COVAR_ROWS</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#COVAR_SCALE">COVAR_SCALE</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#COVAR_SCRAMBLED">COVAR_SCRAMBLED</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#COVAR_USE_AVG">COVAR_USE_AVG</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#DCT_INVERSE">DCT_INVERSE</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#DCT_ROWS">DCT_ROWS</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#DECOMP_CHOLESKY">DECOMP_CHOLESKY</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#DECOMP_EIG">DECOMP_EIG</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#DECOMP_LU">DECOMP_LU</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#DECOMP_NORMAL">DECOMP_NORMAL</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#DECOMP_QR">DECOMP_QR</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#DECOMP_SVD">DECOMP_SVD</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#DEPTH_MASK">DEPTH_MASK</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#DEPTH_MASK_16S">DEPTH_MASK_16S</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#DEPTH_MASK_16U">DEPTH_MASK_16U</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#DEPTH_MASK_32F">DEPTH_MASK_32F</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#DEPTH_MASK_32S">DEPTH_MASK_32S</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#DEPTH_MASK_64F">DEPTH_MASK_64F</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#DEPTH_MASK_8S">DEPTH_MASK_8S</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#DEPTH_MASK_8U">DEPTH_MASK_8U</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#DEPTH_MASK_ALL">DEPTH_MASK_ALL</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#DEPTH_MASK_ALL_BUT_8S">DEPTH_MASK_ALL_BUT_8S</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#DEPTH_MASK_FLT">DEPTH_MASK_FLT</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#DFT_COMPLEX_OUTPUT">DFT_COMPLEX_OUTPUT</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#DFT_INVERSE">DFT_INVERSE</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#DFT_REAL_OUTPUT">DFT_REAL_OUTPUT</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#DFT_ROWS">DFT_ROWS</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#DFT_SCALE">DFT_SCALE</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#FILLED">FILLED</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#FONT_HERSHEY_COMPLEX">FONT_HERSHEY_COMPLEX</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#FONT_HERSHEY_COMPLEX_SMALL">FONT_HERSHEY_COMPLEX_SMALL</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#FONT_HERSHEY_DUPLEX">FONT_HERSHEY_DUPLEX</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#FONT_HERSHEY_PLAIN">FONT_HERSHEY_PLAIN</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#FONT_HERSHEY_SCRIPT_COMPLEX">FONT_HERSHEY_SCRIPT_COMPLEX</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#FONT_HERSHEY_SCRIPT_SIMPLEX">FONT_HERSHEY_SCRIPT_SIMPLEX</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#FONT_HERSHEY_SIMPLEX">FONT_HERSHEY_SIMPLEX</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#FONT_HERSHEY_TRIPLEX">FONT_HERSHEY_TRIPLEX</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#FONT_ITALIC">FONT_ITALIC</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#GEMM_1_T">GEMM_1_T</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#GEMM_2_T">GEMM_2_T</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#GEMM_3_T">GEMM_3_T</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#KMEANS_PP_CENTERS">KMEANS_PP_CENTERS</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#KMEANS_RANDOM_CENTERS">KMEANS_RANDOM_CENTERS</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#KMEANS_USE_INITIAL_LABELS">KMEANS_USE_INITIAL_LABELS</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#LINE_4">LINE_4</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#LINE_8">LINE_8</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#LINE_AA">LINE_AA</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#MAGIC_MASK">MAGIC_MASK</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static java.lang.String</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#NATIVE_LIBRARY_NAME">NATIVE_LIBRARY_NAME</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#NORM_HAMMING">NORM_HAMMING</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#NORM_HAMMING2">NORM_HAMMING2</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#NORM_INF">NORM_INF</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#NORM_L1">NORM_L1</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#NORM_L2">NORM_L2</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#NORM_L2SQR">NORM_L2SQR</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#NORM_MINMAX">NORM_MINMAX</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#NORM_RELATIVE">NORM_RELATIVE</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#NORM_TYPE_MASK">NORM_TYPE_MASK</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#REDUCE_AVG">REDUCE_AVG</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#REDUCE_MAX">REDUCE_MAX</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#REDUCE_MIN">REDUCE_MIN</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#REDUCE_SUM">REDUCE_SUM</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#SORT_ASCENDING">SORT_ASCENDING</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#SORT_DESCENDING">SORT_DESCENDING</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#SORT_EVERY_COLUMN">SORT_EVERY_COLUMN</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#SORT_EVERY_ROW">SORT_EVERY_ROW</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#SVD_FULL_UV">SVD_FULL_UV</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#SVD_MODIFY_A">SVD_MODIFY_A</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#SVD_NO_UV">SVD_NO_UV</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#TYPE_MASK">TYPE_MASK</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static java.lang.String</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#VERSION">VERSION</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#VERSION_EPOCH">VERSION_EPOCH</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#VERSION_MAJOR">VERSION_MAJOR</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#VERSION_MINOR">VERSION_MINOR</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#VERSION_REVISION">VERSION_REVISION</a></strong></code>&nbsp;
    </td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
    <li class="blockList"><a name="constructor_summary">
        <!--   -->
    </a>

        <h3>Constructor Summary</h3>
        <table class="overviewSummary" border="0" cellpadding="3" cellspacing="0"
               summary="Constructor Summary table, listing constructors, and an explanation">
            <caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
            <tr>
                <th class="colOne" scope="col">Constructor and Description</th>
            </tr>
            <tr class="altColor">
                <td class="colOne"><code><strong><a
                        href="../../../org/opencv/core/Core.html#Core()">Core</a></strong>()</code>&nbsp;
                </td>
            </tr>
        </table>
    </li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
    <!--   -->
</a>

<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0"
       summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
    <th class="colFirst" scope="col">Modifier and Type</th>
    <th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#absdiff(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">absdiff</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Calculates the per-element absolute difference between two arrays or
            between
            an array and a scalar.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#absdiff(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Mat)">absdiff</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Calculates the per-element absolute difference between two arrays or
            between
            an array and a scalar.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#add(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">add</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Calculates the per-element sum of two arrays or an array and a scalar.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#add(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">add</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>

        <div class="block">Calculates the per-element sum of two arrays or an array and a scalar.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#add(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)">add</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
        int&nbsp;dtype)</code>

        <div class="block">Calculates the per-element sum of two arrays or an array and a scalar.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#add(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Mat)">add</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Calculates the per-element sum of two arrays or an array and a scalar.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#add(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Mat, org.opencv.core.Mat)">add</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>

        <div class="block">Calculates the per-element sum of two arrays or an array and a scalar.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#add(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Mat, org.opencv.core.Mat, int)">add</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
        int&nbsp;dtype)</code>

        <div class="block">Calculates the per-element sum of two arrays or an array and a scalar.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#addWeighted(org.opencv.core.Mat, double, org.opencv.core.Mat, double, double, org.opencv.core.Mat)">addWeighted</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        double&nbsp;alpha,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        double&nbsp;beta,
        double&nbsp;gamma,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Calculates the weighted sum of two arrays.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#addWeighted(org.opencv.core.Mat, double, org.opencv.core.Mat, double, double, org.opencv.core.Mat, int)">addWeighted</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        double&nbsp;alpha,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        double&nbsp;beta,
        double&nbsp;gamma,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;dtype)</code>

        <div class="block">Calculates the weighted sum of two arrays.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#arrowedLine(org.opencv.core.Mat, org.opencv.core.Point, org.opencv.core.Point, org.opencv.core.Scalar)">arrowedLine</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</code>

        <div class="block">Draws a arrow segment pointing from the first point to the second one.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#arrowedLine(org.opencv.core.Mat, org.opencv.core.Point, org.opencv.core.Point, org.opencv.core.Scalar, int, int, int, double)">arrowedLine</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
        int&nbsp;thickness,
        int&nbsp;line_type,
        int&nbsp;shift,
        double&nbsp;tipLength)</code>

        <div class="block">Draws a arrow segment pointing from the first point to the second one.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#batchDistance(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat)">batchDistance</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dist,
        int&nbsp;dtype,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;nidx)</code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#batchDistance(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, int, int)">batchDistance</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dist,
        int&nbsp;dtype,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;nidx,
        int&nbsp;normType,
        int&nbsp;K)</code>&nbsp;</td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#batchDistance(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, int, int, org.opencv.core.Mat, int, boolean)">batchDistance</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dist,
        int&nbsp;dtype,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;nidx,
        int&nbsp;normType,
        int&nbsp;K,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
        int&nbsp;update,
        boolean&nbsp;crosscheck)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#bitwise_and(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">bitwise_and</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Calculates the per-element bit-wise conjunction of two arrays or an array
            and
            a scalar.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#bitwise_and(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">bitwise_and</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>

        <div class="block">Calculates the per-element bit-wise conjunction of two arrays or an array
            and
            a scalar.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#bitwise_not(org.opencv.core.Mat, org.opencv.core.Mat)">bitwise_not</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Inverts every bit of an array.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#bitwise_not(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">bitwise_not</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>

        <div class="block">Inverts every bit of an array.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#bitwise_or(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">bitwise_or</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Calculates the per-element bit-wise disjunction of two arrays or an array
            and
            a scalar.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#bitwise_or(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">bitwise_or</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>

        <div class="block">Calculates the per-element bit-wise disjunction of two arrays or an array
            and
            a scalar.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#bitwise_xor(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">bitwise_xor</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Calculates the per-element bit-wise "exclusive or" operation on two
            arrays or
            an array and a scalar.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#bitwise_xor(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">bitwise_xor</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>

        <div class="block">Calculates the per-element bit-wise "exclusive or" operation on two
            arrays or
            an array and a scalar.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#calcCovarMatrix(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)">calcCovarMatrix</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;samples,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;covar,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mean,
        int&nbsp;flags)</code>

        <div class="block">Calculates the covariance matrix of a set of vectors.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#calcCovarMatrix(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int)">calcCovarMatrix</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;samples,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;covar,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mean,
        int&nbsp;flags,
        int&nbsp;ctype)</code>

        <div class="block">Calculates the covariance matrix of a set of vectors.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#cartToPolar(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">cartToPolar</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;x,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;y,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;magnitude,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;angle)</code>

        <div class="block">Calculates the magnitude and angle of 2D vectors.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#cartToPolar(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)">cartToPolar</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;x,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;y,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;magnitude,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;angle,
        boolean&nbsp;angleInDegrees)</code>

        <div class="block">Calculates the magnitude and angle of 2D vectors.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static boolean</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#checkRange(org.opencv.core.Mat)">checkRange</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;a)</code>

        <div class="block">Checks every element of an input array for invalid values.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static boolean</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#checkRange(org.opencv.core.Mat, boolean, double, double)">checkRange</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;a,
        boolean&nbsp;quiet,
        double&nbsp;minVal,
        double&nbsp;maxVal)</code>

        <div class="block">Checks every element of an input array for invalid values.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#circle(org.opencv.core.Mat, org.opencv.core.Point, int, org.opencv.core.Scalar)">circle</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
        int&nbsp;radius,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</code>

        <div class="block">Draws a circle.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#circle(org.opencv.core.Mat, org.opencv.core.Point, int, org.opencv.core.Scalar, int)">circle</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
        int&nbsp;radius,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
        int&nbsp;thickness)</code>

        <div class="block">Draws a circle.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#circle(org.opencv.core.Mat, org.opencv.core.Point, int, org.opencv.core.Scalar, int, int, int)">circle</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
        int&nbsp;radius,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
        int&nbsp;thickness,
        int&nbsp;lineType,
        int&nbsp;shift)</code>

        <div class="block">Draws a circle.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static boolean</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#clipLine(org.opencv.core.Rect, org.opencv.core.Point, org.opencv.core.Point)">clipLine</a></strong>(<a
            href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;imgRect,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2)</code>

        <div class="block">Clips the line against the image rectangle.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#compare(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)">compare</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;cmpop)</code>

        <div class="block">Performs the per-element comparison of two arrays or an array and scalar
            value.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#compare(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Mat, int)">compare</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;cmpop)</code>

        <div class="block">Performs the per-element comparison of two arrays or an array and scalar
            value.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#completeSymm(org.opencv.core.Mat)">completeSymm</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mtx)</code>

        <div class="block">Copies the lower or the upper half of a square matrix to another half.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#completeSymm(org.opencv.core.Mat, boolean)">completeSymm</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mtx,
        boolean&nbsp;lowerToUpper)</code>

        <div class="block">Copies the lower or the upper half of a square matrix to another half.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#convertScaleAbs(org.opencv.core.Mat, org.opencv.core.Mat)">convertScaleAbs</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Scales, calculates absolute values, and converts the result to 8-bit.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#convertScaleAbs(org.opencv.core.Mat, org.opencv.core.Mat, double, double)">convertScaleAbs</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        double&nbsp;alpha,
        double&nbsp;beta)</code>

        <div class="block">Scales, calculates absolute values, and converts the result to 8-bit.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#countNonZero(org.opencv.core.Mat)">countNonZero</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src)</code>

        <div class="block">Counts non-zero array elements.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static float</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#cubeRoot(float)">cubeRoot</a></strong>(float&nbsp;val)</code>

        <div class="block">Computes the cube root of an argument.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#dct(org.opencv.core.Mat, org.opencv.core.Mat)">dct</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Performs a forward or inverse discrete Cosine transform of 1D or 2D
            array.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#dct(org.opencv.core.Mat, org.opencv.core.Mat, int)">dct</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;flags)</code>

        <div class="block">Performs a forward or inverse discrete Cosine transform of 1D or 2D
            array.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static double</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#determinant(org.opencv.core.Mat)">determinant</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mtx)</code>

        <div class="block">Returns the determinant of a square floating-point matrix.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#dft(org.opencv.core.Mat, org.opencv.core.Mat)">dft</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Performs a forward or inverse Discrete Fourier transform of a 1D or 2D
            floating-point array.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#dft(org.opencv.core.Mat, org.opencv.core.Mat, int, int)">dft</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;flags,
        int&nbsp;nonzeroRows)</code>

        <div class="block">Performs a forward or inverse Discrete Fourier transform of a 1D or 2D
            floating-point array.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#divide(double, org.opencv.core.Mat, org.opencv.core.Mat)">divide</a></strong>(double&nbsp;scale,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Performs per-element division of two arrays or a scalar by an array.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#divide(double, org.opencv.core.Mat, org.opencv.core.Mat, int)">divide</a></strong>(double&nbsp;scale,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;dtype)</code>

        <div class="block">Performs per-element division of two arrays or a scalar by an array.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#divide(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">divide</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Performs per-element division of two arrays or a scalar by an array.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#divide(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double)">divide</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        double&nbsp;scale)</code>

        <div class="block">Performs per-element division of two arrays or a scalar by an array.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#divide(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, int)">divide</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        double&nbsp;scale,
        int&nbsp;dtype)</code>

        <div class="block">Performs per-element division of two arrays or a scalar by an array.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#divide(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Mat)">divide</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Performs per-element division of two arrays or a scalar by an array.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#divide(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Mat, double)">divide</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        double&nbsp;scale)</code>

        <div class="block">Performs per-element division of two arrays or a scalar by an array.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#divide(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Mat, double, int)">divide</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        double&nbsp;scale,
        int&nbsp;dtype)</code>

        <div class="block">Performs per-element division of two arrays or a scalar by an array.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static boolean</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#eigen(org.opencv.core.Mat, boolean, org.opencv.core.Mat, org.opencv.core.Mat)">eigen</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        boolean&nbsp;computeEigenvectors,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvalues,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvectors)</code>

        <div class="block">Calculates eigenvalues and eigenvectors of a symmetric matrix.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#ellipse(org.opencv.core.Mat, org.opencv.core.Point, org.opencv.core.Size, double, double, double, org.opencv.core.Scalar)">ellipse</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;axes,
        double&nbsp;angle,
        double&nbsp;startAngle,
        double&nbsp;endAngle,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</code>

        <div class="block">Draws a simple or thick elliptic arc or fills an ellipse sector.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#ellipse(org.opencv.core.Mat, org.opencv.core.Point, org.opencv.core.Size, double, double, double, org.opencv.core.Scalar, int)">ellipse</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;axes,
        double&nbsp;angle,
        double&nbsp;startAngle,
        double&nbsp;endAngle,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
        int&nbsp;thickness)</code>

        <div class="block">Draws a simple or thick elliptic arc or fills an ellipse sector.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#ellipse(org.opencv.core.Mat, org.opencv.core.Point, org.opencv.core.Size, double, double, double, org.opencv.core.Scalar, int, int, int)">ellipse</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;axes,
        double&nbsp;angle,
        double&nbsp;startAngle,
        double&nbsp;endAngle,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
        int&nbsp;thickness,
        int&nbsp;lineType,
        int&nbsp;shift)</code>

        <div class="block">Draws a simple or thick elliptic arc or fills an ellipse sector.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#ellipse(org.opencv.core.Mat, org.opencv.core.RotatedRect, org.opencv.core.Scalar)">ellipse</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
        <a href="../../../org/opencv/core/RotatedRect.html" title="class in org.opencv.core">RotatedRect</a>&nbsp;box,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</code>

        <div class="block">Draws a simple or thick elliptic arc or fills an ellipse sector.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#ellipse(org.opencv.core.Mat, org.opencv.core.RotatedRect, org.opencv.core.Scalar, int)">ellipse</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
        <a href="../../../org/opencv/core/RotatedRect.html" title="class in org.opencv.core">RotatedRect</a>&nbsp;box,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
        int&nbsp;thickness)</code>

        <div class="block">Draws a simple or thick elliptic arc or fills an ellipse sector.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#ellipse(org.opencv.core.Mat, org.opencv.core.RotatedRect, org.opencv.core.Scalar, int, int)">ellipse</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
        <a href="../../../org/opencv/core/RotatedRect.html" title="class in org.opencv.core">RotatedRect</a>&nbsp;box,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
        int&nbsp;thickness,
        int&nbsp;lineType)</code>

        <div class="block">Draws a simple or thick elliptic arc or fills an ellipse sector.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#ellipse2Poly(org.opencv.core.Point, org.opencv.core.Size, int, int, int, int, org.opencv.core.MatOfPoint)">ellipse2Poly</a></strong>(<a
            href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;axes,
        int&nbsp;angle,
        int&nbsp;arcStart,
        int&nbsp;arcEnd,
        int&nbsp;delta,
        <a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;pts)</code>

        <div class="block">Approximates an elliptic arc with a polyline.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#exp(org.opencv.core.Mat, org.opencv.core.Mat)">exp</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Calculates the exponent of every array element.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#extractChannel(org.opencv.core.Mat, org.opencv.core.Mat, int)">extractChannel</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;coi)</code>&nbsp;</td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static float</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#fastAtan2(float, float)">fastAtan2</a></strong>(float&nbsp;y,
        float&nbsp;x)</code>

        <div class="block">Calculates the angle of a 2D vector in degrees.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#fillConvexPoly(org.opencv.core.Mat, org.opencv.core.MatOfPoint, org.opencv.core.Scalar)">fillConvexPoly</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
        <a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;points,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</code>

        <div class="block">Fills a convex polygon.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#fillConvexPoly(org.opencv.core.Mat, org.opencv.core.MatOfPoint, org.opencv.core.Scalar, int, int)">fillConvexPoly</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
        <a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;points,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
        int&nbsp;lineType,
        int&nbsp;shift)</code>

        <div class="block">Fills a convex polygon.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#fillPoly(org.opencv.core.Mat, java.util.List, org.opencv.core.Scalar)">fillPoly</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
        java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html"
                             title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;pts,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</code>

        <div class="block">Fills the area bounded by one or more polygons.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#fillPoly(org.opencv.core.Mat, java.util.List, org.opencv.core.Scalar, int, int, org.opencv.core.Point)">fillPoly</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
        java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html"
                             title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;pts,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
        int&nbsp;lineType,
        int&nbsp;shift,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;offset)</code>

        <div class="block">Fills the area bounded by one or more polygons.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#findNonZero(org.opencv.core.Mat, org.opencv.core.Mat)">findNonZero</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;idx)</code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#flip(org.opencv.core.Mat, org.opencv.core.Mat, int)">flip</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;flipCode)</code>

        <div class="block">Flips a 2D array around vertical, horizontal, or both axes.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#gemm(org.opencv.core.Mat, org.opencv.core.Mat, double, org.opencv.core.Mat, double, org.opencv.core.Mat)">gemm</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        double&nbsp;alpha,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src3,
        double&nbsp;beta,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Performs generalized matrix multiplication.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#gemm(org.opencv.core.Mat, org.opencv.core.Mat, double, org.opencv.core.Mat, double, org.opencv.core.Mat, int)">gemm</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        double&nbsp;alpha,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src3,
        double&nbsp;beta,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;flags)</code>

        <div class="block">Performs generalized matrix multiplication.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static java.lang.String</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#getBuildInformation()">getBuildInformation</a></strong>()</code>

        <div class="block">Returns full configuration time cmake output.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static long</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#getCPUTickCount()">getCPUTickCount</a></strong>()</code>

        <div class="block">Returns the number of CPU ticks.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#getNumberOfCPUs()">getNumberOfCPUs</a></strong>()</code>

        <div class="block">Returns the number of logical CPUs available for the process.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#getNumThreads()">getNumThreads</a></strong>()</code>

        <div class="block">Returns the number of threads used by OpenCV for parallel regions.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#getOptimalDFTSize(int)">getOptimalDFTSize</a></strong>(int&nbsp;vecsize)</code>

        <div class="block">Returns the optimal DFT size for a given vector size.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Size.html"
                                         title="class in org.opencv.core">Size</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#getTextSize(java.lang.String, int, double, int, int[])">getTextSize</a></strong>(java.lang.String&nbsp;text,
        int&nbsp;fontFace,
        double&nbsp;fontScale,
        int&nbsp;thickness,
        int[]&nbsp;baseLine)</code>

        <div class="block">Calculates the width and height of a text string.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#getThreadNum()">getThreadNum</a></strong>()</code>

        <div class="block">Returns the index of the currently executed thread within the current
            parallel region.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static long</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Core.html#getTickCount()">getTickCount</a></strong>()</code>

        <div class="block">Returns the number of ticks.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static double</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#getTickFrequency()">getTickFrequency</a></strong>()</code>

        <div class="block">Returns the number of ticks per second.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#hconcat(java.util.List, org.opencv.core.Mat)">hconcat</a></strong>(java.util.List&lt;<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#idct(org.opencv.core.Mat, org.opencv.core.Mat)">idct</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Calculates the inverse Discrete Cosine Transform of a 1D or 2D array.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#idct(org.opencv.core.Mat, org.opencv.core.Mat, int)">idct</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;flags)</code>

        <div class="block">Calculates the inverse Discrete Cosine Transform of a 1D or 2D array.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#idft(org.opencv.core.Mat, org.opencv.core.Mat)">idft</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Calculates the inverse Discrete Fourier Transform of a 1D or 2D array.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#idft(org.opencv.core.Mat, org.opencv.core.Mat, int, int)">idft</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;flags,
        int&nbsp;nonzeroRows)</code>

        <div class="block">Calculates the inverse Discrete Fourier Transform of a 1D or 2D array.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#inRange(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Scalar, org.opencv.core.Mat)">inRange</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;lowerb,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;upperb,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Checks if array elements lie between the elements of two other arrays.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#insertChannel(org.opencv.core.Mat, org.opencv.core.Mat, int)">insertChannel</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;coi)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static double</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#invert(org.opencv.core.Mat, org.opencv.core.Mat)">invert</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Finds the inverse or pseudo-inverse of a matrix.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static double</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#invert(org.opencv.core.Mat, org.opencv.core.Mat, int)">invert</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;flags)</code>

        <div class="block">Finds the inverse or pseudo-inverse of a matrix.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static double</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#kmeans(org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.TermCriteria, int, int)">kmeans</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;data,
        int&nbsp;K,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;bestLabels,
        <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria,
        int&nbsp;attempts,
        int&nbsp;flags)</code>

        <div class="block">Finds centers of clusters and groups input samples around the clusters.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static double</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#kmeans(org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.TermCriteria, int, int, org.opencv.core.Mat)">kmeans</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;data,
        int&nbsp;K,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;bestLabels,
        <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria,
        int&nbsp;attempts,
        int&nbsp;flags,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;centers)</code>

        <div class="block">Finds centers of clusters and groups input samples around the clusters.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#line(org.opencv.core.Mat, org.opencv.core.Point, org.opencv.core.Point, org.opencv.core.Scalar)">line</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</code>

        <div class="block">Draws a line segment connecting two points.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#line(org.opencv.core.Mat, org.opencv.core.Point, org.opencv.core.Point, org.opencv.core.Scalar, int)">line</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
        int&nbsp;thickness)</code>

        <div class="block">Draws a line segment connecting two points.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#line(org.opencv.core.Mat, org.opencv.core.Point, org.opencv.core.Point, org.opencv.core.Scalar, int, int, int)">line</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
        int&nbsp;thickness,
        int&nbsp;lineType,
        int&nbsp;shift)</code>

        <div class="block">Draws a line segment connecting two points.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#log(org.opencv.core.Mat, org.opencv.core.Mat)">log</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Calculates the natural logarithm of every array element.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#LUT(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">LUT</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lut,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Performs a look-up table transform of an array.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#LUT(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)">LUT</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lut,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;interpolation)</code>

        <div class="block">Performs a look-up table transform of an array.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#magnitude(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">magnitude</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;x,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;y,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;magnitude)</code>

        <div class="block">Calculates the magnitude of 2D vectors.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static double</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#Mahalanobis(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">Mahalanobis</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;v1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;v2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;icovar)</code>

        <div class="block">Calculates the Mahalanobis distance between two vectors.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#max(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">max</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Calculates per-element maximum of two arrays or an array and a scalar.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#max(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Mat)">max</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Calculates per-element maximum of two arrays or an array and a scalar.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Scalar.html"
                                         title="class in org.opencv.core">Scalar</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#mean(org.opencv.core.Mat)">mean</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src)</code>

        <div class="block">Calculates an average (mean) of array elements.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Scalar.html"
                                         title="class in org.opencv.core">Scalar</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#mean(org.opencv.core.Mat, org.opencv.core.Mat)">mean</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>

        <div class="block">Calculates an average (mean) of array elements.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#meanStdDev(org.opencv.core.Mat, org.opencv.core.MatOfDouble, org.opencv.core.MatOfDouble)">meanStdDev</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;mean,
        <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;stddev)</code>

        <div class="block">Calculates a mean and standard deviation of array elements.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#meanStdDev(org.opencv.core.Mat, org.opencv.core.MatOfDouble, org.opencv.core.MatOfDouble, org.opencv.core.Mat)">meanStdDev</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;mean,
        <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;stddev,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>

        <div class="block">Calculates a mean and standard deviation of array elements.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#merge(java.util.List, org.opencv.core.Mat)">merge</a></strong>(java.util.List&lt;<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;mv,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Creates one multichannel array out of several single-channel ones.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#min(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">min</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Calculates per-element minimum of two arrays or an array and a scalar.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#min(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Mat)">min</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Calculates per-element minimum of two arrays or an array and a scalar.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Core.MinMaxLocResult.html"
                                         title="class in org.opencv.core">Core.MinMaxLocResult</a></code>
    </td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#minMaxLoc(org.opencv.core.Mat)">minMaxLoc</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src)</code>

        <div class="block">Finds the global minimum and maximum in an array.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Core.MinMaxLocResult.html"
                                         title="class in org.opencv.core">Core.MinMaxLocResult</a></code>
    </td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#minMaxLoc(org.opencv.core.Mat, org.opencv.core.Mat)">minMaxLoc</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>

        <div class="block">Finds the global minimum and maximum in an array.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#mixChannels(java.util.List, java.util.List, org.opencv.core.MatOfInt)">mixChannels</a></strong>(java.util.List&lt;<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;src,
        java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                             title="class in org.opencv.core">Mat</a>&gt;&nbsp;dst,
        <a href="../../../org/opencv/core/MatOfInt.html"
           title="class in org.opencv.core">MatOfInt</a>&nbsp;fromTo)</code>

        <div class="block">Copies specified channels from input arrays to the specified channels of
            output arrays.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#mulSpectrums(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)">mulSpectrums</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;a,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;b,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;c,
        int&nbsp;flags)</code>

        <div class="block">Performs the per-element multiplication of two Fourier spectrums.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#mulSpectrums(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, boolean)">mulSpectrums</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;a,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;b,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;c,
        int&nbsp;flags,
        boolean&nbsp;conjB)</code>

        <div class="block">Performs the per-element multiplication of two Fourier spectrums.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#multiply(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">multiply</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Calculates the per-element scaled product of two arrays.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#multiply(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double)">multiply</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        double&nbsp;scale)</code>

        <div class="block">Calculates the per-element scaled product of two arrays.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#multiply(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, int)">multiply</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        double&nbsp;scale,
        int&nbsp;dtype)</code>

        <div class="block">Calculates the per-element scaled product of two arrays.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#multiply(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Mat)">multiply</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Calculates the per-element scaled product of two arrays.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#multiply(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Mat, double)">multiply</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        double&nbsp;scale)</code>

        <div class="block">Calculates the per-element scaled product of two arrays.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#multiply(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Mat, double, int)">multiply</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        double&nbsp;scale,
        int&nbsp;dtype)</code>

        <div class="block">Calculates the per-element scaled product of two arrays.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#mulTransposed(org.opencv.core.Mat, org.opencv.core.Mat, boolean)">mulTransposed</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        boolean&nbsp;aTa)</code>

        <div class="block">Calculates the product of a matrix and its transposition.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#mulTransposed(org.opencv.core.Mat, org.opencv.core.Mat, boolean, org.opencv.core.Mat, double)">mulTransposed</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        boolean&nbsp;aTa,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;delta,
        double&nbsp;scale)</code>

        <div class="block">Calculates the product of a matrix and its transposition.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#mulTransposed(org.opencv.core.Mat, org.opencv.core.Mat, boolean, org.opencv.core.Mat, double, int)">mulTransposed</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        boolean&nbsp;aTa,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;delta,
        double&nbsp;scale,
        int&nbsp;dtype)</code>

        <div class="block">Calculates the product of a matrix and its transposition.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static double</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#norm(org.opencv.core.Mat)">norm</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1)</code>

        <div class="block">Calculates an absolute array norm, an absolute difference norm, or a
            relative
            difference norm.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static double</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#norm(org.opencv.core.Mat, int)">norm</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        int&nbsp;normType)</code>

        <div class="block">Calculates an absolute array norm, an absolute difference norm, or a
            relative
            difference norm.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static double</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#norm(org.opencv.core.Mat, int, org.opencv.core.Mat)">norm</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        int&nbsp;normType,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>

        <div class="block">Calculates an absolute array norm, an absolute difference norm, or a
            relative
            difference norm.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static double</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#norm(org.opencv.core.Mat, org.opencv.core.Mat)">norm</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2)</code>

        <div class="block">Calculates an absolute array norm, an absolute difference norm, or a
            relative
            difference norm.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static double</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#norm(org.opencv.core.Mat, org.opencv.core.Mat, int)">norm</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        int&nbsp;normType)</code>

        <div class="block">Calculates an absolute array norm, an absolute difference norm, or a
            relative
            difference norm.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static double</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#norm(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat)">norm</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        int&nbsp;normType,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>

        <div class="block">Calculates an absolute array norm, an absolute difference norm, or a
            relative
            difference norm.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#normalize(org.opencv.core.Mat, org.opencv.core.Mat)">normalize</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Normalizes the norm or value range of an array.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#normalize(org.opencv.core.Mat, org.opencv.core.Mat, double, double, int)">normalize</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        double&nbsp;alpha,
        double&nbsp;beta,
        int&nbsp;norm_type)</code>

        <div class="block">Normalizes the norm or value range of an array.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#normalize(org.opencv.core.Mat, org.opencv.core.Mat, double, double, int, int)">normalize</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        double&nbsp;alpha,
        double&nbsp;beta,
        int&nbsp;norm_type,
        int&nbsp;dtype)</code>

        <div class="block">Normalizes the norm or value range of an array.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#normalize(org.opencv.core.Mat, org.opencv.core.Mat, double, double, int, int, org.opencv.core.Mat)">normalize</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        double&nbsp;alpha,
        double&nbsp;beta,
        int&nbsp;norm_type,
        int&nbsp;dtype,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>

        <div class="block">Normalizes the norm or value range of an array.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#patchNaNs(org.opencv.core.Mat)">patchNaNs</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;a)</code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#patchNaNs(org.opencv.core.Mat, double)">patchNaNs</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;a,
        double&nbsp;val)</code>&nbsp;</td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#PCABackProject(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">PCABackProject</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;data,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mean,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvectors,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;result)</code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#PCACompute(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">PCACompute</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;data,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mean,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvectors)</code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#PCACompute(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)">PCACompute</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;data,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mean,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvectors,
        int&nbsp;maxComponents)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#PCAComputeVar(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double)">PCAComputeVar</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;data,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mean,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvectors,
        double&nbsp;retainedVariance)</code>&nbsp;</td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#PCAProject(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">PCAProject</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;data,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mean,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvectors,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;result)</code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#perspectiveTransform(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">perspectiveTransform</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;m)</code>

        <div class="block">Performs the perspective matrix transformation of vectors.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#phase(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">phase</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;x,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;y,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;angle)</code>

        <div class="block">Calculates the rotation angle of 2D vectors.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#phase(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)">phase</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;x,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;y,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;angle,
        boolean&nbsp;angleInDegrees)</code>

        <div class="block">Calculates the rotation angle of 2D vectors.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#polarToCart(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">polarToCart</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;magnitude,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;angle,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;x,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;y)</code>

        <div class="block">Calculates x and y coordinates of 2D vectors from their magnitude and
            angle.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#polarToCart(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)">polarToCart</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;magnitude,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;angle,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;x,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;y,
        boolean&nbsp;angleInDegrees)</code>

        <div class="block">Calculates x and y coordinates of 2D vectors from their magnitude and
            angle.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#polylines(org.opencv.core.Mat, java.util.List, boolean, org.opencv.core.Scalar)">polylines</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
        java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html"
                             title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;pts,
        boolean&nbsp;isClosed,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</code>

        <div class="block">Draws several polygonal curves.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#polylines(org.opencv.core.Mat, java.util.List, boolean, org.opencv.core.Scalar, int)">polylines</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
        java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html"
                             title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;pts,
        boolean&nbsp;isClosed,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
        int&nbsp;thickness)</code>

        <div class="block">Draws several polygonal curves.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#polylines(org.opencv.core.Mat, java.util.List, boolean, org.opencv.core.Scalar, int, int, int)">polylines</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
        java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html"
                             title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;pts,
        boolean&nbsp;isClosed,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
        int&nbsp;thickness,
        int&nbsp;lineType,
        int&nbsp;shift)</code>

        <div class="block">Draws several polygonal curves.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#pow(org.opencv.core.Mat, double, org.opencv.core.Mat)">pow</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        double&nbsp;power,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Raises every array element to a power.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#putText(org.opencv.core.Mat, java.lang.String, org.opencv.core.Point, int, double, org.opencv.core.Scalar)">putText</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
        java.lang.String&nbsp;text,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;org,
        int&nbsp;fontFace,
        double&nbsp;fontScale,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</code>

        <div class="block">Draws a text string.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#putText(org.opencv.core.Mat, java.lang.String, org.opencv.core.Point, int, double, org.opencv.core.Scalar, int)">putText</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
        java.lang.String&nbsp;text,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;org,
        int&nbsp;fontFace,
        double&nbsp;fontScale,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
        int&nbsp;thickness)</code>

        <div class="block">Draws a text string.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#putText(org.opencv.core.Mat, java.lang.String, org.opencv.core.Point, int, double, org.opencv.core.Scalar, int, int, boolean)">putText</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
        java.lang.String&nbsp;text,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;org,
        int&nbsp;fontFace,
        double&nbsp;fontScale,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
        int&nbsp;thickness,
        int&nbsp;lineType,
        boolean&nbsp;bottomLeftOrigin)</code>

        <div class="block">Draws a text string.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#randn(org.opencv.core.Mat, double, double)">randn</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        double&nbsp;mean,
        double&nbsp;stddev)</code>

        <div class="block">Fills the array with normally distributed random numbers.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#randShuffle(org.opencv.core.Mat)">randShuffle</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#randShuffle(org.opencv.core.Mat, double)">randShuffle</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        double&nbsp;iterFactor)</code>&nbsp;</td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#randu(org.opencv.core.Mat, double, double)">randu</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        double&nbsp;low,
        double&nbsp;high)</code>

        <div class="block">Generates a single uniformly-distributed random number or an array of
            random
            numbers.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#rectangle(org.opencv.core.Mat, org.opencv.core.Point, org.opencv.core.Point, org.opencv.core.Scalar)">rectangle</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</code>

        <div class="block">Draws a simple, thick, or filled up-right rectangle.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#rectangle(org.opencv.core.Mat, org.opencv.core.Point, org.opencv.core.Point, org.opencv.core.Scalar, int)">rectangle</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
        int&nbsp;thickness)</code>

        <div class="block">Draws a simple, thick, or filled up-right rectangle.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#rectangle(org.opencv.core.Mat, org.opencv.core.Point, org.opencv.core.Point, org.opencv.core.Scalar, int, int, int)">rectangle</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
        int&nbsp;thickness,
        int&nbsp;lineType,
        int&nbsp;shift)</code>

        <div class="block">Draws a simple, thick, or filled up-right rectangle.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#reduce(org.opencv.core.Mat, org.opencv.core.Mat, int, int)">reduce</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;dim,
        int&nbsp;rtype)</code>

        <div class="block">Reduces a matrix to a vector.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#reduce(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int)">reduce</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;dim,
        int&nbsp;rtype,
        int&nbsp;dtype)</code>

        <div class="block">Reduces a matrix to a vector.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#repeat(org.opencv.core.Mat, int, int, org.opencv.core.Mat)">repeat</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        int&nbsp;ny,
        int&nbsp;nx,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Fills the output array with repeated copies of the input array.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#scaleAdd(org.opencv.core.Mat, double, org.opencv.core.Mat, org.opencv.core.Mat)">scaleAdd</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        double&nbsp;alpha,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Calculates the sum of a scaled array and another array.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#setErrorVerbosity(boolean)">setErrorVerbosity</a></strong>(boolean&nbsp;verbose)</code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#setIdentity(org.opencv.core.Mat)">setIdentity</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mtx)</code>

        <div class="block">Initializes a scaled identity matrix.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#setIdentity(org.opencv.core.Mat, org.opencv.core.Scalar)">setIdentity</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mtx,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;s)</code>

        <div class="block">Initializes a scaled identity matrix.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#setNumThreads(int)">setNumThreads</a></strong>(int&nbsp;nthreads)</code>

        <div class="block">OpenCV will try to set the number of threads for the next parallel
            region.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static boolean</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#solve(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">solve</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Solves one or more linear systems or least-squares problems.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static boolean</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#solve(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)">solve</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;flags)</code>

        <div class="block">Solves one or more linear systems or least-squares problems.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#solveCubic(org.opencv.core.Mat, org.opencv.core.Mat)">solveCubic</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;coeffs,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;roots)</code>

        <div class="block">Finds the real roots of a cubic equation.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static double</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#solvePoly(org.opencv.core.Mat, org.opencv.core.Mat)">solvePoly</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;coeffs,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;roots)</code>

        <div class="block">Finds the real or complex roots of a polynomial equation.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static double</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#solvePoly(org.opencv.core.Mat, org.opencv.core.Mat, int)">solvePoly</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;coeffs,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;roots,
        int&nbsp;maxIters)</code>

        <div class="block">Finds the real or complex roots of a polynomial equation.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#sort(org.opencv.core.Mat, org.opencv.core.Mat, int)">sort</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;flags)</code>

        <div class="block">Sorts each row or each column of a matrix.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#sortIdx(org.opencv.core.Mat, org.opencv.core.Mat, int)">sortIdx</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;flags)</code>

        <div class="block">Sorts each row or each column of a matrix.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#split(org.opencv.core.Mat, java.util.List)">split</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;m,
        java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                             title="class in org.opencv.core">Mat</a>&gt;&nbsp;mv)</code>

        <div class="block">Divides a multi-channel array into several single-channel arrays.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#sqrt(org.opencv.core.Mat, org.opencv.core.Mat)">sqrt</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Calculates a square root of array elements.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#subtract(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">subtract</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Calculates the per-element difference between two arrays or array and a
            scalar.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#subtract(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">subtract</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>

        <div class="block">Calculates the per-element difference between two arrays or array and a
            scalar.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#subtract(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)">subtract</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
        int&nbsp;dtype)</code>

        <div class="block">Calculates the per-element difference between two arrays or array and a
            scalar.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#subtract(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Mat)">subtract</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Calculates the per-element difference between two arrays or array and a
            scalar.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#subtract(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Mat, org.opencv.core.Mat)">subtract</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>

        <div class="block">Calculates the per-element difference between two arrays or array and a
            scalar.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#subtract(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Mat, org.opencv.core.Mat, int)">subtract</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
        int&nbsp;dtype)</code>

        <div class="block">Calculates the per-element difference between two arrays or array and a
            scalar.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Scalar.html"
                                         title="class in org.opencv.core">Scalar</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#sumElems(org.opencv.core.Mat)">sumElems</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src)</code>

        <div class="block">Calculates the sum of array elements.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#SVBackSubst(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">SVBackSubst</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;w,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;u,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vt,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rhs,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#SVDecomp(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">SVDecomp</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;w,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;u,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vt)</code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#SVDecomp(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)">SVDecomp</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;w,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;u,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vt,
        int&nbsp;flags)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Scalar.html"
                                         title="class in org.opencv.core">Scalar</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#trace(org.opencv.core.Mat)">trace</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mtx)</code>

        <div class="block">Returns the trace of a matrix.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#transform(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">transform</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;m)</code>

        <div class="block">Performs the matrix transformation of every array element.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#transpose(org.opencv.core.Mat, org.opencv.core.Mat)">transpose</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Transposes a matrix.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Core.html#vconcat(java.util.List, org.opencv.core.Mat)">vconcat</a></strong>(java.util.List&lt;<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>&nbsp;
    </td>
</tr>
</table>
<ul class="blockList">
    <li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
        <!--   -->
    </a>

        <h3>Methods inherited from class&nbsp;java.lang.Object</h3>
        <code>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_detail">
    <!--   -->
</a>

<h3>Field Detail</h3>
<a name="CMP_EQ">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CMP_EQ</h4>
        <pre>public static final&nbsp;int CMP_EQ</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.CMP_EQ">Constant Field
                Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CMP_GE">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CMP_GE</h4>
        <pre>public static final&nbsp;int CMP_GE</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.CMP_GE">Constant Field
                Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CMP_GT">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CMP_GT</h4>
        <pre>public static final&nbsp;int CMP_GT</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.CMP_GT">Constant Field
                Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CMP_LE">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CMP_LE</h4>
        <pre>public static final&nbsp;int CMP_LE</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.CMP_LE">Constant Field
                Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CMP_LT">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CMP_LT</h4>
        <pre>public static final&nbsp;int CMP_LT</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.CMP_LT">Constant Field
                Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CMP_NE">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CMP_NE</h4>
        <pre>public static final&nbsp;int CMP_NE</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.CMP_NE">Constant Field
                Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COVAR_COLS">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COVAR_COLS</h4>
        <pre>public static final&nbsp;int COVAR_COLS</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.COVAR_COLS">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COVAR_NORMAL">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COVAR_NORMAL</h4>
        <pre>public static final&nbsp;int COVAR_NORMAL</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.COVAR_NORMAL">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COVAR_ROWS">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COVAR_ROWS</h4>
        <pre>public static final&nbsp;int COVAR_ROWS</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.COVAR_ROWS">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COVAR_SCALE">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COVAR_SCALE</h4>
        <pre>public static final&nbsp;int COVAR_SCALE</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.COVAR_SCALE">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COVAR_SCRAMBLED">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COVAR_SCRAMBLED</h4>
        <pre>public static final&nbsp;int COVAR_SCRAMBLED</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.COVAR_SCRAMBLED">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COVAR_USE_AVG">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COVAR_USE_AVG</h4>
        <pre>public static final&nbsp;int COVAR_USE_AVG</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.COVAR_USE_AVG">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="DCT_INVERSE">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>DCT_INVERSE</h4>
        <pre>public static final&nbsp;int DCT_INVERSE</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.DCT_INVERSE">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="DCT_ROWS">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>DCT_ROWS</h4>
        <pre>public static final&nbsp;int DCT_ROWS</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.DCT_ROWS">Constant Field
                Values</a></dd>
        </dl>
    </li>
</ul>
<a name="DECOMP_CHOLESKY">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>DECOMP_CHOLESKY</h4>
        <pre>public static final&nbsp;int DECOMP_CHOLESKY</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.DECOMP_CHOLESKY">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="DECOMP_EIG">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>DECOMP_EIG</h4>
        <pre>public static final&nbsp;int DECOMP_EIG</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.DECOMP_EIG">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="DECOMP_LU">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>DECOMP_LU</h4>
        <pre>public static final&nbsp;int DECOMP_LU</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.DECOMP_LU">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="DECOMP_NORMAL">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>DECOMP_NORMAL</h4>
        <pre>public static final&nbsp;int DECOMP_NORMAL</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.DECOMP_NORMAL">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="DECOMP_QR">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>DECOMP_QR</h4>
        <pre>public static final&nbsp;int DECOMP_QR</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.DECOMP_QR">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="DECOMP_SVD">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>DECOMP_SVD</h4>
        <pre>public static final&nbsp;int DECOMP_SVD</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.DECOMP_SVD">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="DEPTH_MASK">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>DEPTH_MASK</h4>
        <pre>public static final&nbsp;int DEPTH_MASK</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.DEPTH_MASK">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="DEPTH_MASK_16S">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>DEPTH_MASK_16S</h4>
        <pre>public static final&nbsp;int DEPTH_MASK_16S</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.DEPTH_MASK_16S">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="DEPTH_MASK_16U">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>DEPTH_MASK_16U</h4>
        <pre>public static final&nbsp;int DEPTH_MASK_16U</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.DEPTH_MASK_16U">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="DEPTH_MASK_32F">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>DEPTH_MASK_32F</h4>
        <pre>public static final&nbsp;int DEPTH_MASK_32F</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.DEPTH_MASK_32F">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="DEPTH_MASK_32S">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>DEPTH_MASK_32S</h4>
        <pre>public static final&nbsp;int DEPTH_MASK_32S</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.DEPTH_MASK_32S">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="DEPTH_MASK_64F">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>DEPTH_MASK_64F</h4>
        <pre>public static final&nbsp;int DEPTH_MASK_64F</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.DEPTH_MASK_64F">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="DEPTH_MASK_8S">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>DEPTH_MASK_8S</h4>
        <pre>public static final&nbsp;int DEPTH_MASK_8S</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.DEPTH_MASK_8S">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="DEPTH_MASK_8U">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>DEPTH_MASK_8U</h4>
        <pre>public static final&nbsp;int DEPTH_MASK_8U</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.DEPTH_MASK_8U">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="DEPTH_MASK_ALL">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>DEPTH_MASK_ALL</h4>
        <pre>public static final&nbsp;int DEPTH_MASK_ALL</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.DEPTH_MASK_ALL">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="DEPTH_MASK_ALL_BUT_8S">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>DEPTH_MASK_ALL_BUT_8S</h4>
        <pre>public static final&nbsp;int DEPTH_MASK_ALL_BUT_8S</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.DEPTH_MASK_ALL_BUT_8S">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="DEPTH_MASK_FLT">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>DEPTH_MASK_FLT</h4>
        <pre>public static final&nbsp;int DEPTH_MASK_FLT</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.DEPTH_MASK_FLT">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="DFT_COMPLEX_OUTPUT">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>DFT_COMPLEX_OUTPUT</h4>
        <pre>public static final&nbsp;int DFT_COMPLEX_OUTPUT</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.DFT_COMPLEX_OUTPUT">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="DFT_INVERSE">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>DFT_INVERSE</h4>
        <pre>public static final&nbsp;int DFT_INVERSE</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.DFT_INVERSE">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="DFT_REAL_OUTPUT">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>DFT_REAL_OUTPUT</h4>
        <pre>public static final&nbsp;int DFT_REAL_OUTPUT</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.DFT_REAL_OUTPUT">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="DFT_ROWS">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>DFT_ROWS</h4>
        <pre>public static final&nbsp;int DFT_ROWS</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.DFT_ROWS">Constant Field
                Values</a></dd>
        </dl>
    </li>
</ul>
<a name="DFT_SCALE">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>DFT_SCALE</h4>
        <pre>public static final&nbsp;int DFT_SCALE</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.DFT_SCALE">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="FILLED">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>FILLED</h4>
        <pre>public static final&nbsp;int FILLED</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.FILLED">Constant Field
                Values</a></dd>
        </dl>
    </li>
</ul>
<a name="FONT_HERSHEY_COMPLEX">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>FONT_HERSHEY_COMPLEX</h4>
        <pre>public static final&nbsp;int FONT_HERSHEY_COMPLEX</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.FONT_HERSHEY_COMPLEX">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="FONT_HERSHEY_COMPLEX_SMALL">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>FONT_HERSHEY_COMPLEX_SMALL</h4>
        <pre>public static final&nbsp;int FONT_HERSHEY_COMPLEX_SMALL</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.core.Core.FONT_HERSHEY_COMPLEX_SMALL">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="FONT_HERSHEY_DUPLEX">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>FONT_HERSHEY_DUPLEX</h4>
        <pre>public static final&nbsp;int FONT_HERSHEY_DUPLEX</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.FONT_HERSHEY_DUPLEX">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="FONT_HERSHEY_PLAIN">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>FONT_HERSHEY_PLAIN</h4>
        <pre>public static final&nbsp;int FONT_HERSHEY_PLAIN</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.FONT_HERSHEY_PLAIN">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="FONT_HERSHEY_SCRIPT_COMPLEX">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>FONT_HERSHEY_SCRIPT_COMPLEX</h4>
        <pre>public static final&nbsp;int FONT_HERSHEY_SCRIPT_COMPLEX</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.core.Core.FONT_HERSHEY_SCRIPT_COMPLEX">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="FONT_HERSHEY_SCRIPT_SIMPLEX">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>FONT_HERSHEY_SCRIPT_SIMPLEX</h4>
        <pre>public static final&nbsp;int FONT_HERSHEY_SCRIPT_SIMPLEX</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.core.Core.FONT_HERSHEY_SCRIPT_SIMPLEX">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="FONT_HERSHEY_SIMPLEX">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>FONT_HERSHEY_SIMPLEX</h4>
        <pre>public static final&nbsp;int FONT_HERSHEY_SIMPLEX</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.FONT_HERSHEY_SIMPLEX">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="FONT_HERSHEY_TRIPLEX">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>FONT_HERSHEY_TRIPLEX</h4>
        <pre>public static final&nbsp;int FONT_HERSHEY_TRIPLEX</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.FONT_HERSHEY_TRIPLEX">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="FONT_ITALIC">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>FONT_ITALIC</h4>
        <pre>public static final&nbsp;int FONT_ITALIC</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.FONT_ITALIC">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="GEMM_1_T">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>GEMM_1_T</h4>
        <pre>public static final&nbsp;int GEMM_1_T</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.GEMM_1_T">Constant Field
                Values</a></dd>
        </dl>
    </li>
</ul>
<a name="GEMM_2_T">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>GEMM_2_T</h4>
        <pre>public static final&nbsp;int GEMM_2_T</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.GEMM_2_T">Constant Field
                Values</a></dd>
        </dl>
    </li>
</ul>
<a name="GEMM_3_T">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>GEMM_3_T</h4>
        <pre>public static final&nbsp;int GEMM_3_T</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.GEMM_3_T">Constant Field
                Values</a></dd>
        </dl>
    </li>
</ul>
<a name="KMEANS_PP_CENTERS">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>KMEANS_PP_CENTERS</h4>
        <pre>public static final&nbsp;int KMEANS_PP_CENTERS</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.KMEANS_PP_CENTERS">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="KMEANS_RANDOM_CENTERS">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>KMEANS_RANDOM_CENTERS</h4>
        <pre>public static final&nbsp;int KMEANS_RANDOM_CENTERS</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.KMEANS_RANDOM_CENTERS">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="KMEANS_USE_INITIAL_LABELS">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>KMEANS_USE_INITIAL_LABELS</h4>
        <pre>public static final&nbsp;int KMEANS_USE_INITIAL_LABELS</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.core.Core.KMEANS_USE_INITIAL_LABELS">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="LINE_4">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>LINE_4</h4>
        <pre>public static final&nbsp;int LINE_4</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.LINE_4">Constant Field
                Values</a></dd>
        </dl>
    </li>
</ul>
<a name="LINE_8">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>LINE_8</h4>
        <pre>public static final&nbsp;int LINE_8</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.LINE_8">Constant Field
                Values</a></dd>
        </dl>
    </li>
</ul>
<a name="LINE_AA">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>LINE_AA</h4>
        <pre>public static final&nbsp;int LINE_AA</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.LINE_AA">Constant Field
                Values</a></dd>
        </dl>
    </li>
</ul>
<a name="MAGIC_MASK">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>MAGIC_MASK</h4>
        <pre>public static final&nbsp;int MAGIC_MASK</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.MAGIC_MASK">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="NATIVE_LIBRARY_NAME">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>NATIVE_LIBRARY_NAME</h4>
        <pre>public static final&nbsp;java.lang.String NATIVE_LIBRARY_NAME</pre>
    </li>
</ul>
<a name="NORM_HAMMING">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>NORM_HAMMING</h4>
        <pre>public static final&nbsp;int NORM_HAMMING</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.NORM_HAMMING">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="NORM_HAMMING2">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>NORM_HAMMING2</h4>
        <pre>public static final&nbsp;int NORM_HAMMING2</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.NORM_HAMMING2">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="NORM_INF">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>NORM_INF</h4>
        <pre>public static final&nbsp;int NORM_INF</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.NORM_INF">Constant Field
                Values</a></dd>
        </dl>
    </li>
</ul>
<a name="NORM_L1">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>NORM_L1</h4>
        <pre>public static final&nbsp;int NORM_L1</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.NORM_L1">Constant Field
                Values</a></dd>
        </dl>
    </li>
</ul>
<a name="NORM_L2">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>NORM_L2</h4>
        <pre>public static final&nbsp;int NORM_L2</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.NORM_L2">Constant Field
                Values</a></dd>
        </dl>
    </li>
</ul>
<a name="NORM_L2SQR">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>NORM_L2SQR</h4>
        <pre>public static final&nbsp;int NORM_L2SQR</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.NORM_L2SQR">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="NORM_MINMAX">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>NORM_MINMAX</h4>
        <pre>public static final&nbsp;int NORM_MINMAX</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.NORM_MINMAX">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="NORM_RELATIVE">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>NORM_RELATIVE</h4>
        <pre>public static final&nbsp;int NORM_RELATIVE</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.NORM_RELATIVE">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="NORM_TYPE_MASK">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>NORM_TYPE_MASK</h4>
        <pre>public static final&nbsp;int NORM_TYPE_MASK</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.NORM_TYPE_MASK">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="REDUCE_AVG">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>REDUCE_AVG</h4>
        <pre>public static final&nbsp;int REDUCE_AVG</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.REDUCE_AVG">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="REDUCE_MAX">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>REDUCE_MAX</h4>
        <pre>public static final&nbsp;int REDUCE_MAX</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.REDUCE_MAX">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="REDUCE_MIN">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>REDUCE_MIN</h4>
        <pre>public static final&nbsp;int REDUCE_MIN</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.REDUCE_MIN">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="REDUCE_SUM">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>REDUCE_SUM</h4>
        <pre>public static final&nbsp;int REDUCE_SUM</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.REDUCE_SUM">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="SORT_ASCENDING">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>SORT_ASCENDING</h4>
        <pre>public static final&nbsp;int SORT_ASCENDING</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.SORT_ASCENDING">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="SORT_DESCENDING">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>SORT_DESCENDING</h4>
        <pre>public static final&nbsp;int SORT_DESCENDING</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.SORT_DESCENDING">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="SORT_EVERY_COLUMN">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>SORT_EVERY_COLUMN</h4>
        <pre>public static final&nbsp;int SORT_EVERY_COLUMN</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.SORT_EVERY_COLUMN">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="SORT_EVERY_ROW">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>SORT_EVERY_ROW</h4>
        <pre>public static final&nbsp;int SORT_EVERY_ROW</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.SORT_EVERY_ROW">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="SVD_FULL_UV">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>SVD_FULL_UV</h4>
        <pre>public static final&nbsp;int SVD_FULL_UV</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.SVD_FULL_UV">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="SVD_MODIFY_A">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>SVD_MODIFY_A</h4>
        <pre>public static final&nbsp;int SVD_MODIFY_A</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.SVD_MODIFY_A">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="SVD_NO_UV">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>SVD_NO_UV</h4>
        <pre>public static final&nbsp;int SVD_NO_UV</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.SVD_NO_UV">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="TYPE_MASK">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>TYPE_MASK</h4>
        <pre>public static final&nbsp;int TYPE_MASK</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.core.Core.TYPE_MASK">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="VERSION">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>VERSION</h4>
        <pre>public static final&nbsp;java.lang.String VERSION</pre>
    </li>
</ul>
<a name="VERSION_EPOCH">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>VERSION_EPOCH</h4>
        <pre>public static final&nbsp;int VERSION_EPOCH</pre>
    </li>
</ul>
<a name="VERSION_MAJOR">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>VERSION_MAJOR</h4>
        <pre>public static final&nbsp;int VERSION_MAJOR</pre>
    </li>
</ul>
<a name="VERSION_MINOR">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>VERSION_MINOR</h4>
        <pre>public static final&nbsp;int VERSION_MINOR</pre>
    </li>
</ul>
<a name="VERSION_REVISION">
    <!--   -->
</a>
<ul class="blockListLast">
    <li class="blockList">
        <h4>VERSION_REVISION</h4>
        <pre>public static final&nbsp;int VERSION_REVISION</pre>
    </li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
    <li class="blockList"><a name="constructor_detail">
        <!--   -->
    </a>

        <h3>Constructor Detail</h3>
        <a name="Core()">
            <!--   -->
        </a>
        <ul class="blockListLast">
            <li class="blockList">
                <h4>Core</h4>
                <pre>public&nbsp;Core()</pre>
            </li>
        </ul>
    </li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
    <!--   -->
</a>

<h3>Method Detail</h3>
<a name="absdiff(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>absdiff</h4>
<pre>public static&nbsp;void&nbsp;absdiff(<a href="../../../org/opencv/core/Mat.html"
                                             title="class in org.opencv.core">Mat</a>&nbsp;src1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Calculates the per-element absolute difference between two arrays or
            between
            an array and a scalar.</p>

            <p>The function <code>absdiff</code> calculates:</p>
            <ul>
                <li> Absolute difference between two arrays when they have the same size
                    and type:
            </ul>

            <p><em>dst(I) = saturate(| src1(I) - src2(I)|)</em></p>

            <ul>
                <li> Absolute difference between an array and a scalar when the second
                    array is constructed from <code>Scalar</code> or has as many elements as the
                    number of channels in <code>src1</code>:
            </ul>

            <p><em>dst(I) = saturate(| src1(I) - src2|)</em></p>

            <ul>
                <li> Absolute difference between a scalar and an array when the first array
                    is constructed from <code>Scalar</code> or has as many elements as the number
                    of channels in <code>src2</code>:
            </ul>

            <p><em>dst(I) = saturate(| src1 - src2(I)|)</em></p>

            <p>where <code>I</code> is a multi-dimensional index of array elements. In case
                of multi-channel arrays, each channel is processed independently.</p>

            <p>Note: Saturation is not applied when the arrays have the depth
                <code>CV_32S</code>. You may even get a negative value in the case of
                overflow.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array or a scalar.</dd>
            <dd><code>src2</code> - second input array or a scalar.</dd>
            <dd><code>dst</code> - output array that has the same size and type as input arrays.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#absdiff">org.opencv.core.Core.absdiff</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="absdiff(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>absdiff</h4>
<pre>public static&nbsp;void&nbsp;absdiff(<a href="../../../org/opencv/core/Mat.html"
                                             title="class in org.opencv.core">Mat</a>&nbsp;src1,
           <a href="../../../org/opencv/core/Scalar.html"
              title="class in org.opencv.core">Scalar</a>&nbsp;src2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Calculates the per-element absolute difference between two arrays or
            between
            an array and a scalar.</p>

            <p>The function <code>absdiff</code> calculates:</p>
            <ul>
                <li> Absolute difference between two arrays when they have the same size
                    and type:
            </ul>

            <p><em>dst(I) = saturate(| src1(I) - src2(I)|)</em></p>

            <ul>
                <li> Absolute difference between an array and a scalar when the second
                    array is constructed from <code>Scalar</code> or has as many elements as the
                    number of channels in <code>src1</code>:
            </ul>

            <p><em>dst(I) = saturate(| src1(I) - src2|)</em></p>

            <ul>
                <li> Absolute difference between a scalar and an array when the first array
                    is constructed from <code>Scalar</code> or has as many elements as the number
                    of channels in <code>src2</code>:
            </ul>

            <p><em>dst(I) = saturate(| src1 - src2(I)|)</em></p>

            <p>where <code>I</code> is a multi-dimensional index of array elements. In case
                of multi-channel arrays, each channel is processed independently.</p>

            <p>Note: Saturation is not applied when the arrays have the depth
                <code>CV_32S</code>. You may even get a negative value in the case of
                overflow.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array or a scalar.</dd>
            <dd><code>src2</code> - second input array or a scalar.</dd>
            <dd><code>dst</code> - output array that has the same size and type as input arrays.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#absdiff">org.opencv.core.Core.absdiff</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="add(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>add</h4>
<pre>public static&nbsp;void&nbsp;add(<a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a>&nbsp;src1,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Calculates the per-element sum of two arrays or an array and a
            scalar.</p>

            <p>The function <code>add</code> calculates:</p>
            <ul>
                <li> Sum of two arrays when both input arrays have the same size and the
                    same number of channels:
            </ul>

            <p><em>dst(I) = saturate(src1(I) + src2(I)) if mask(I) != 0</em></p>

            <ul>
                <li> Sum of an array and a scalar when <code>src2</code> is constructed
                    from <code>Scalar</code> or has the same number of elements as
                    <code>src1.channels()</code>:
            </ul>

            <p><em>dst(I) = saturate(src1(I) + src2) if mask(I) != 0</em></p>

            <ul>
                <li> Sum of a scalar and an array when <code>src1</code> is constructed
                    from <code>Scalar</code> or has the same number of elements as
                    <code>src2.channels()</code>:
            </ul>

            <p><em>dst(I) = saturate(src1 + src2(I)) if mask(I) != 0</em></p>

            <p>where <code>I</code> is a multi-dimensional index of array elements. In case
                of multi-channel arrays, each channel is processed independently.
                The first function in the list above can be replaced with matrix expressions:
                <code></p>

            <p>// C++ code:</p>

            <p>dst = src1 + src2;</p>

            <p>dst += src1; // equivalent to add(dst, src1, dst);</p>

            <p>The input arrays and the output array can all have the same or different
                depths. For example, you can add a 16-bit unsigned array to a 8-bit signed
                array and store the sum as a 32-bit floating-point array. Depth of the output
                array is determined by the <code>dtype</code> parameter. In the second and
                third cases above, as well as in the first case, when <code>src1.depth() ==
                    src2.depth()</code>, <code>dtype</code> can be set to the default
                <code>-1</code>. In this case, the output array will have the same depth as
                the input array, be it <code>src1</code>, <code>src2</code> or both.
                </code></p>

            <p>Note: Saturation is not applied when the output array has the depth
                <code>CV_32S</code>. You may even get result of an incorrect sign in the case
                of overflow.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array or a scalar.</dd>
            <dd><code>src2</code> - second input array or a scalar.</dd>
            <dd><code>dst</code> - output array that has the same size and number of channels as the
                input array(s); the depth is defined by <code>dtype</code> or
                <code>src1</code>/<code>src2</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#add">org.opencv.core.Core.add</a>,
                <a href="../../../org/opencv/core/Core.html#addWeighted(org.opencv.core.Mat, double, org.opencv.core.Mat, double, double, org.opencv.core.Mat, int)"><code>addWeighted(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, double, double, org.opencv.core.Mat,
                    int)</code></a>,
                <a href="../../../org/opencv/core/Mat.html#convertTo(org.opencv.core.Mat, int, double, double)"><code>Mat.convertTo(org.opencv.core.Mat,
                    int, double, double)</code></a>,
                <a href="../../../org/opencv/core/Core.html#scaleAdd(org.opencv.core.Mat, double, org.opencv.core.Mat, org.opencv.core.Mat)"><code>scaleAdd(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#subtract(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>subtract(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>
            </dd>
        </dl>
    </li>
</ul>
<a name="add(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>add</h4>
<pre>public static&nbsp;void&nbsp;add(<a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a>&nbsp;src1,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
        <div class="block"><p>Calculates the per-element sum of two arrays or an array and a
            scalar.</p>

            <p>The function <code>add</code> calculates:</p>
            <ul>
                <li> Sum of two arrays when both input arrays have the same size and the
                    same number of channels:
            </ul>

            <p><em>dst(I) = saturate(src1(I) + src2(I)) if mask(I) != 0</em></p>

            <ul>
                <li> Sum of an array and a scalar when <code>src2</code> is constructed
                    from <code>Scalar</code> or has the same number of elements as
                    <code>src1.channels()</code>:
            </ul>

            <p><em>dst(I) = saturate(src1(I) + src2) if mask(I) != 0</em></p>

            <ul>
                <li> Sum of a scalar and an array when <code>src1</code> is constructed
                    from <code>Scalar</code> or has the same number of elements as
                    <code>src2.channels()</code>:
            </ul>

            <p><em>dst(I) = saturate(src1 + src2(I)) if mask(I) != 0</em></p>

            <p>where <code>I</code> is a multi-dimensional index of array elements. In case
                of multi-channel arrays, each channel is processed independently.
                The first function in the list above can be replaced with matrix expressions:
                <code></p>

            <p>// C++ code:</p>

            <p>dst = src1 + src2;</p>

            <p>dst += src1; // equivalent to add(dst, src1, dst);</p>

            <p>The input arrays and the output array can all have the same or different
                depths. For example, you can add a 16-bit unsigned array to a 8-bit signed
                array and store the sum as a 32-bit floating-point array. Depth of the output
                array is determined by the <code>dtype</code> parameter. In the second and
                third cases above, as well as in the first case, when <code>src1.depth() ==
                    src2.depth()</code>, <code>dtype</code> can be set to the default
                <code>-1</code>. In this case, the output array will have the same depth as
                the input array, be it <code>src1</code>, <code>src2</code> or both.
                </code></p>

            <p>Note: Saturation is not applied when the output array has the depth
                <code>CV_32S</code>. You may even get result of an incorrect sign in the case
                of overflow.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array or a scalar.</dd>
            <dd><code>src2</code> - second input array or a scalar.</dd>
            <dd><code>dst</code> - output array that has the same size and number of channels as the
                input array(s); the depth is defined by <code>dtype</code> or
                <code>src1</code>/<code>src2</code>.
            </dd>
            <dd><code>mask</code> - optional operation mask - 8-bit single channel array, that
                specifies elements of the output array to be changed.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#add">org.opencv.core.Core.add</a>,
                <a href="../../../org/opencv/core/Core.html#addWeighted(org.opencv.core.Mat, double, org.opencv.core.Mat, double, double, org.opencv.core.Mat, int)"><code>addWeighted(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, double, double, org.opencv.core.Mat,
                    int)</code></a>,
                <a href="../../../org/opencv/core/Mat.html#convertTo(org.opencv.core.Mat, int, double, double)"><code>Mat.convertTo(org.opencv.core.Mat,
                    int, double, double)</code></a>,
                <a href="../../../org/opencv/core/Core.html#scaleAdd(org.opencv.core.Mat, double, org.opencv.core.Mat, org.opencv.core.Mat)"><code>scaleAdd(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#subtract(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>subtract(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>
            </dd>
        </dl>
    </li>
</ul>
<a name="add(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>add</h4>
<pre>public static&nbsp;void&nbsp;add(<a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a>&nbsp;src1,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
       int&nbsp;dtype)</pre>
        <div class="block"><p>Calculates the per-element sum of two arrays or an array and a
            scalar.</p>

            <p>The function <code>add</code> calculates:</p>
            <ul>
                <li> Sum of two arrays when both input arrays have the same size and the
                    same number of channels:
            </ul>

            <p><em>dst(I) = saturate(src1(I) + src2(I)) if mask(I) != 0</em></p>

            <ul>
                <li> Sum of an array and a scalar when <code>src2</code> is constructed
                    from <code>Scalar</code> or has the same number of elements as
                    <code>src1.channels()</code>:
            </ul>

            <p><em>dst(I) = saturate(src1(I) + src2) if mask(I) != 0</em></p>

            <ul>
                <li> Sum of a scalar and an array when <code>src1</code> is constructed
                    from <code>Scalar</code> or has the same number of elements as
                    <code>src2.channels()</code>:
            </ul>

            <p><em>dst(I) = saturate(src1 + src2(I)) if mask(I) != 0</em></p>

            <p>where <code>I</code> is a multi-dimensional index of array elements. In case
                of multi-channel arrays, each channel is processed independently.
                The first function in the list above can be replaced with matrix expressions:
                <code></p>

            <p>// C++ code:</p>

            <p>dst = src1 + src2;</p>

            <p>dst += src1; // equivalent to add(dst, src1, dst);</p>

            <p>The input arrays and the output array can all have the same or different
                depths. For example, you can add a 16-bit unsigned array to a 8-bit signed
                array and store the sum as a 32-bit floating-point array. Depth of the output
                array is determined by the <code>dtype</code> parameter. In the second and
                third cases above, as well as in the first case, when <code>src1.depth() ==
                    src2.depth()</code>, <code>dtype</code> can be set to the default
                <code>-1</code>. In this case, the output array will have the same depth as
                the input array, be it <code>src1</code>, <code>src2</code> or both.
                </code></p>

            <p>Note: Saturation is not applied when the output array has the depth
                <code>CV_32S</code>. You may even get result of an incorrect sign in the case
                of overflow.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array or a scalar.</dd>
            <dd><code>src2</code> - second input array or a scalar.</dd>
            <dd><code>dst</code> - output array that has the same size and number of channels as the
                input array(s); the depth is defined by <code>dtype</code> or
                <code>src1</code>/<code>src2</code>.
            </dd>
            <dd><code>mask</code> - optional operation mask - 8-bit single channel array, that
                specifies elements of the output array to be changed.
            </dd>
            <dd><code>dtype</code> - optional depth of the output array (see the discussion below).
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#add">org.opencv.core.Core.add</a>,
                <a href="../../../org/opencv/core/Core.html#addWeighted(org.opencv.core.Mat, double, org.opencv.core.Mat, double, double, org.opencv.core.Mat, int)"><code>addWeighted(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, double, double, org.opencv.core.Mat,
                    int)</code></a>,
                <a href="../../../org/opencv/core/Mat.html#convertTo(org.opencv.core.Mat, int, double, double)"><code>Mat.convertTo(org.opencv.core.Mat,
                    int, double, double)</code></a>,
                <a href="../../../org/opencv/core/Core.html#scaleAdd(org.opencv.core.Mat, double, org.opencv.core.Mat, org.opencv.core.Mat)"><code>scaleAdd(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#subtract(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>subtract(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>
            </dd>
        </dl>
    </li>
</ul>
<a name="add(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>add</h4>
<pre>public static&nbsp;void&nbsp;add(<a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a>&nbsp;src1,
       <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Calculates the per-element sum of two arrays or an array and a
            scalar.</p>

            <p>The function <code>add</code> calculates:</p>
            <ul>
                <li> Sum of two arrays when both input arrays have the same size and the
                    same number of channels:
            </ul>

            <p><em>dst(I) = saturate(src1(I) + src2(I)) if mask(I) != 0</em></p>

            <ul>
                <li> Sum of an array and a scalar when <code>src2</code> is constructed
                    from <code>Scalar</code> or has the same number of elements as
                    <code>src1.channels()</code>:
            </ul>

            <p><em>dst(I) = saturate(src1(I) + src2) if mask(I) != 0</em></p>

            <ul>
                <li> Sum of a scalar and an array when <code>src1</code> is constructed
                    from <code>Scalar</code> or has the same number of elements as
                    <code>src2.channels()</code>:
            </ul>

            <p><em>dst(I) = saturate(src1 + src2(I)) if mask(I) != 0</em></p>

            <p>where <code>I</code> is a multi-dimensional index of array elements. In case
                of multi-channel arrays, each channel is processed independently.
                The first function in the list above can be replaced with matrix expressions:
                <code></p>

            <p>// C++ code:</p>

            <p>dst = src1 + src2;</p>

            <p>dst += src1; // equivalent to add(dst, src1, dst);</p>

            <p>The input arrays and the output array can all have the same or different
                depths. For example, you can add a 16-bit unsigned array to a 8-bit signed
                array and store the sum as a 32-bit floating-point array. Depth of the output
                array is determined by the <code>dtype</code> parameter. In the second and
                third cases above, as well as in the first case, when <code>src1.depth() ==
                    src2.depth()</code>, <code>dtype</code> can be set to the default
                <code>-1</code>. In this case, the output array will have the same depth as
                the input array, be it <code>src1</code>, <code>src2</code> or both.
                </code></p>

            <p>Note: Saturation is not applied when the output array has the depth
                <code>CV_32S</code>. You may even get result of an incorrect sign in the case
                of overflow.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array or a scalar.</dd>
            <dd><code>src2</code> - second input array or a scalar.</dd>
            <dd><code>dst</code> - output array that has the same size and number of channels as the
                input array(s); the depth is defined by <code>dtype</code> or
                <code>src1</code>/<code>src2</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#add">org.opencv.core.Core.add</a>,
                <a href="../../../org/opencv/core/Core.html#addWeighted(org.opencv.core.Mat, double, org.opencv.core.Mat, double, double, org.opencv.core.Mat, int)"><code>addWeighted(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, double, double, org.opencv.core.Mat,
                    int)</code></a>,
                <a href="../../../org/opencv/core/Mat.html#convertTo(org.opencv.core.Mat, int, double, double)"><code>Mat.convertTo(org.opencv.core.Mat,
                    int, double, double)</code></a>,
                <a href="../../../org/opencv/core/Core.html#scaleAdd(org.opencv.core.Mat, double, org.opencv.core.Mat, org.opencv.core.Mat)"><code>scaleAdd(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#subtract(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>subtract(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>
            </dd>
        </dl>
    </li>
</ul>
<a name="add(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>add</h4>
<pre>public static&nbsp;void&nbsp;add(<a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a>&nbsp;src1,
       <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
        <div class="block"><p>Calculates the per-element sum of two arrays or an array and a
            scalar.</p>

            <p>The function <code>add</code> calculates:</p>
            <ul>
                <li> Sum of two arrays when both input arrays have the same size and the
                    same number of channels:
            </ul>

            <p><em>dst(I) = saturate(src1(I) + src2(I)) if mask(I) != 0</em></p>

            <ul>
                <li> Sum of an array and a scalar when <code>src2</code> is constructed
                    from <code>Scalar</code> or has the same number of elements as
                    <code>src1.channels()</code>:
            </ul>

            <p><em>dst(I) = saturate(src1(I) + src2) if mask(I) != 0</em></p>

            <ul>
                <li> Sum of a scalar and an array when <code>src1</code> is constructed
                    from <code>Scalar</code> or has the same number of elements as
                    <code>src2.channels()</code>:
            </ul>

            <p><em>dst(I) = saturate(src1 + src2(I)) if mask(I) != 0</em></p>

            <p>where <code>I</code> is a multi-dimensional index of array elements. In case
                of multi-channel arrays, each channel is processed independently.
                The first function in the list above can be replaced with matrix expressions:
                <code></p>

            <p>// C++ code:</p>

            <p>dst = src1 + src2;</p>

            <p>dst += src1; // equivalent to add(dst, src1, dst);</p>

            <p>The input arrays and the output array can all have the same or different
                depths. For example, you can add a 16-bit unsigned array to a 8-bit signed
                array and store the sum as a 32-bit floating-point array. Depth of the output
                array is determined by the <code>dtype</code> parameter. In the second and
                third cases above, as well as in the first case, when <code>src1.depth() ==
                    src2.depth()</code>, <code>dtype</code> can be set to the default
                <code>-1</code>. In this case, the output array will have the same depth as
                the input array, be it <code>src1</code>, <code>src2</code> or both.
                </code></p>

            <p>Note: Saturation is not applied when the output array has the depth
                <code>CV_32S</code>. You may even get result of an incorrect sign in the case
                of overflow.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array or a scalar.</dd>
            <dd><code>src2</code> - second input array or a scalar.</dd>
            <dd><code>dst</code> - output array that has the same size and number of channels as the
                input array(s); the depth is defined by <code>dtype</code> or
                <code>src1</code>/<code>src2</code>.
            </dd>
            <dd><code>mask</code> - optional operation mask - 8-bit single channel array, that
                specifies elements of the output array to be changed.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#add">org.opencv.core.Core.add</a>,
                <a href="../../../org/opencv/core/Core.html#addWeighted(org.opencv.core.Mat, double, org.opencv.core.Mat, double, double, org.opencv.core.Mat, int)"><code>addWeighted(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, double, double, org.opencv.core.Mat,
                    int)</code></a>,
                <a href="../../../org/opencv/core/Mat.html#convertTo(org.opencv.core.Mat, int, double, double)"><code>Mat.convertTo(org.opencv.core.Mat,
                    int, double, double)</code></a>,
                <a href="../../../org/opencv/core/Core.html#scaleAdd(org.opencv.core.Mat, double, org.opencv.core.Mat, org.opencv.core.Mat)"><code>scaleAdd(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#subtract(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>subtract(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>
            </dd>
        </dl>
    </li>
</ul>
<a name="add(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Mat, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>add</h4>
<pre>public static&nbsp;void&nbsp;add(<a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a>&nbsp;src1,
       <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
       int&nbsp;dtype)</pre>
        <div class="block"><p>Calculates the per-element sum of two arrays or an array and a
            scalar.</p>

            <p>The function <code>add</code> calculates:</p>
            <ul>
                <li> Sum of two arrays when both input arrays have the same size and the
                    same number of channels:
            </ul>

            <p><em>dst(I) = saturate(src1(I) + src2(I)) if mask(I) != 0</em></p>

            <ul>
                <li> Sum of an array and a scalar when <code>src2</code> is constructed
                    from <code>Scalar</code> or has the same number of elements as
                    <code>src1.channels()</code>:
            </ul>

            <p><em>dst(I) = saturate(src1(I) + src2) if mask(I) != 0</em></p>

            <ul>
                <li> Sum of a scalar and an array when <code>src1</code> is constructed
                    from <code>Scalar</code> or has the same number of elements as
                    <code>src2.channels()</code>:
            </ul>

            <p><em>dst(I) = saturate(src1 + src2(I)) if mask(I) != 0</em></p>

            <p>where <code>I</code> is a multi-dimensional index of array elements. In case
                of multi-channel arrays, each channel is processed independently.
                The first function in the list above can be replaced with matrix expressions:
                <code></p>

            <p>// C++ code:</p>

            <p>dst = src1 + src2;</p>

            <p>dst += src1; // equivalent to add(dst, src1, dst);</p>

            <p>The input arrays and the output array can all have the same or different
                depths. For example, you can add a 16-bit unsigned array to a 8-bit signed
                array and store the sum as a 32-bit floating-point array. Depth of the output
                array is determined by the <code>dtype</code> parameter. In the second and
                third cases above, as well as in the first case, when <code>src1.depth() ==
                    src2.depth()</code>, <code>dtype</code> can be set to the default
                <code>-1</code>. In this case, the output array will have the same depth as
                the input array, be it <code>src1</code>, <code>src2</code> or both.
                </code></p>

            <p>Note: Saturation is not applied when the output array has the depth
                <code>CV_32S</code>. You may even get result of an incorrect sign in the case
                of overflow.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array or a scalar.</dd>
            <dd><code>src2</code> - second input array or a scalar.</dd>
            <dd><code>dst</code> - output array that has the same size and number of channels as the
                input array(s); the depth is defined by <code>dtype</code> or
                <code>src1</code>/<code>src2</code>.
            </dd>
            <dd><code>mask</code> - optional operation mask - 8-bit single channel array, that
                specifies elements of the output array to be changed.
            </dd>
            <dd><code>dtype</code> - optional depth of the output array (see the discussion below).
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#add">org.opencv.core.Core.add</a>,
                <a href="../../../org/opencv/core/Core.html#addWeighted(org.opencv.core.Mat, double, org.opencv.core.Mat, double, double, org.opencv.core.Mat, int)"><code>addWeighted(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, double, double, org.opencv.core.Mat,
                    int)</code></a>,
                <a href="../../../org/opencv/core/Mat.html#convertTo(org.opencv.core.Mat, int, double, double)"><code>Mat.convertTo(org.opencv.core.Mat,
                    int, double, double)</code></a>,
                <a href="../../../org/opencv/core/Core.html#scaleAdd(org.opencv.core.Mat, double, org.opencv.core.Mat, org.opencv.core.Mat)"><code>scaleAdd(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#subtract(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>subtract(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>
            </dd>
        </dl>
    </li>
</ul>
<a name="addWeighted(org.opencv.core.Mat, double, org.opencv.core.Mat, double, double, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>addWeighted</h4>
<pre>public static&nbsp;void&nbsp;addWeighted(<a href="../../../org/opencv/core/Mat.html"
                                                 title="class in org.opencv.core">Mat</a>&nbsp;src1,
               double&nbsp;alpha,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
               double&nbsp;beta,
               double&nbsp;gamma,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Calculates the weighted sum of two arrays.</p>

            <p>The function <code>addWeighted</code> calculates the weighted sum of two
                arrays as follows:</p>

            <p><em>dst(I)= saturate(src1(I)* alpha + src2(I)* beta + gamma)</em></p>

            <p>where <code>I</code> is a multi-dimensional index of array elements. In case
                of multi-channel arrays, each channel is processed independently.
                The function can be replaced with a matrix expression: <code></p>

            <p>// C++ code:</p>

            <p>dst = src1*alpha + src2*beta + gamma;</p>

            <p>Note: Saturation is not applied when the output array has the depth
                <code>CV_32S</code>. You may even get result of an incorrect sign in the case
                of overflow.
                </code></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array.</dd>
            <dd><code>alpha</code> - weight of the first array elements.</dd>
            <dd><code>src2</code> - second input array of the same size and channel number as
                <code>src1</code>.
            </dd>
            <dd><code>beta</code> - weight of the second array elements.</dd>
            <dd><code>gamma</code> - scalar added to each sum.</dd>
            <dd><code>dst</code> - output array that has the same size and number of channels as the
                input arrays.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#addweighted">org.opencv.core.Core.addWeighted</a>,
                <a href="../../../org/opencv/core/Core.html#add(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>add(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#scaleAdd(org.opencv.core.Mat, double, org.opencv.core.Mat, org.opencv.core.Mat)"><code>scaleAdd(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#subtract(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>subtract(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Mat.html#convertTo(org.opencv.core.Mat, int, double, double)"><code>Mat.convertTo(org.opencv.core.Mat,
                    int, double, double)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="addWeighted(org.opencv.core.Mat, double, org.opencv.core.Mat, double, double, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>addWeighted</h4>
<pre>public static&nbsp;void&nbsp;addWeighted(<a href="../../../org/opencv/core/Mat.html"
                                                 title="class in org.opencv.core">Mat</a>&nbsp;src1,
               double&nbsp;alpha,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
               double&nbsp;beta,
               double&nbsp;gamma,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
               int&nbsp;dtype)</pre>
        <div class="block"><p>Calculates the weighted sum of two arrays.</p>

            <p>The function <code>addWeighted</code> calculates the weighted sum of two
                arrays as follows:</p>

            <p><em>dst(I)= saturate(src1(I)* alpha + src2(I)* beta + gamma)</em></p>

            <p>where <code>I</code> is a multi-dimensional index of array elements. In case
                of multi-channel arrays, each channel is processed independently.
                The function can be replaced with a matrix expression: <code></p>

            <p>// C++ code:</p>

            <p>dst = src1*alpha + src2*beta + gamma;</p>

            <p>Note: Saturation is not applied when the output array has the depth
                <code>CV_32S</code>. You may even get result of an incorrect sign in the case
                of overflow.
                </code></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array.</dd>
            <dd><code>alpha</code> - weight of the first array elements.</dd>
            <dd><code>src2</code> - second input array of the same size and channel number as
                <code>src1</code>.
            </dd>
            <dd><code>beta</code> - weight of the second array elements.</dd>
            <dd><code>gamma</code> - scalar added to each sum.</dd>
            <dd><code>dst</code> - output array that has the same size and number of channels as the
                input arrays.
            </dd>
            <dd><code>dtype</code> - optional depth of the output array; when both input arrays have
                the same depth, <code>dtype</code> can be set to <code>-1</code>, which will
                be equivalent to <code>src1.depth()</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#addweighted">org.opencv.core.Core.addWeighted</a>,
                <a href="../../../org/opencv/core/Core.html#add(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>add(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#scaleAdd(org.opencv.core.Mat, double, org.opencv.core.Mat, org.opencv.core.Mat)"><code>scaleAdd(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#subtract(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>subtract(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Mat.html#convertTo(org.opencv.core.Mat, int, double, double)"><code>Mat.convertTo(org.opencv.core.Mat,
                    int, double, double)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="arrowedLine(org.opencv.core.Mat, org.opencv.core.Point, org.opencv.core.Point, org.opencv.core.Scalar)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>arrowedLine</h4>
<pre>public static&nbsp;void&nbsp;arrowedLine(<a href="../../../org/opencv/core/Mat.html"
                                                 title="class in org.opencv.core">Mat</a>&nbsp;img,
               <a href="../../../org/opencv/core/Point.html"
                  title="class in org.opencv.core">Point</a>&nbsp;pt1,
               <a href="../../../org/opencv/core/Point.html"
                  title="class in org.opencv.core">Point</a>&nbsp;pt2,
               <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</pre>
        <div class="block"><p>Draws a arrow segment pointing from the first point to the second
            one.</p>

            <p>The function <code>arrowedLine</code> draws an arrow between <code>pt1</code>
                and <code>pt2</code> points in the image. See also "line".</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>img</code> - Image.</dd>
            <dd><code>pt1</code> - The point the arrow starts from.</dd>
            <dd><code>pt2</code> - The point the arrow points to.</dd>
            <dd><code>color</code> - Line color.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#arrowedline">org.opencv.core.Core.arrowedLine</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="arrowedLine(org.opencv.core.Mat, org.opencv.core.Point, org.opencv.core.Point, org.opencv.core.Scalar, int, int, int, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>arrowedLine</h4>
<pre>public static&nbsp;void&nbsp;arrowedLine(<a href="../../../org/opencv/core/Mat.html"
                                                 title="class in org.opencv.core">Mat</a>&nbsp;img,
               <a href="../../../org/opencv/core/Point.html"
                  title="class in org.opencv.core">Point</a>&nbsp;pt1,
               <a href="../../../org/opencv/core/Point.html"
                  title="class in org.opencv.core">Point</a>&nbsp;pt2,
               <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
               int&nbsp;thickness,
               int&nbsp;line_type,
               int&nbsp;shift,
               double&nbsp;tipLength)</pre>
        <div class="block"><p>Draws a arrow segment pointing from the first point to the second
            one.</p>

            <p>The function <code>arrowedLine</code> draws an arrow between <code>pt1</code>
                and <code>pt2</code> points in the image. See also "line".</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>img</code> - Image.</dd>
            <dd><code>pt1</code> - The point the arrow starts from.</dd>
            <dd><code>pt2</code> - The point the arrow points to.</dd>
            <dd><code>color</code> - Line color.</dd>
            <dd><code>thickness</code> - Line thickness.</dd>
            <dd><code>line_type</code> - Type of the line:
                <ul>
                    <li> 8 (or omitted) - 8-connected line.
                    <li> 4 - 4-connected line.
                    <li> CV_AA - antialiased line.
                </ul>
            </dd>
            <dd><code>shift</code> - Number of fractional bits in the point coordinates.</dd>
            <dd><code>tipLength</code> - The length of the arrow tip in relation to the arrow length
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#arrowedline">org.opencv.core.Core.arrowedLine</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="batchDistance(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>batchDistance</h4>
<pre>public static&nbsp;void&nbsp;batchDistance(<a href="../../../org/opencv/core/Mat.html"
                                                   title="class in org.opencv.core">Mat</a>&nbsp;src1,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;src2,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;dist,
                 int&nbsp;dtype,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;nidx)</pre>
    </li>
</ul>
<a name="batchDistance(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>batchDistance</h4>
<pre>public static&nbsp;void&nbsp;batchDistance(<a href="../../../org/opencv/core/Mat.html"
                                                   title="class in org.opencv.core">Mat</a>&nbsp;src1,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;src2,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;dist,
                 int&nbsp;dtype,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;nidx,
                 int&nbsp;normType,
                 int&nbsp;K)</pre>
    </li>
</ul>
<a name="batchDistance(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, int, int, org.opencv.core.Mat, int, boolean)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>batchDistance</h4>
<pre>public static&nbsp;void&nbsp;batchDistance(<a href="../../../org/opencv/core/Mat.html"
                                                   title="class in org.opencv.core">Mat</a>&nbsp;src1,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;src2,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;dist,
                 int&nbsp;dtype,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;nidx,
                 int&nbsp;normType,
                 int&nbsp;K,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;mask,
                 int&nbsp;update,
                 boolean&nbsp;crosscheck)</pre>
    </li>
</ul>
<a name="bitwise_and(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>bitwise_and</h4>
<pre>public static&nbsp;void&nbsp;bitwise_and(<a href="../../../org/opencv/core/Mat.html"
                                                 title="class in org.opencv.core">Mat</a>&nbsp;src1,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Calculates the per-element bit-wise conjunction of two arrays or an
            array and
            a scalar.</p>

            <p>The function calculates the per-element bit-wise logical conjunction for:</p>
            <ul>
                <li> Two arrays when <code>src1</code> and <code>src2</code> have the same
                    size:
            </ul>

            <p><em>dst(I) = src1(I) / src2(I) if mask(I) != 0</em></p>

            <ul>
                <li> An array and a scalar when <code>src2</code> is constructed from
                    <code>Scalar</code> or has the same number of elements as
                    <code>src1.channels()</code>:
            </ul>

            <p><em>dst(I) = src1(I) / src2 if mask(I) != 0</em></p>

            <ul>
                <li> A scalar and an array when <code>src1</code> is constructed from
                    <code>Scalar</code> or has the same number of elements as
                    <code>src2.channels()</code>:
            </ul>

            <p><em>dst(I) = src1 / src2(I) if mask(I) != 0</em></p>

            <p>In case of floating-point arrays, their machine-specific bit representations
                (usually IEEE754-compliant) are used for the operation. In case of
                multi-channel arrays, each channel is processed independently. In the second
                and third cases above, the scalar is first converted to the array type.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array or a scalar.</dd>
            <dd><code>src2</code> - second input array or a scalar.</dd>
            <dd><code>dst</code> - output array that has the same size and type as the input arrays.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#bitwise-and">org.opencv.core.Core.bitwise_and</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="bitwise_and(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>bitwise_and</h4>
<pre>public static&nbsp;void&nbsp;bitwise_and(<a href="../../../org/opencv/core/Mat.html"
                                                 title="class in org.opencv.core">Mat</a>&nbsp;src1,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
        <div class="block"><p>Calculates the per-element bit-wise conjunction of two arrays or an
            array and
            a scalar.</p>

            <p>The function calculates the per-element bit-wise logical conjunction for:</p>
            <ul>
                <li> Two arrays when <code>src1</code> and <code>src2</code> have the same
                    size:
            </ul>

            <p><em>dst(I) = src1(I) / src2(I) if mask(I) != 0</em></p>

            <ul>
                <li> An array and a scalar when <code>src2</code> is constructed from
                    <code>Scalar</code> or has the same number of elements as
                    <code>src1.channels()</code>:
            </ul>

            <p><em>dst(I) = src1(I) / src2 if mask(I) != 0</em></p>

            <ul>
                <li> A scalar and an array when <code>src1</code> is constructed from
                    <code>Scalar</code> or has the same number of elements as
                    <code>src2.channels()</code>:
            </ul>

            <p><em>dst(I) = src1 / src2(I) if mask(I) != 0</em></p>

            <p>In case of floating-point arrays, their machine-specific bit representations
                (usually IEEE754-compliant) are used for the operation. In case of
                multi-channel arrays, each channel is processed independently. In the second
                and third cases above, the scalar is first converted to the array type.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array or a scalar.</dd>
            <dd><code>src2</code> - second input array or a scalar.</dd>
            <dd><code>dst</code> - output array that has the same size and type as the input arrays.
            </dd>
            <dd><code>mask</code> - optional operation mask, 8-bit single channel array, that
                specifies elements of the output array to be changed.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#bitwise-and">org.opencv.core.Core.bitwise_and</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="bitwise_not(org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>bitwise_not</h4>
<pre>public static&nbsp;void&nbsp;bitwise_not(<a href="../../../org/opencv/core/Mat.html"
                                                 title="class in org.opencv.core">Mat</a>&nbsp;src,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Inverts every bit of an array.</p>

            <p>The function calculates per-element bit-wise inversion of the input array:</p>

            <p><em>dst(I) = !src(I)</em></p>

            <p>In case of a floating-point input array, its machine-specific bit
                representation (usually IEEE754-compliant) is used for the operation. In case
                of multi-channel arrays, each channel is processed independently.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input array.</dd>
            <dd><code>dst</code> - output array that has the same size and type as the input array.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#bitwise-not">org.opencv.core.Core.bitwise_not</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="bitwise_not(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>bitwise_not</h4>
<pre>public static&nbsp;void&nbsp;bitwise_not(<a href="../../../org/opencv/core/Mat.html"
                                                 title="class in org.opencv.core">Mat</a>&nbsp;src,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
        <div class="block"><p>Inverts every bit of an array.</p>

            <p>The function calculates per-element bit-wise inversion of the input array:</p>

            <p><em>dst(I) = !src(I)</em></p>

            <p>In case of a floating-point input array, its machine-specific bit
                representation (usually IEEE754-compliant) is used for the operation. In case
                of multi-channel arrays, each channel is processed independently.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input array.</dd>
            <dd><code>dst</code> - output array that has the same size and type as the input array.
            </dd>
            <dd><code>mask</code> - optional operation mask, 8-bit single channel array, that
                specifies elements of the output array to be changed.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#bitwise-not">org.opencv.core.Core.bitwise_not</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="bitwise_or(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>bitwise_or</h4>
<pre>public static&nbsp;void&nbsp;bitwise_or(<a href="../../../org/opencv/core/Mat.html"
                                                title="class in org.opencv.core">Mat</a>&nbsp;src1,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Calculates the per-element bit-wise disjunction of two arrays or an
            array and
            a scalar.</p>

            <p>The function calculates the per-element bit-wise logical disjunction for:</p>
            <ul>
                <li> Two arrays when <code>src1</code> and <code>src2</code> have the same
                    size:
            </ul>

            <p><em>dst(I) = src1(I) V src2(I) if mask(I) != 0</em></p>

            <ul>
                <li> An array and a scalar when <code>src2</code> is constructed from
                    <code>Scalar</code> or has the same number of elements as
                    <code>src1.channels()</code>:
            </ul>

            <p><em>dst(I) = src1(I) V src2 if mask(I) != 0</em></p>

            <ul>
                <li> A scalar and an array when <code>src1</code> is constructed from
                    <code>Scalar</code> or has the same number of elements as
                    <code>src2.channels()</code>:
            </ul>

            <p><em>dst(I) = src1 V src2(I) if mask(I) != 0</em></p>

            <p>In case of floating-point arrays, their machine-specific bit representations
                (usually IEEE754-compliant) are used for the operation. In case of
                multi-channel arrays, each channel is processed independently. In the second
                and third cases above, the scalar is first converted to the array type.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array or a scalar.</dd>
            <dd><code>src2</code> - second input array or a scalar.</dd>
            <dd><code>dst</code> - output array that has the same size and type as the input arrays.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#bitwise-or">org.opencv.core.Core.bitwise_or</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="bitwise_or(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>bitwise_or</h4>
<pre>public static&nbsp;void&nbsp;bitwise_or(<a href="../../../org/opencv/core/Mat.html"
                                                title="class in org.opencv.core">Mat</a>&nbsp;src1,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
        <div class="block"><p>Calculates the per-element bit-wise disjunction of two arrays or an
            array and
            a scalar.</p>

            <p>The function calculates the per-element bit-wise logical disjunction for:</p>
            <ul>
                <li> Two arrays when <code>src1</code> and <code>src2</code> have the same
                    size:
            </ul>

            <p><em>dst(I) = src1(I) V src2(I) if mask(I) != 0</em></p>

            <ul>
                <li> An array and a scalar when <code>src2</code> is constructed from
                    <code>Scalar</code> or has the same number of elements as
                    <code>src1.channels()</code>:
            </ul>

            <p><em>dst(I) = src1(I) V src2 if mask(I) != 0</em></p>

            <ul>
                <li> A scalar and an array when <code>src1</code> is constructed from
                    <code>Scalar</code> or has the same number of elements as
                    <code>src2.channels()</code>:
            </ul>

            <p><em>dst(I) = src1 V src2(I) if mask(I) != 0</em></p>

            <p>In case of floating-point arrays, their machine-specific bit representations
                (usually IEEE754-compliant) are used for the operation. In case of
                multi-channel arrays, each channel is processed independently. In the second
                and third cases above, the scalar is first converted to the array type.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array or a scalar.</dd>
            <dd><code>src2</code> - second input array or a scalar.</dd>
            <dd><code>dst</code> - output array that has the same size and type as the input arrays.
            </dd>
            <dd><code>mask</code> - optional operation mask, 8-bit single channel array, that
                specifies elements of the output array to be changed.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#bitwise-or">org.opencv.core.Core.bitwise_or</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="bitwise_xor(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>bitwise_xor</h4>
<pre>public static&nbsp;void&nbsp;bitwise_xor(<a href="../../../org/opencv/core/Mat.html"
                                                 title="class in org.opencv.core">Mat</a>&nbsp;src1,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Calculates the per-element bit-wise "exclusive or" operation on two
            arrays or
            an array and a scalar.</p>

            <p>The function calculates the per-element bit-wise logical "exclusive-or"
                operation for:</p>
            <ul>
                <li> Two arrays when <code>src1</code> and <code>src2</code> have the same
                    size:
            </ul>

            <p><em>dst(I) = src1(I)(+) src2(I) if mask(I) != 0</em></p>

            <ul>
                <li> An array and a scalar when <code>src2</code> is constructed from
                    <code>Scalar</code> or has the same number of elements as
                    <code>src1.channels()</code>:
            </ul>

            <p><em>dst(I) = src1(I)(+) src2 if mask(I) != 0</em></p>

            <ul>
                <li> A scalar and an array when <code>src1</code> is constructed from
                    <code>Scalar</code> or has the same number of elements as
                    <code>src2.channels()</code>:
            </ul>

            <p><em>dst(I) = src1(+) src2(I) if mask(I) != 0</em></p>

            <p>In case of floating-point arrays, their machine-specific bit representations
                (usually IEEE754-compliant) are used for the operation. In case of
                multi-channel arrays, each channel is processed independently. In the 2nd and
                3rd cases above, the scalar is first converted to the array type.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array or a scalar.</dd>
            <dd><code>src2</code> - second input array or a scalar.</dd>
            <dd><code>dst</code> - output array that has the same size and type as the input arrays.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#bitwise-xor">org.opencv.core.Core.bitwise_xor</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="bitwise_xor(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>bitwise_xor</h4>
<pre>public static&nbsp;void&nbsp;bitwise_xor(<a href="../../../org/opencv/core/Mat.html"
                                                 title="class in org.opencv.core">Mat</a>&nbsp;src1,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
        <div class="block"><p>Calculates the per-element bit-wise "exclusive or" operation on two
            arrays or
            an array and a scalar.</p>

            <p>The function calculates the per-element bit-wise logical "exclusive-or"
                operation for:</p>
            <ul>
                <li> Two arrays when <code>src1</code> and <code>src2</code> have the same
                    size:
            </ul>

            <p><em>dst(I) = src1(I)(+) src2(I) if mask(I) != 0</em></p>

            <ul>
                <li> An array and a scalar when <code>src2</code> is constructed from
                    <code>Scalar</code> or has the same number of elements as
                    <code>src1.channels()</code>:
            </ul>

            <p><em>dst(I) = src1(I)(+) src2 if mask(I) != 0</em></p>

            <ul>
                <li> A scalar and an array when <code>src1</code> is constructed from
                    <code>Scalar</code> or has the same number of elements as
                    <code>src2.channels()</code>:
            </ul>

            <p><em>dst(I) = src1(+) src2(I) if mask(I) != 0</em></p>

            <p>In case of floating-point arrays, their machine-specific bit representations
                (usually IEEE754-compliant) are used for the operation. In case of
                multi-channel arrays, each channel is processed independently. In the 2nd and
                3rd cases above, the scalar is first converted to the array type.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array or a scalar.</dd>
            <dd><code>src2</code> - second input array or a scalar.</dd>
            <dd><code>dst</code> - output array that has the same size and type as the input arrays.
            </dd>
            <dd><code>mask</code> - optional operation mask, 8-bit single channel array, that
                specifies elements of the output array to be changed.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#bitwise-xor">org.opencv.core.Core.bitwise_xor</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="calcCovarMatrix(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>calcCovarMatrix</h4>
<pre>public static&nbsp;void&nbsp;calcCovarMatrix(<a href="../../../org/opencv/core/Mat.html"
                                                     title="class in org.opencv.core">Mat</a>&nbsp;samples,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;covar,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;mean,
                   int&nbsp;flags)</pre>
        <div class="block"><p>Calculates the covariance matrix of a set of vectors.</p>

            <p>The functions <code>calcCovarMatrix</code> calculate the covariance matrix
                and, optionally, the mean vector of the set of input vectors.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>samples</code> - samples stored either as separate matrices or as rows/columns
                of a single matrix.
            </dd>
            <dd><code>covar</code> - output covariance matrix of the type <code>ctype</code> and
                square size.
            </dd>
            <dd><code>mean</code> - input or output (depending on the flags) array as the average
                value of the input vectors.
            </dd>
            <dd><code>flags</code> - operation flags as a combination of the following values:
                <ul>
                    <li> CV_COVAR_SCRAMBLED The output covariance matrix is calculated as:
                </ul>

                <p><em>scale * [ vects [0]- mean, vects [1]- mean,...]^T * [ vects [0]- mean,
                    vects [1]- mean,...],</em></p>

                <p>The covariance matrix will be <code>nsamples x nsamples</code>. Such an
                    unusual covariance matrix is used for fast PCA of a set of very large vectors
                    (see, for example, the EigenFaces technique for face recognition).
                    Eigenvalues of this "scrambled" matrix match the eigenvalues of the true
                    covariance matrix. The "true" eigenvectors can be easily calculated from the
                    eigenvectors of the "scrambled" covariance matrix.</p>
                <ul>
                    <li> CV_COVAR_NORMAL The output covariance matrix is calculated as:
                </ul>

                <p><em>scale * [ vects [0]- mean, vects [1]- mean,...] * [ vects [0]- mean,
                    vects [1]- mean,...]^T,</em></p>

                <p><code>covar</code> will be a square matrix of the same size as the total
                    number of elements in each input vector. One and only one of
                    <code>CV_COVAR_SCRAMBLED</code> and <code>CV_COVAR_NORMAL</code> must be
                    specified.</p>
                <ul>
                    <li> CV_COVAR_USE_AVG If the flag is specified, the function does not
                        calculate <code>mean</code> from the input vectors but, instead, uses the
                        passed <code>mean</code> vector. This is useful if <code>mean</code> has
                        been
                        pre-calculated or known in advance, or if the covariance matrix is
                        calculated
                        by parts. In this case, <code>mean</code> is not a mean vector of the input
                        sub-set of vectors but rather the mean vector of the whole set.
                    <li> CV_COVAR_SCALE If the flag is specified, the covariance matrix is
                        scaled. In the "normal" mode, <code>scale</code> is <code>1./nsamples</code>.
                        In the "scrambled" mode, <code>scale</code> is the reciprocal of the total
                        number of elements in each input vector. By default (if the flag is not
                        specified), the covariance matrix is not scaled (<code>scale=1</code>).
                    <li> CV_COVAR_ROWS [Only useful in the second variant of the function] If
                        the flag is specified, all the input vectors are stored as rows of the
                        <code>samples</code> matrix. <code>mean</code> should be a single-row vector
                        in this case.
                    <li> CV_COVAR_COLS [Only useful in the second variant of the function] If
                        the flag is specified, all the input vectors are stored as columns of the
                        <code>samples</code> matrix. <code>mean</code> should be a single-column
                        vector in this case.
                </ul>
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#calccovarmatrix">org.opencv.core.Core.calcCovarMatrix</a>,
                <a href="../../../org/opencv/core/Core.html#Mahalanobis(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Mahalanobis(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#mulTransposed(org.opencv.core.Mat, org.opencv.core.Mat, boolean, org.opencv.core.Mat, double, int)"><code>mulTransposed(org.opencv.core.Mat,
                    org.opencv.core.Mat, boolean, org.opencv.core.Mat, double, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="calcCovarMatrix(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>calcCovarMatrix</h4>
<pre>public static&nbsp;void&nbsp;calcCovarMatrix(<a href="../../../org/opencv/core/Mat.html"
                                                     title="class in org.opencv.core">Mat</a>&nbsp;samples,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;covar,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;mean,
                   int&nbsp;flags,
                   int&nbsp;ctype)</pre>
        <div class="block"><p>Calculates the covariance matrix of a set of vectors.</p>

            <p>The functions <code>calcCovarMatrix</code> calculate the covariance matrix
                and, optionally, the mean vector of the set of input vectors.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>samples</code> - samples stored either as separate matrices or as rows/columns
                of a single matrix.
            </dd>
            <dd><code>covar</code> - output covariance matrix of the type <code>ctype</code> and
                square size.
            </dd>
            <dd><code>mean</code> - input or output (depending on the flags) array as the average
                value of the input vectors.
            </dd>
            <dd><code>flags</code> - operation flags as a combination of the following values:
                <ul>
                    <li> CV_COVAR_SCRAMBLED The output covariance matrix is calculated as:
                </ul>

                <p><em>scale * [ vects [0]- mean, vects [1]- mean,...]^T * [ vects [0]- mean,
                    vects [1]- mean,...],</em></p>

                <p>The covariance matrix will be <code>nsamples x nsamples</code>. Such an
                    unusual covariance matrix is used for fast PCA of a set of very large vectors
                    (see, for example, the EigenFaces technique for face recognition).
                    Eigenvalues of this "scrambled" matrix match the eigenvalues of the true
                    covariance matrix. The "true" eigenvectors can be easily calculated from the
                    eigenvectors of the "scrambled" covariance matrix.</p>
                <ul>
                    <li> CV_COVAR_NORMAL The output covariance matrix is calculated as:
                </ul>

                <p><em>scale * [ vects [0]- mean, vects [1]- mean,...] * [ vects [0]- mean,
                    vects [1]- mean,...]^T,</em></p>

                <p><code>covar</code> will be a square matrix of the same size as the total
                    number of elements in each input vector. One and only one of
                    <code>CV_COVAR_SCRAMBLED</code> and <code>CV_COVAR_NORMAL</code> must be
                    specified.</p>
                <ul>
                    <li> CV_COVAR_USE_AVG If the flag is specified, the function does not
                        calculate <code>mean</code> from the input vectors but, instead, uses the
                        passed <code>mean</code> vector. This is useful if <code>mean</code> has
                        been
                        pre-calculated or known in advance, or if the covariance matrix is
                        calculated
                        by parts. In this case, <code>mean</code> is not a mean vector of the input
                        sub-set of vectors but rather the mean vector of the whole set.
                    <li> CV_COVAR_SCALE If the flag is specified, the covariance matrix is
                        scaled. In the "normal" mode, <code>scale</code> is <code>1./nsamples</code>.
                        In the "scrambled" mode, <code>scale</code> is the reciprocal of the total
                        number of elements in each input vector. By default (if the flag is not
                        specified), the covariance matrix is not scaled (<code>scale=1</code>).
                    <li> CV_COVAR_ROWS [Only useful in the second variant of the function] If
                        the flag is specified, all the input vectors are stored as rows of the
                        <code>samples</code> matrix. <code>mean</code> should be a single-row vector
                        in this case.
                    <li> CV_COVAR_COLS [Only useful in the second variant of the function] If
                        the flag is specified, all the input vectors are stored as columns of the
                        <code>samples</code> matrix. <code>mean</code> should be a single-column
                        vector in this case.
                </ul>
            </dd>
            <dd><code>ctype</code> - type of the matrixl; it equals 'CV_64F' by default.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#calccovarmatrix">org.opencv.core.Core.calcCovarMatrix</a>,
                <a href="../../../org/opencv/core/Core.html#Mahalanobis(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Mahalanobis(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#mulTransposed(org.opencv.core.Mat, org.opencv.core.Mat, boolean, org.opencv.core.Mat, double, int)"><code>mulTransposed(org.opencv.core.Mat,
                    org.opencv.core.Mat, boolean, org.opencv.core.Mat, double, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="cartToPolar(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>cartToPolar</h4>
<pre>public static&nbsp;void&nbsp;cartToPolar(<a href="../../../org/opencv/core/Mat.html"
                                                 title="class in org.opencv.core">Mat</a>&nbsp;x,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;y,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;magnitude,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;angle)</pre>
        <div class="block"><p>Calculates the magnitude and angle of 2D vectors.</p>

            <p>The function <code>cartToPolar</code> calculates either the magnitude, angle,
                or both for every 2D vector (x(I),y(I)):</p>

            <p><em>magnitude(I)= sqrt(x(I)^2+y(I)^2),
                angle(I)= atan2(y(I), x(I))[ *180 / pi ] </em></p>

            <p>The angles are calculated with accuracy about 0.3 degrees. For the point
                (0,0), the angle is set to 0.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>x</code> - array of x-coordinates; this must be a single-precision or
                double-precision floating-point array.
            </dd>
            <dd><code>y</code> - array of y-coordinates, that must have the same size and same type
                as <code>x</code>.
            </dd>
            <dd><code>magnitude</code> - output array of magnitudes of the same size and type as
                <code>x</code>.
            </dd>
            <dd><code>angle</code> - output array of angles that has the same size and type as
                <code>x</code>; the angles are measured in radians (from 0 to 2*Pi) or in
                degrees (0 to 360 degrees).
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#carttopolar">org.opencv.core.Core.cartToPolar</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#Scharr(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, double, double, int)"><code>Imgproc.Scharr(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int, int, double, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#Sobel(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, int, double, double, int)"><code>Imgproc.Sobel(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int, int, int, double, double, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="cartToPolar(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>cartToPolar</h4>
<pre>public static&nbsp;void&nbsp;cartToPolar(<a href="../../../org/opencv/core/Mat.html"
                                                 title="class in org.opencv.core">Mat</a>&nbsp;x,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;y,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;magnitude,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;angle,
               boolean&nbsp;angleInDegrees)</pre>
        <div class="block"><p>Calculates the magnitude and angle of 2D vectors.</p>

            <p>The function <code>cartToPolar</code> calculates either the magnitude, angle,
                or both for every 2D vector (x(I),y(I)):</p>

            <p><em>magnitude(I)= sqrt(x(I)^2+y(I)^2),
                angle(I)= atan2(y(I), x(I))[ *180 / pi ] </em></p>

            <p>The angles are calculated with accuracy about 0.3 degrees. For the point
                (0,0), the angle is set to 0.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>x</code> - array of x-coordinates; this must be a single-precision or
                double-precision floating-point array.
            </dd>
            <dd><code>y</code> - array of y-coordinates, that must have the same size and same type
                as <code>x</code>.
            </dd>
            <dd><code>magnitude</code> - output array of magnitudes of the same size and type as
                <code>x</code>.
            </dd>
            <dd><code>angle</code> - output array of angles that has the same size and type as
                <code>x</code>; the angles are measured in radians (from 0 to 2*Pi) or in
                degrees (0 to 360 degrees).
            </dd>
            <dd><code>angleInDegrees</code> - a flag, indicating whether the angles are measured in
                radians (which is by default), or in degrees.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#carttopolar">org.opencv.core.Core.cartToPolar</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#Scharr(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, double, double, int)"><code>Imgproc.Scharr(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int, int, double, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#Sobel(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, int, double, double, int)"><code>Imgproc.Sobel(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int, int, int, double, double, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="checkRange(org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>checkRange</h4>
        <pre>public static&nbsp;boolean&nbsp;checkRange(<a href="../../../org/opencv/core/Mat.html"
                                                           title="class in org.opencv.core">Mat</a>&nbsp;a)</pre>
        <div class="block"><p>Checks every element of an input array for invalid values.</p>

            <p>The functions <code>checkRange</code> check that every array element is
                neither NaN nor infinite. When <code>minVal < -DBL_MAX</code> and
                <code>maxVal < DBL_MAX</code>, the functions also check that each value is
                between <code>minVal</code> and <code>maxVal</code>. In case of multi-channel
                arrays, each channel is processed independently.
                If some values are out of range, position of the first outlier is stored in
                <code>pos</code> (when <code>pos != NULL</code>). Then, the functions either
                return false (when <code>quiet=true</code>) or throw an exception.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>a</code> - input array.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#checkrange">org.opencv.core.Core.checkRange</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="checkRange(org.opencv.core.Mat, boolean, double, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>checkRange</h4>
<pre>public static&nbsp;boolean&nbsp;checkRange(<a href="../../../org/opencv/core/Mat.html"
                                                   title="class in org.opencv.core">Mat</a>&nbsp;a,
                 boolean&nbsp;quiet,
                 double&nbsp;minVal,
                 double&nbsp;maxVal)</pre>
        <div class="block"><p>Checks every element of an input array for invalid values.</p>

            <p>The functions <code>checkRange</code> check that every array element is
                neither NaN nor infinite. When <code>minVal < -DBL_MAX</code> and
                <code>maxVal < DBL_MAX</code>, the functions also check that each value is
                between <code>minVal</code> and <code>maxVal</code>. In case of multi-channel
                arrays, each channel is processed independently.
                If some values are out of range, position of the first outlier is stored in
                <code>pos</code> (when <code>pos != NULL</code>). Then, the functions either
                return false (when <code>quiet=true</code>) or throw an exception.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>a</code> - input array.</dd>
            <dd><code>quiet</code> - a flag, indicating whether the functions quietly return false
                when the array elements are out of range or they throw an exception.
            </dd>
            <dd><code>minVal</code> - inclusive lower boundary of valid values range.</dd>
            <dd><code>maxVal</code> - exclusive upper boundary of valid values range.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#checkrange">org.opencv.core.Core.checkRange</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="circle(org.opencv.core.Mat, org.opencv.core.Point, int, org.opencv.core.Scalar)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>circle</h4>
<pre>public static&nbsp;void&nbsp;circle(<a href="../../../org/opencv/core/Mat.html"
                                            title="class in org.opencv.core">Mat</a>&nbsp;img,
          <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
          int&nbsp;radius,
          <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</pre>
        <div class="block"><p>Draws a circle.</p>

            <p>The function <code>circle</code> draws a simple or filled circle with a given
                center and radius.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>img</code> - Image where the circle is drawn.</dd>
            <dd><code>center</code> - Center of the circle.</dd>
            <dd><code>radius</code> - Radius of the circle.</dd>
            <dd><code>color</code> - Circle color.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#circle">org.opencv.core.Core.circle</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="circle(org.opencv.core.Mat, org.opencv.core.Point, int, org.opencv.core.Scalar, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>circle</h4>
<pre>public static&nbsp;void&nbsp;circle(<a href="../../../org/opencv/core/Mat.html"
                                            title="class in org.opencv.core">Mat</a>&nbsp;img,
          <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
          int&nbsp;radius,
          <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
          int&nbsp;thickness)</pre>
        <div class="block"><p>Draws a circle.</p>

            <p>The function <code>circle</code> draws a simple or filled circle with a given
                center and radius.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>img</code> - Image where the circle is drawn.</dd>
            <dd><code>center</code> - Center of the circle.</dd>
            <dd><code>radius</code> - Radius of the circle.</dd>
            <dd><code>color</code> - Circle color.</dd>
            <dd><code>thickness</code> - Thickness of the circle outline, if positive. Negative
                thickness means that a filled circle is to be drawn.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#circle">org.opencv.core.Core.circle</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="circle(org.opencv.core.Mat, org.opencv.core.Point, int, org.opencv.core.Scalar, int, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>circle</h4>
<pre>public static&nbsp;void&nbsp;circle(<a href="../../../org/opencv/core/Mat.html"
                                            title="class in org.opencv.core">Mat</a>&nbsp;img,
          <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
          int&nbsp;radius,
          <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
          int&nbsp;thickness,
          int&nbsp;lineType,
          int&nbsp;shift)</pre>
        <div class="block"><p>Draws a circle.</p>

            <p>The function <code>circle</code> draws a simple or filled circle with a given
                center and radius.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>img</code> - Image where the circle is drawn.</dd>
            <dd><code>center</code> - Center of the circle.</dd>
            <dd><code>radius</code> - Radius of the circle.</dd>
            <dd><code>color</code> - Circle color.</dd>
            <dd><code>thickness</code> - Thickness of the circle outline, if positive. Negative
                thickness means that a filled circle is to be drawn.
            </dd>
            <dd><code>lineType</code> - Type of the circle boundary. See the "line" description.
            </dd>
            <dd><code>shift</code> - Number of fractional bits in the coordinates of the center and
                in the radius value.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#circle">org.opencv.core.Core.circle</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="clipLine(org.opencv.core.Rect, org.opencv.core.Point, org.opencv.core.Point)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>clipLine</h4>
<pre>public static&nbsp;boolean&nbsp;clipLine(<a href="../../../org/opencv/core/Rect.html"
                                                 title="class in org.opencv.core">Rect</a>&nbsp;imgRect,
               <a href="../../../org/opencv/core/Point.html"
                  title="class in org.opencv.core">Point</a>&nbsp;pt1,
               <a href="../../../org/opencv/core/Point.html"
                  title="class in org.opencv.core">Point</a>&nbsp;pt2)</pre>
        <div class="block"><p>Clips the line against the image rectangle.</p>

            <p>The functions <code>clipLine</code> calculate a part of the line segment that
                is entirely within the specified rectangle.
                They return <code>false</code> if the line segment is completely outside the
                rectangle. Otherwise, they return <code>true</code>.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>imgRect</code> - Image rectangle.</dd>
            <dd><code>pt1</code> - First line point.</dd>
            <dd><code>pt2</code> - Second line point.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#clipline">org.opencv.core.Core.clipLine</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="compare(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>compare</h4>
<pre>public static&nbsp;void&nbsp;compare(<a href="../../../org/opencv/core/Mat.html"
                                             title="class in org.opencv.core">Mat</a>&nbsp;src1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
           int&nbsp;cmpop)</pre>
        <div class="block"><p>Performs the per-element comparison of two arrays or an array and
            scalar
            value.</p>

            <p>The function compares:</p>
            <ul>
                <li> Elements of two arrays when <code>src1</code> and <code>src2</code>
                    have the same size:
            </ul>

            <p><em>dst(I) = src1(I) cmpop src2(I)</em></p>

            <ul>
                <li> Elements of <code>src1</code> with a scalar <code>src2</code> when
                    <code>src2</code> is constructed from <code>Scalar</code> or has a single
                    element:
            </ul>

            <p><em>dst(I) = src1(I) cmpop src2</em></p>

            <ul>
                <li><code>src1</code> with elements of <code>src2</code> when
                    <code>src1</code> is constructed from <code>Scalar</code> or has a single
                    element:
            </ul>

            <p><em>dst(I) = src1 cmpop src2(I)</em></p>

            <p>When the comparison result is true, the corresponding element of output array
                is set to 255.The comparison operations can be replaced with the equivalent
                matrix expressions: <code></p>

            <p>// C++ code:</p>

            <p>Mat dst1 = src1 >= src2;</p>

            <p>Mat dst2 = src1 < 8;...</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array or a scalar (in the case of <code>cvCmp</code>,
                <code>cv.Cmp</code>, <code>cvCmpS</code>, <code>cv.CmpS</code> it is always
                an array); when it is an array, it must have a single channel.
            </dd>
            <dd><code>src2</code> - second input array or a scalar (in the case of
                <code>cvCmp</code>
                and <code>cv.Cmp</code> it is always an array; in the case of
                <code>cvCmpS</code>, <code>cv.CmpS</code> it is always a scalar); when it is
                an array, it must have a single channel.
            </dd>
            <dd><code>dst</code> - output array that has the same size and type as the input arrays.
            </dd>
            <dd><code>cmpop</code> - a flag, that specifies correspondence between the arrays:
                <ul>
                    <li> CMP_EQ <code>src1</code> is equal to <code>src2</code>.
                    <li> CMP_GT <code>src1</code> is greater than <code>src2</code>.
                    <li> CMP_GE <code>src1</code> is greater than or equal to <code>src2</code>.
                    <li> CMP_LT <code>src1</code> is less than <code>src2</code>.
                    <li> CMP_LE <code>src1</code> is less than or equal to <code>src2</code>.
                    <li> CMP_NE <code>src1</code> is unequal to <code>src2</code>.
                </ul>
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#compare">org.opencv.core.Core.compare</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#threshold(org.opencv.core.Mat, org.opencv.core.Mat, double, double, int)"><code>Imgproc.threshold(org.opencv.core.Mat,
                    org.opencv.core.Mat, double, double, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#max(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>max(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#checkRange(org.opencv.core.Mat, boolean, double, double)"><code>checkRange(org.opencv.core.Mat,
                    boolean, double, double)</code></a>,
                <a href="../../../org/opencv/core/Core.html#min(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>min(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="compare(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>compare</h4>
<pre>public static&nbsp;void&nbsp;compare(<a href="../../../org/opencv/core/Mat.html"
                                             title="class in org.opencv.core">Mat</a>&nbsp;src1,
           <a href="../../../org/opencv/core/Scalar.html"
              title="class in org.opencv.core">Scalar</a>&nbsp;src2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
           int&nbsp;cmpop)</pre>
        <div class="block"><p>Performs the per-element comparison of two arrays or an array and
            scalar
            value.</p>

            <p>The function compares:</p>
            <ul>
                <li> Elements of two arrays when <code>src1</code> and <code>src2</code>
                    have the same size:
            </ul>

            <p><em>dst(I) = src1(I) cmpop src2(I)</em></p>

            <ul>
                <li> Elements of <code>src1</code> with a scalar <code>src2</code> when
                    <code>src2</code> is constructed from <code>Scalar</code> or has a single
                    element:
            </ul>

            <p><em>dst(I) = src1(I) cmpop src2</em></p>

            <ul>
                <li><code>src1</code> with elements of <code>src2</code> when
                    <code>src1</code> is constructed from <code>Scalar</code> or has a single
                    element:
            </ul>

            <p><em>dst(I) = src1 cmpop src2(I)</em></p>

            <p>When the comparison result is true, the corresponding element of output array
                is set to 255.The comparison operations can be replaced with the equivalent
                matrix expressions: <code></p>

            <p>// C++ code:</p>

            <p>Mat dst1 = src1 >= src2;</p>

            <p>Mat dst2 = src1 < 8;...</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array or a scalar (in the case of <code>cvCmp</code>,
                <code>cv.Cmp</code>, <code>cvCmpS</code>, <code>cv.CmpS</code> it is always
                an array); when it is an array, it must have a single channel.
            </dd>
            <dd><code>src2</code> - second input array or a scalar (in the case of
                <code>cvCmp</code>
                and <code>cv.Cmp</code> it is always an array; in the case of
                <code>cvCmpS</code>, <code>cv.CmpS</code> it is always a scalar); when it is
                an array, it must have a single channel.
            </dd>
            <dd><code>dst</code> - output array that has the same size and type as the input arrays.
            </dd>
            <dd><code>cmpop</code> - a flag, that specifies correspondence between the arrays:
                <ul>
                    <li> CMP_EQ <code>src1</code> is equal to <code>src2</code>.
                    <li> CMP_GT <code>src1</code> is greater than <code>src2</code>.
                    <li> CMP_GE <code>src1</code> is greater than or equal to <code>src2</code>.
                    <li> CMP_LT <code>src1</code> is less than <code>src2</code>.
                    <li> CMP_LE <code>src1</code> is less than or equal to <code>src2</code>.
                    <li> CMP_NE <code>src1</code> is unequal to <code>src2</code>.
                </ul>
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#compare">org.opencv.core.Core.compare</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#threshold(org.opencv.core.Mat, org.opencv.core.Mat, double, double, int)"><code>Imgproc.threshold(org.opencv.core.Mat,
                    org.opencv.core.Mat, double, double, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#max(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>max(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#checkRange(org.opencv.core.Mat, boolean, double, double)"><code>checkRange(org.opencv.core.Mat,
                    boolean, double, double)</code></a>,
                <a href="../../../org/opencv/core/Core.html#min(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>min(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="completeSymm(org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>completeSymm</h4>
        <pre>public static&nbsp;void&nbsp;completeSymm(<a href="../../../org/opencv/core/Mat.html"
                                                          title="class in org.opencv.core">Mat</a>&nbsp;mtx)</pre>
        <div class="block"><p>Copies the lower or the upper half of a square matrix to another
            half.</p>

            <p>The function <code>completeSymm</code> copies the lower half of a square
                matrix to its another half. The matrix diagonal remains unchanged:</p>
            <ul>
                <li><em>mtx_(ij)=mtx_(ji)</em> for <em>i &gt j</em> if
                    <code>lowerToUpper=false</code>
                <li><em>mtx_(ij)=mtx_(ji)</em> for <em>i &lt j</em> if
                    <code>lowerToUpper=true</code>
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>mtx</code> - input-output floating-point square matrix.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#completesymm">org.opencv.core.Core.completeSymm</a>,
                <a href="../../../org/opencv/core/Core.html#transpose(org.opencv.core.Mat, org.opencv.core.Mat)"><code>transpose(org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#flip(org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>flip(org.opencv.core.Mat,
                    org.opencv.core.Mat, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="completeSymm(org.opencv.core.Mat, boolean)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>completeSymm</h4>
<pre>public static&nbsp;void&nbsp;completeSymm(<a href="../../../org/opencv/core/Mat.html"
                                                  title="class in org.opencv.core">Mat</a>&nbsp;mtx,
                boolean&nbsp;lowerToUpper)</pre>
        <div class="block"><p>Copies the lower or the upper half of a square matrix to another
            half.</p>

            <p>The function <code>completeSymm</code> copies the lower half of a square
                matrix to its another half. The matrix diagonal remains unchanged:</p>
            <ul>
                <li><em>mtx_(ij)=mtx_(ji)</em> for <em>i &gt j</em> if
                    <code>lowerToUpper=false</code>
                <li><em>mtx_(ij)=mtx_(ji)</em> for <em>i &lt j</em> if
                    <code>lowerToUpper=true</code>
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>mtx</code> - input-output floating-point square matrix.</dd>
            <dd><code>lowerToUpper</code> - operation flag; if true, the lower half is copied to the
                upper half. Otherwise, the upper half is copied to the lower half.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#completesymm">org.opencv.core.Core.completeSymm</a>,
                <a href="../../../org/opencv/core/Core.html#transpose(org.opencv.core.Mat, org.opencv.core.Mat)"><code>transpose(org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#flip(org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>flip(org.opencv.core.Mat,
                    org.opencv.core.Mat, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="convertScaleAbs(org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>convertScaleAbs</h4>
<pre>public static&nbsp;void&nbsp;convertScaleAbs(<a href="../../../org/opencv/core/Mat.html"
                                                     title="class in org.opencv.core">Mat</a>&nbsp;src,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Scales, calculates absolute values, and converts the result to
            8-bit.</p>

            <p>On each element of the input array, the function <code>convertScaleAbs</code>
                performs three operations sequentially: scaling, taking an absolute value,
                conversion to an unsigned 8-bit type:</p>

            <p><em>dst(I)= saturate_cast&ltuchar&gt(| src(I)* alpha + beta|)&ltBR&gtIn case
                of multi-channel arrays, the function processes each channel independently.
                When the output is not 8-bit, the operation can be emulated by calling the
                <code>Mat.convertTo</code> method(or by using matrix expressions) and then
                by calculating an absolute value of the result. For example:
                &ltBR&gt&ltcode&gt</em></p>

            <p>// C++ code:</p>

            <p>Mat_
                <float> A(30,30);
            </p>

            <p>randu(A, Scalar(-100), Scalar(100));</p>

            <p>Mat_
                <float> B = A*5 + 3;
            </p>

            <p>B = abs(B);</p>

            <p>// Mat_
                <float> B = abs(A*5+3) will also do the job,
            </p>

            <p>// but it will allocate a temporary matrix</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input array.</dd>
            <dd><code>dst</code> - output array.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#convertscaleabs">org.opencv.core.Core.convertScaleAbs</a>,
                <a href="../../../org/opencv/core/Mat.html#convertTo(org.opencv.core.Mat, int, double, double)"><code>Mat.convertTo(org.opencv.core.Mat,
                    int, double, double)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="convertScaleAbs(org.opencv.core.Mat, org.opencv.core.Mat, double, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>convertScaleAbs</h4>
<pre>public static&nbsp;void&nbsp;convertScaleAbs(<a href="../../../org/opencv/core/Mat.html"
                                                     title="class in org.opencv.core">Mat</a>&nbsp;src,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;dst,
                   double&nbsp;alpha,
                   double&nbsp;beta)</pre>
        <div class="block"><p>Scales, calculates absolute values, and converts the result to
            8-bit.</p>

            <p>On each element of the input array, the function <code>convertScaleAbs</code>
                performs three operations sequentially: scaling, taking an absolute value,
                conversion to an unsigned 8-bit type:</p>

            <p><em>dst(I)= saturate_cast&ltuchar&gt(| src(I)* alpha + beta|)&ltBR&gtIn case
                of multi-channel arrays, the function processes each channel independently.
                When the output is not 8-bit, the operation can be emulated by calling the
                <code>Mat.convertTo</code> method(or by using matrix expressions) and then
                by calculating an absolute value of the result. For example:
                &ltBR&gt&ltcode&gt</em></p>

            <p>// C++ code:</p>

            <p>Mat_
                <float> A(30,30);
            </p>

            <p>randu(A, Scalar(-100), Scalar(100));</p>

            <p>Mat_
                <float> B = A*5 + 3;
            </p>

            <p>B = abs(B);</p>

            <p>// Mat_
                <float> B = abs(A*5+3) will also do the job,
            </p>

            <p>// but it will allocate a temporary matrix</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input array.</dd>
            <dd><code>dst</code> - output array.</dd>
            <dd><code>alpha</code> - optional scale factor.</dd>
            <dd><code>beta</code> - optional delta added to the scaled values.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#convertscaleabs">org.opencv.core.Core.convertScaleAbs</a>,
                <a href="../../../org/opencv/core/Mat.html#convertTo(org.opencv.core.Mat, int, double, double)"><code>Mat.convertTo(org.opencv.core.Mat,
                    int, double, double)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="countNonZero(org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>countNonZero</h4>
        <pre>public static&nbsp;int&nbsp;countNonZero(<a href="../../../org/opencv/core/Mat.html"
                                                         title="class in org.opencv.core">Mat</a>&nbsp;src)</pre>
        <div class="block"><p>Counts non-zero array elements.</p>

            <p>The function returns the number of non-zero elements in <code>src</code> :</p>

            <p><em>sum(by: I: src(I) != 0) 1</em></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - single-channel array.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#countnonzero">org.opencv.core.Core.countNonZero</a>,
                <a href="../../../org/opencv/core/Core.html#minMaxLoc(org.opencv.core.Mat, org.opencv.core.Mat)"><code>minMaxLoc(org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#calcCovarMatrix(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int)"><code>calcCovarMatrix(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, int, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#meanStdDev(org.opencv.core.Mat, org.opencv.core.MatOfDouble, org.opencv.core.MatOfDouble, org.opencv.core.Mat)"><code>meanStdDev(org.opencv.core.Mat,
                    org.opencv.core.MatOfDouble, org.opencv.core.MatOfDouble,
                    org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#norm(org.opencv.core.Mat, int, org.opencv.core.Mat)"><code>norm(org.opencv.core.Mat,
                    int, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#mean(org.opencv.core.Mat, org.opencv.core.Mat)"><code>mean(org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="cubeRoot(float)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>cubeRoot</h4>
        <pre>public static&nbsp;float&nbsp;cubeRoot(float&nbsp;val)</pre>
        <div class="block"><p>Computes the cube root of an argument.</p>

            <p>The function <code>cubeRoot</code> computes <em>sqrt3(val)</em>. Negative
                arguments are handled correctly. NaN and Inf are not handled. The accuracy
                approaches the maximum possible accuracy for single-precision data.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>val</code> - A function argument.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/utility_and_system_functions_and_macros.html#cuberoot">org.opencv.core.Core.cubeRoot</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="dct(org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>dct</h4>
<pre>public static&nbsp;void&nbsp;dct(<a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a>&nbsp;src,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Performs a forward or inverse discrete Cosine transform of 1D or 2D
            array.</p>

            <p>The function <code>dct</code> performs a forward or inverse discrete Cosine
                transform (DCT) of a 1D or 2D floating-point array:</p>
            <ul>
                <li> Forward Cosine transform of a 1D vector of <code>N</code> elements:
            </ul>

            <p><em>Y = C^N * X</em></p>

            <p>where</p>

            <p><em>C^N_(jk)= sqrt(alpha_j/N) cos((pi(2k+1)j)/(2N))</em></p>

            <p>and</p>

            <p><em>alpha_0=1</em>, <em>alpha_j=2</em> for *j > 0*.</p>
            <ul>
                <li> Inverse Cosine transform of a 1D vector of <code>N</code> elements:
            </ul>

            <p><em>X = (C^N)^(-1) * Y = (C^N)^T * Y</em></p>

            <p>(since <em>C^N</em> is an orthogonal matrix, <em>C^N * (C^N)^T = I</em>)</p>
            <ul>
                <li> Forward 2D Cosine transform of <code>M x N</code> matrix:
            </ul>

            <p><em>Y = C^N * X * (C^N)^T</em></p>

            <ul>
                <li> Inverse 2D Cosine transform of <code>M x N</code> matrix:
            </ul>

            <p><em>X = (C^N)^T * X * C^N</em></p>

            <p>The function chooses the mode of operation by looking at the flags and size
                of the input array:</p>
            <ul>
                <li> If <code>(flags & DCT_INVERSE) == 0</code>, the function does a
                    forward 1D or 2D transform. Otherwise, it is an inverse 1D or 2D transform.
                <li> If <code>(flags & DCT_ROWS) != 0</code>, the function performs a 1D
                    transform of each row.
                <li> If the array is a single column or a single row, the function performs
                    a 1D transform.
                <li> If none of the above is true, the function performs a 2D transform.
            </ul>

            <p>Note:</p>

            <p>Currently <code>dct</code> supports even-size arrays (2, 4, 6...). For data
                analysis and approximation, you can pad the array when necessary.</p>

            <p>Also, the function performance depends very much, and not monotonically, on
                the array size (see"getOptimalDFTSize"). In the current implementation DCT of
                a vector of size <code>N</code> is calculated via DFT of a vector of size
                <code>N/2</code>. Thus, the optimal DCT size <code>N1 >= N</code> can be
                calculated as: <code></p>

            <p>// C++ code:</p>

            <p>size_t getOptimalDCTSize(size_t N) { return 2*getOptimalDFTSize((N+1)/2); }</p>

            <p>N1 = getOptimalDCTSize(N);</p>

            <p></code></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input floating-point array.</dd>
            <dd><code>dst</code> - output array of the same size and type as <code>src</code>.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#dct">org.opencv.core.Core.dct</a>,
                <a href="../../../org/opencv/core/Core.html#dft(org.opencv.core.Mat, org.opencv.core.Mat, int, int)"><code>dft(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#idct(org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>idct(org.opencv.core.Mat,
                    org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#getOptimalDFTSize(int)"><code>getOptimalDFTSize(int)</code></a>
            </dd>
        </dl>
    </li>
</ul>
<a name="dct(org.opencv.core.Mat, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>dct</h4>
<pre>public static&nbsp;void&nbsp;dct(<a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a>&nbsp;src,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
       int&nbsp;flags)</pre>
        <div class="block"><p>Performs a forward or inverse discrete Cosine transform of 1D or 2D
            array.</p>

            <p>The function <code>dct</code> performs a forward or inverse discrete Cosine
                transform (DCT) of a 1D or 2D floating-point array:</p>
            <ul>
                <li> Forward Cosine transform of a 1D vector of <code>N</code> elements:
            </ul>

            <p><em>Y = C^N * X</em></p>

            <p>where</p>

            <p><em>C^N_(jk)= sqrt(alpha_j/N) cos((pi(2k+1)j)/(2N))</em></p>

            <p>and</p>

            <p><em>alpha_0=1</em>, <em>alpha_j=2</em> for *j > 0*.</p>
            <ul>
                <li> Inverse Cosine transform of a 1D vector of <code>N</code> elements:
            </ul>

            <p><em>X = (C^N)^(-1) * Y = (C^N)^T * Y</em></p>

            <p>(since <em>C^N</em> is an orthogonal matrix, <em>C^N * (C^N)^T = I</em>)</p>
            <ul>
                <li> Forward 2D Cosine transform of <code>M x N</code> matrix:
            </ul>

            <p><em>Y = C^N * X * (C^N)^T</em></p>

            <ul>
                <li> Inverse 2D Cosine transform of <code>M x N</code> matrix:
            </ul>

            <p><em>X = (C^N)^T * X * C^N</em></p>

            <p>The function chooses the mode of operation by looking at the flags and size
                of the input array:</p>
            <ul>
                <li> If <code>(flags & DCT_INVERSE) == 0</code>, the function does a
                    forward 1D or 2D transform. Otherwise, it is an inverse 1D or 2D transform.
                <li> If <code>(flags & DCT_ROWS) != 0</code>, the function performs a 1D
                    transform of each row.
                <li> If the array is a single column or a single row, the function performs
                    a 1D transform.
                <li> If none of the above is true, the function performs a 2D transform.
            </ul>

            <p>Note:</p>

            <p>Currently <code>dct</code> supports even-size arrays (2, 4, 6...). For data
                analysis and approximation, you can pad the array when necessary.</p>

            <p>Also, the function performance depends very much, and not monotonically, on
                the array size (see"getOptimalDFTSize"). In the current implementation DCT of
                a vector of size <code>N</code> is calculated via DFT of a vector of size
                <code>N/2</code>. Thus, the optimal DCT size <code>N1 >= N</code> can be
                calculated as: <code></p>

            <p>// C++ code:</p>

            <p>size_t getOptimalDCTSize(size_t N) { return 2*getOptimalDFTSize((N+1)/2); }</p>

            <p>N1 = getOptimalDCTSize(N);</p>

            <p></code></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input floating-point array.</dd>
            <dd><code>dst</code> - output array of the same size and type as <code>src</code>.</dd>
            <dd><code>flags</code> - transformation flags as a combination of the following values:
                <ul>
                    <li> DCT_INVERSE performs an inverse 1D or 2D transform instead of the
                        default forward transform.
                    <li> DCT_ROWS performs a forward or inverse transform of every individual
                        row of the input matrix. This flag enables you to transform multiple vectors
                        simultaneously and can be used to decrease the overhead (which is sometimes
                        several times larger than the processing itself) to perform 3D and
                        higher-dimensional transforms and so forth.
                </ul>
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#dct">org.opencv.core.Core.dct</a>,
                <a href="../../../org/opencv/core/Core.html#dft(org.opencv.core.Mat, org.opencv.core.Mat, int, int)"><code>dft(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#idct(org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>idct(org.opencv.core.Mat,
                    org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#getOptimalDFTSize(int)"><code>getOptimalDFTSize(int)</code></a>
            </dd>
        </dl>
    </li>
</ul>
<a name="determinant(org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>determinant</h4>
        <pre>public static&nbsp;double&nbsp;determinant(<a href="../../../org/opencv/core/Mat.html"
                                                           title="class in org.opencv.core">Mat</a>&nbsp;mtx)</pre>
        <div class="block"><p>Returns the determinant of a square floating-point matrix.</p>

            <p>The function <code>determinant</code> calculates and returns the determinant
                of the specified matrix. For small matrices (<code>mtx.cols=mtx.rows<=3</code>),
                the direct method is used. For larger matrices, the function uses LU
                factorization with partial pivoting.</p>

            <p>For symmetric positively-determined matrices, it is also possible to use
                "eigen" decomposition to calculate the determinant.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>mtx</code> - input matrix that must have <code>CV_32FC1</code> or
                <code>CV_64FC1</code> type and square size.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#determinant">org.opencv.core.Core.determinant</a>,
                <a href="../../../org/opencv/core/Core.html#invert(org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>invert(org.opencv.core.Mat,
                    org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#solve(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>solve(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#eigen(org.opencv.core.Mat, boolean, org.opencv.core.Mat, org.opencv.core.Mat)"><code>eigen(org.opencv.core.Mat,
                    boolean, org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#trace(org.opencv.core.Mat)"><code>trace(org.opencv.core.Mat)</code></a>
            </dd>
        </dl>
    </li>
</ul>
<a name="dft(org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dft</h4>
<pre>public static&nbsp;void&nbsp;dft(<a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a>&nbsp;src,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block"><p>Performs a forward or inverse Discrete Fourier transform of a 1D or 2D
    floating-point array.</p>

    <p>The function performs one of the following:</p>
    <ul>
        <li> Forward the Fourier transform of a 1D vector of <code>N</code>
            elements:
    </ul>

    <p><em>Y = F^N * X,</em></p>

    <p>where <em>F^N_(jk)=exp(-2pi i j k/N)</em> and <em>i=sqrt(-1)</em></p>
    <ul>
        <li> Inverse the Fourier transform of a 1D vector of <code>N</code>
            elements:
    </ul>

    <p><em>X'= (F^N)^(-1) * Y = (F^N)^* * y
        X = (1/N) * X, </em></p>

    <p>where <em>F^*=(Re(F^N)-Im(F^N))^T</em></p>
    <ul>
        <li> Forward the 2D Fourier transform of a <code>M x N</code> matrix:
    </ul>

    <p><em>Y = F^M * X * F^N</em></p>

    <ul>
        <li> Inverse the 2D Fourier transform of a <code>M x N</code> matrix:
    </ul>

    <p><em>X'= (F^M)^* * Y * (F^N)^*
        X = 1/(M * N) * X' </em></p>

    <p>In case of real (single-channel) data, the output spectrum of the forward
        Fourier transform or input spectrum of the inverse Fourier transform can be
        represented in a packed format called *CCS* (complex-conjugate-symmetrical).
        It was borrowed from IPL (Intel* Image Processing Library). Here is how 2D
        *CCS* spectrum looks:</p>

    <p><em>Re Y_(0,0) Re Y_(0,1) Im Y_(0,1) Re Y_(0,2) Im Y_(0,2) *s Re Y_(0,N/2-1)
        Im Y_(0,N/2-1) Re Y_(0,N/2)
        Re Y_(1,0) Re Y_(1,1) Im Y_(1,1) Re Y_(1,2) Im Y_(1,2) *s Re Y_(1,N/2-1) Im
        Y_(1,N/2-1) Re Y_(1,N/2)
        Im Y_(1,0) Re Y_(2,1) Im Y_(2,1) Re Y_(2,2) Im Y_(2,2) *s Re Y_(2,N/2-1) Im
        Y_(2,N/2-1) Im Y_(1,N/2)...........................
        Re Y_(M/2-1,0) Re Y_(M-3,1) Im Y_(M-3,1)......... Re Y_(M-3,N/2-1) Im
        Y_(M-3,N/2-1) Re Y_(M/2-1,N/2)
        Im Y_(M/2-1,0) Re Y_(M-2,1) Im Y_(M-2,1)......... Re Y_(M-2,N/2-1) Im
        Y_(M-2,N/2-1) Im Y_(M/2-1,N/2)
        Re Y_(M/2,0) Re Y_(M-1,1) Im Y_(M-1,1)......... Re Y_(M-1,N/2-1) Im
        Y_(M-1,N/2-1) Re Y_(M/2,N/2) </em></p>

    <p>In case of 1D transform of a real vector, the output looks like the first row
        of the matrix above.</p>

    <p>So, the function chooses an operation mode depending on the flags and size of
        the input array:</p>
    <ul>
        <li> If <code>DFT_ROWS</code> is set or the input array has a single row or
            single column, the function performs a 1D forward or inverse transform of
            each row of a matrix when <code>DFT_ROWS</code> is set. Otherwise, it
            performs a 2D transform.
        <li> If the input array is real and <code>DFT_INVERSE</code> is not set,
            the function performs a forward 1D or 2D transform:
        <li> When <code>DFT_COMPLEX_OUTPUT</code> is set, the output is a complex
            matrix of the same size as input.
        <li> When <code>DFT_COMPLEX_OUTPUT</code> is not set, the output is a real
            matrix of the same size as input. In case of 2D transform, it uses the packed
            format as shown above. In case of a single 1D transform, it looks like the
            first row of the matrix above. In case of multiple 1D transforms (when using
            the <code>DFT_ROWS</code> flag), each row of the output matrix looks like the
            first row of the matrix above.
        <li> If the input array is complex and either <code>DFT_INVERSE</code> or
            <code>DFT_REAL_OUTPUT</code> are not set, the output is a complex array of
            the same size as input. The function performs a forward or inverse 1D or 2D
            transform of the whole input array or each row of the input array
            independently, depending on the flags <code>DFT_INVERSE</code> and
            <code>DFT_ROWS</code>.
        <li> When <code>DFT_INVERSE</code> is set and the input array is real, or
            it is complex but <code>DFT_REAL_OUTPUT</code> is set, the output is a real
            array of the same size as input. The function performs a 1D or 2D inverse
            transformation of the whole input array or each individual row, depending on
            the flags <code>DFT_INVERSE</code> and <code>DFT_ROWS</code>.
    </ul>

    <p>If <code>DFT_SCALE</code> is set, the scaling is done after the
        transformation.</p>

    <p>Unlike "dct", the function supports arrays of arbitrary size. But only those
        arrays are processed efficiently, whose sizes can be factorized in a product
        of small prime numbers (2, 3, and 5 in the current implementation). Such an
        efficient DFT size can be calculated using the "getOptimalDFTSize" method.
        The sample below illustrates how to calculate a DFT-based convolution of two
        2D real arrays: <code></p>

    <p>// C++ code:</p>

    <p>void convolveDFT(InputArray A, InputArray B, OutputArray C)</p>


    <p>// reallocate the output array if needed</p>

    <p>C.create(abs(A.rows - B.rows)+1, abs(A.cols - B.cols)+1, A.type());</p>

    <p>Size dftSize;</p>

    <p>// calculate the size of DFT transform</p>

    <p>dftSize.width = getOptimalDFTSize(A.cols + B.cols - 1);</p>

    <p>dftSize.height = getOptimalDFTSize(A.rows + B.rows - 1);</p>

    <p>// allocate temporary buffers and initialize them with 0's</p>

    <p>Mat tempA(dftSize, A.type(), Scalar.all(0));</p>

    <p>Mat tempB(dftSize, B.type(), Scalar.all(0));</p>

    <p>// copy A and B to the top-left corners of tempA and tempB, respectively</p>

    <p>Mat roiA(tempA, Rect(0,0,A.cols,A.rows));</p>

    <p>A.copyTo(roiA);</p>

    <p>Mat roiB(tempB, Rect(0,0,B.cols,B.rows));</p>

    <p>B.copyTo(roiB);</p>

    <p>// now transform the padded A & B in-place;</p>

    <p>// use "nonzeroRows" hint for faster processing</p>

    <p>dft(tempA, tempA, 0, A.rows);</p>

    <p>dft(tempB, tempB, 0, B.rows);</p>

    <p>// multiply the spectrums;</p>

    <p>// the function handles packed spectrum representations well</p>

    <p>mulSpectrums(tempA, tempB, tempA);</p>

    <p>// transform the product back from the frequency domain.</p>

    <p>// Even though all the result rows will be non-zero,</p>

    <p>// you need only the first C.rows of them, and thus you</p>

    <p>// pass nonzeroRows == C.rows</p>

    <p>dft(tempA, tempA, DFT_INVERSE + DFT_SCALE, C.rows);</p>

    <p>// now copy the result back to C.</p>

    <p>tempA(Rect(0, 0, C.cols, C.rows)).copyTo(C);</p>

    <p>// all the temporary buffers will be deallocated automatically</p>


    <p>To optimize this sample, consider the following approaches: </code></p>
    <ul>
        <li> Since <code>nonzeroRows != 0</code> is passed to the forward transform
            calls and since <code>A</code> and <code>B</code> are copied to the top-left
            corners of <code>tempA</code> and <code>tempB</code>, respectively, it is not
            necessary to clear the whole <code>tempA</code> and <code>tempB</code>. It is
            only necessary to clear the <code>tempA.cols - A.cols</code>
            (<code>tempB.cols - B.cols</code>) rightmost columns of the matrices.
        <li> This DFT-based convolution does not have to be applied to the whole
            big arrays, especially if <code>B</code> is significantly smaller than
            <code>A</code> or vice versa. Instead, you can calculate convolution by
            parts. To do this, you need to split the output array <code>C</code> into
            multiple tiles. For each tile, estimate which parts of <code>A</code> and
            <code>B</code> are required to calculate convolution in this tile. If the
            tiles in <code>C</code> are too small, the speed will decrease a lot because
            of repeated work. In the ultimate case, when each tile in <code>C</code> is a
            single pixel, the algorithm becomes equivalent to the naive convolution
            algorithm. If the tiles are too big, the temporary arrays <code>tempA</code>
            and <code>tempB</code> become too big and there is also a slowdown because of
            bad cache locality. So, there is an optimal tile size somewhere in the
            middle.
        <li> If different tiles in <code>C</code> can be calculated in parallel
            and, thus, the convolution is done by parts, the loop can be threaded.
    </ul>

    <p>All of the above improvements have been implemented in "matchTemplate" and
        "filter2D". Therefore, by using them, you can get the performance even better
        than with the above theoretically optimal implementation. Though, those two
        functions actually calculate cross-correlation, not convolution, so you need
        to "flip" the second convolution operand <code>B</code> vertically and
        horizontally using "flip".</p>

    <p>Note:</p>
    <ul>
        <li> An example using the discrete fourier transform can be found at
            opencv_source_code/samples/cpp/dft.cpp
        <li> (Python) An example using the dft functionality to perform Wiener
            deconvolution can be found at opencv_source/samples/python2/deconvolution.py
        <li> (Python) An example rearranging the quadrants of a Fourier image can
            be found at opencv_source/samples/python2/dft.py
    </ul>
</div>
<dl>
    <dt><span class="strong">Parameters:</span></dt>
    <dd><code>src</code> - input array that could be real or complex.</dd>
    <dd><code>dst</code> - output array whose size and type depends on the <code>flags</code>.</dd>
    <dt><span class="strong">See Also:</span></dt>
    <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#dft">org.opencv.core.Core.dft</a>,
        <a href="../../../org/opencv/imgproc/Imgproc.html#matchTemplate(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>Imgproc.matchTemplate(org.opencv.core.Mat,
            org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
        <a href="../../../org/opencv/core/Core.html#mulSpectrums(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, boolean)"><code>mulSpectrums(org.opencv.core.Mat,
            org.opencv.core.Mat, org.opencv.core.Mat, int, boolean)</code></a>,
        <a href="../../../org/opencv/core/Core.html#cartToPolar(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)"><code>cartToPolar(org.opencv.core.Mat,
            org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)</code></a>,
        <a href="../../../org/opencv/core/Core.html#flip(org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>flip(org.opencv.core.Mat,
            org.opencv.core.Mat, int)</code></a>,
        <a href="../../../org/opencv/core/Core.html#magnitude(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>magnitude(org.opencv.core.Mat,
            org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
        <a href="../../../org/opencv/core/Core.html#phase(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)"><code>phase(org.opencv.core.Mat,
            org.opencv.core.Mat, org.opencv.core.Mat, boolean)</code></a>,
        <a href="../../../org/opencv/core/Core.html#dct(org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>dct(org.opencv.core.Mat,
            org.opencv.core.Mat, int)</code></a>,
        <a href="../../../org/opencv/imgproc/Imgproc.html#filter2D(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, double, int)"><code>Imgproc.filter2D(org.opencv.core.Mat,
            org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, double,
            int)</code></a>,
        <a href="../../../org/opencv/core/Core.html#getOptimalDFTSize(int)"><code>getOptimalDFTSize(int)</code></a>
    </dd>
</dl>
</li>
</ul>
<a name="dft(org.opencv.core.Mat, org.opencv.core.Mat, int, int)">
    <!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dft</h4>
<pre>public static&nbsp;void&nbsp;dft(<a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a>&nbsp;src,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
       int&nbsp;flags,
       int&nbsp;nonzeroRows)</pre>
<div class="block"><p>Performs a forward or inverse Discrete Fourier transform of a 1D or 2D
    floating-point array.</p>

    <p>The function performs one of the following:</p>
    <ul>
        <li> Forward the Fourier transform of a 1D vector of <code>N</code>
            elements:
    </ul>

    <p><em>Y = F^N * X,</em></p>

    <p>where <em>F^N_(jk)=exp(-2pi i j k/N)</em> and <em>i=sqrt(-1)</em></p>
    <ul>
        <li> Inverse the Fourier transform of a 1D vector of <code>N</code>
            elements:
    </ul>

    <p><em>X'= (F^N)^(-1) * Y = (F^N)^* * y
        X = (1/N) * X, </em></p>

    <p>where <em>F^*=(Re(F^N)-Im(F^N))^T</em></p>
    <ul>
        <li> Forward the 2D Fourier transform of a <code>M x N</code> matrix:
    </ul>

    <p><em>Y = F^M * X * F^N</em></p>

    <ul>
        <li> Inverse the 2D Fourier transform of a <code>M x N</code> matrix:
    </ul>

    <p><em>X'= (F^M)^* * Y * (F^N)^*
        X = 1/(M * N) * X' </em></p>

    <p>In case of real (single-channel) data, the output spectrum of the forward
        Fourier transform or input spectrum of the inverse Fourier transform can be
        represented in a packed format called *CCS* (complex-conjugate-symmetrical).
        It was borrowed from IPL (Intel* Image Processing Library). Here is how 2D
        *CCS* spectrum looks:</p>

    <p><em>Re Y_(0,0) Re Y_(0,1) Im Y_(0,1) Re Y_(0,2) Im Y_(0,2) *s Re Y_(0,N/2-1)
        Im Y_(0,N/2-1) Re Y_(0,N/2)
        Re Y_(1,0) Re Y_(1,1) Im Y_(1,1) Re Y_(1,2) Im Y_(1,2) *s Re Y_(1,N/2-1) Im
        Y_(1,N/2-1) Re Y_(1,N/2)
        Im Y_(1,0) Re Y_(2,1) Im Y_(2,1) Re Y_(2,2) Im Y_(2,2) *s Re Y_(2,N/2-1) Im
        Y_(2,N/2-1) Im Y_(1,N/2)...........................
        Re Y_(M/2-1,0) Re Y_(M-3,1) Im Y_(M-3,1)......... Re Y_(M-3,N/2-1) Im
        Y_(M-3,N/2-1) Re Y_(M/2-1,N/2)
        Im Y_(M/2-1,0) Re Y_(M-2,1) Im Y_(M-2,1)......... Re Y_(M-2,N/2-1) Im
        Y_(M-2,N/2-1) Im Y_(M/2-1,N/2)
        Re Y_(M/2,0) Re Y_(M-1,1) Im Y_(M-1,1)......... Re Y_(M-1,N/2-1) Im
        Y_(M-1,N/2-1) Re Y_(M/2,N/2) </em></p>

    <p>In case of 1D transform of a real vector, the output looks like the first row
        of the matrix above.</p>

    <p>So, the function chooses an operation mode depending on the flags and size of
        the input array:</p>
    <ul>
        <li> If <code>DFT_ROWS</code> is set or the input array has a single row or
            single column, the function performs a 1D forward or inverse transform of
            each row of a matrix when <code>DFT_ROWS</code> is set. Otherwise, it
            performs a 2D transform.
        <li> If the input array is real and <code>DFT_INVERSE</code> is not set,
            the function performs a forward 1D or 2D transform:
        <li> When <code>DFT_COMPLEX_OUTPUT</code> is set, the output is a complex
            matrix of the same size as input.
        <li> When <code>DFT_COMPLEX_OUTPUT</code> is not set, the output is a real
            matrix of the same size as input. In case of 2D transform, it uses the packed
            format as shown above. In case of a single 1D transform, it looks like the
            first row of the matrix above. In case of multiple 1D transforms (when using
            the <code>DFT_ROWS</code> flag), each row of the output matrix looks like the
            first row of the matrix above.
        <li> If the input array is complex and either <code>DFT_INVERSE</code> or
            <code>DFT_REAL_OUTPUT</code> are not set, the output is a complex array of
            the same size as input. The function performs a forward or inverse 1D or 2D
            transform of the whole input array or each row of the input array
            independently, depending on the flags <code>DFT_INVERSE</code> and
            <code>DFT_ROWS</code>.
        <li> When <code>DFT_INVERSE</code> is set and the input array is real, or
            it is complex but <code>DFT_REAL_OUTPUT</code> is set, the output is a real
            array of the same size as input. The function performs a 1D or 2D inverse
            transformation of the whole input array or each individual row, depending on
            the flags <code>DFT_INVERSE</code> and <code>DFT_ROWS</code>.
    </ul>

    <p>If <code>DFT_SCALE</code> is set, the scaling is done after the
        transformation.</p>

    <p>Unlike "dct", the function supports arrays of arbitrary size. But only those
        arrays are processed efficiently, whose sizes can be factorized in a product
        of small prime numbers (2, 3, and 5 in the current implementation). Such an
        efficient DFT size can be calculated using the "getOptimalDFTSize" method.
        The sample below illustrates how to calculate a DFT-based convolution of two
        2D real arrays: <code></p>

    <p>// C++ code:</p>

    <p>void convolveDFT(InputArray A, InputArray B, OutputArray C)</p>


    <p>// reallocate the output array if needed</p>

    <p>C.create(abs(A.rows - B.rows)+1, abs(A.cols - B.cols)+1, A.type());</p>

    <p>Size dftSize;</p>

    <p>// calculate the size of DFT transform</p>

    <p>dftSize.width = getOptimalDFTSize(A.cols + B.cols - 1);</p>

    <p>dftSize.height = getOptimalDFTSize(A.rows + B.rows - 1);</p>

    <p>// allocate temporary buffers and initialize them with 0's</p>

    <p>Mat tempA(dftSize, A.type(), Scalar.all(0));</p>

    <p>Mat tempB(dftSize, B.type(), Scalar.all(0));</p>

    <p>// copy A and B to the top-left corners of tempA and tempB, respectively</p>

    <p>Mat roiA(tempA, Rect(0,0,A.cols,A.rows));</p>

    <p>A.copyTo(roiA);</p>

    <p>Mat roiB(tempB, Rect(0,0,B.cols,B.rows));</p>

    <p>B.copyTo(roiB);</p>

    <p>// now transform the padded A & B in-place;</p>

    <p>// use "nonzeroRows" hint for faster processing</p>

    <p>dft(tempA, tempA, 0, A.rows);</p>

    <p>dft(tempB, tempB, 0, B.rows);</p>

    <p>// multiply the spectrums;</p>

    <p>// the function handles packed spectrum representations well</p>

    <p>mulSpectrums(tempA, tempB, tempA);</p>

    <p>// transform the product back from the frequency domain.</p>

    <p>// Even though all the result rows will be non-zero,</p>

    <p>// you need only the first C.rows of them, and thus you</p>

    <p>// pass nonzeroRows == C.rows</p>

    <p>dft(tempA, tempA, DFT_INVERSE + DFT_SCALE, C.rows);</p>

    <p>// now copy the result back to C.</p>

    <p>tempA(Rect(0, 0, C.cols, C.rows)).copyTo(C);</p>

    <p>// all the temporary buffers will be deallocated automatically</p>


    <p>To optimize this sample, consider the following approaches: </code></p>
    <ul>
        <li> Since <code>nonzeroRows != 0</code> is passed to the forward transform
            calls and since <code>A</code> and <code>B</code> are copied to the top-left
            corners of <code>tempA</code> and <code>tempB</code>, respectively, it is not
            necessary to clear the whole <code>tempA</code> and <code>tempB</code>. It is
            only necessary to clear the <code>tempA.cols - A.cols</code>
            (<code>tempB.cols - B.cols</code>) rightmost columns of the matrices.
        <li> This DFT-based convolution does not have to be applied to the whole
            big arrays, especially if <code>B</code> is significantly smaller than
            <code>A</code> or vice versa. Instead, you can calculate convolution by
            parts. To do this, you need to split the output array <code>C</code> into
            multiple tiles. For each tile, estimate which parts of <code>A</code> and
            <code>B</code> are required to calculate convolution in this tile. If the
            tiles in <code>C</code> are too small, the speed will decrease a lot because
            of repeated work. In the ultimate case, when each tile in <code>C</code> is a
            single pixel, the algorithm becomes equivalent to the naive convolution
            algorithm. If the tiles are too big, the temporary arrays <code>tempA</code>
            and <code>tempB</code> become too big and there is also a slowdown because of
            bad cache locality. So, there is an optimal tile size somewhere in the
            middle.
        <li> If different tiles in <code>C</code> can be calculated in parallel
            and, thus, the convolution is done by parts, the loop can be threaded.
    </ul>

    <p>All of the above improvements have been implemented in "matchTemplate" and
        "filter2D". Therefore, by using them, you can get the performance even better
        than with the above theoretically optimal implementation. Though, those two
        functions actually calculate cross-correlation, not convolution, so you need
        to "flip" the second convolution operand <code>B</code> vertically and
        horizontally using "flip".</p>

    <p>Note:</p>
    <ul>
        <li> An example using the discrete fourier transform can be found at
            opencv_source_code/samples/cpp/dft.cpp
        <li> (Python) An example using the dft functionality to perform Wiener
            deconvolution can be found at opencv_source/samples/python2/deconvolution.py
        <li> (Python) An example rearranging the quadrants of a Fourier image can
            be found at opencv_source/samples/python2/dft.py
    </ul>
</div>
<dl>
    <dt><span class="strong">Parameters:</span></dt>
    <dd><code>src</code> - input array that could be real or complex.</dd>
    <dd><code>dst</code> - output array whose size and type depends on the <code>flags</code>.</dd>
    <dd><code>flags</code> - transformation flags, representing a combination of the
        following values:
        <ul>
            <li> DFT_INVERSE performs an inverse 1D or 2D transform instead of the
                default forward transform.
            <li> DFT_SCALE scales the result: divide it by the number of array
                elements. Normally, it is combined with <code>DFT_INVERSE</code>.
            <li> DFT_ROWS performs a forward or inverse transform of every individual
                row of the input matrix; this flag enables you to transform multiple vectors
                simultaneously and can be used to decrease the overhead (which is sometimes
                several times larger than the processing itself) to perform 3D and
                higher-dimensional transformations and so forth.
            <li> DFT_COMPLEX_OUTPUT performs a forward transformation of 1D or 2D real
                array; the result, though being a complex array, has complex-conjugate
                symmetry (*CCS*, see the function description below for details), and such an
                array can be packed into a real array of the same size as input, which is the
                fastest option and which is what the function does by default; however, you
                may wish to get a full complex array (for simpler spectrum analysis, and so
                on) - pass the flag to enable the function to produce a full-size complex
                output array.
            <li> DFT_REAL_OUTPUT performs an inverse transformation of a 1D or 2D
                complex array; the result is normally a complex array of the same size,
                however, if the input array has conjugate-complex symmetry (for example, it
                is a result of forward transformation with <code>DFT_COMPLEX_OUTPUT</code>
                flag), the output is a real array; while the function itself does not check
                whether the input is symmetrical or not, you can pass the flag and then the
                function will assume the symmetry and produce the real output array (note
                that when the input is packed into a real array and inverse transformation is
                executed, the function treats the input as a packed complex-conjugate
                symmetrical array, and the output will also be a real array).
        </ul>
    </dd>
    <dd><code>nonzeroRows</code> - when the parameter is not zero, the function assumes that
        only the first <code>nonzeroRows</code> rows of the input array
        (<code>DFT_INVERSE</code> is not set) or only the first <code>nonzeroRows</code>
        of the output array (<code>DFT_INVERSE</code> is set) contain non-zeros,
        thus, the function can handle the rest of the rows more efficiently and save
        some time; this technique is very useful for calculating array
        cross-correlation or convolution using DFT.
    </dd>
    <dt><span class="strong">See Also:</span></dt>
    <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#dft">org.opencv.core.Core.dft</a>,
        <a href="../../../org/opencv/imgproc/Imgproc.html#matchTemplate(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>Imgproc.matchTemplate(org.opencv.core.Mat,
            org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
        <a href="../../../org/opencv/core/Core.html#mulSpectrums(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, boolean)"><code>mulSpectrums(org.opencv.core.Mat,
            org.opencv.core.Mat, org.opencv.core.Mat, int, boolean)</code></a>,
        <a href="../../../org/opencv/core/Core.html#cartToPolar(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)"><code>cartToPolar(org.opencv.core.Mat,
            org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)</code></a>,
        <a href="../../../org/opencv/core/Core.html#flip(org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>flip(org.opencv.core.Mat,
            org.opencv.core.Mat, int)</code></a>,
        <a href="../../../org/opencv/core/Core.html#magnitude(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>magnitude(org.opencv.core.Mat,
            org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
        <a href="../../../org/opencv/core/Core.html#phase(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)"><code>phase(org.opencv.core.Mat,
            org.opencv.core.Mat, org.opencv.core.Mat, boolean)</code></a>,
        <a href="../../../org/opencv/core/Core.html#dct(org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>dct(org.opencv.core.Mat,
            org.opencv.core.Mat, int)</code></a>,
        <a href="../../../org/opencv/imgproc/Imgproc.html#filter2D(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, double, int)"><code>Imgproc.filter2D(org.opencv.core.Mat,
            org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, double,
            int)</code></a>,
        <a href="../../../org/opencv/core/Core.html#getOptimalDFTSize(int)"><code>getOptimalDFTSize(int)</code></a>
    </dd>
</dl>
</li>
</ul>
<a name="divide(double, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>divide</h4>
<pre>public static&nbsp;void&nbsp;divide(double&nbsp;scale,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Performs per-element division of two arrays or a scalar by an
            array.</p>

            <p>The functions <code>divide</code> divide one array by another:</p>

            <p><em>dst(I) = saturate(src1(I)*scale/src2(I))</em></p>

            <p>or a scalar by an array when there is no <code>src1</code> :</p>

            <p><em>dst(I) = saturate(scale/src2(I))</em></p>

            <p>When <code>src2(I)</code> is zero, <code>dst(I)</code> will also be zero.
                Different channels of multi-channel arrays are processed independently.</p>

            <p>Note: Saturation is not applied when the output array has the depth
                <code>CV_32S</code>. You may even get result of an incorrect sign in the case
                of overflow.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>scale</code> - scalar factor.</dd>
            <dd><code>src2</code> - second input array of the same size and type as
                <code>src1</code>.
            </dd>
            <dd><code>dst</code> - output array of the same size and type as <code>src2</code>.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#divide">org.opencv.core.Core.divide</a>,
                <a href="../../../org/opencv/core/Core.html#multiply(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, int)"><code>multiply(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, double, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#add(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>add(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#subtract(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>subtract(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>
            </dd>
        </dl>
    </li>
</ul>
<a name="divide(double, org.opencv.core.Mat, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>divide</h4>
<pre>public static&nbsp;void&nbsp;divide(double&nbsp;scale,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
          int&nbsp;dtype)</pre>
        <div class="block"><p>Performs per-element division of two arrays or a scalar by an
            array.</p>

            <p>The functions <code>divide</code> divide one array by another:</p>

            <p><em>dst(I) = saturate(src1(I)*scale/src2(I))</em></p>

            <p>or a scalar by an array when there is no <code>src1</code> :</p>

            <p><em>dst(I) = saturate(scale/src2(I))</em></p>

            <p>When <code>src2(I)</code> is zero, <code>dst(I)</code> will also be zero.
                Different channels of multi-channel arrays are processed independently.</p>

            <p>Note: Saturation is not applied when the output array has the depth
                <code>CV_32S</code>. You may even get result of an incorrect sign in the case
                of overflow.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>scale</code> - scalar factor.</dd>
            <dd><code>src2</code> - second input array of the same size and type as
                <code>src1</code>.
            </dd>
            <dd><code>dst</code> - output array of the same size and type as <code>src2</code>.</dd>
            <dd><code>dtype</code> - optional depth of the output array; if <code>-1</code>,
                <code>dst</code> will have depth <code>src2.depth()</code>, but in case of an
                array-by-array division, you can only pass <code>-1</code> when
                <code>src1.depth()==src2.depth()</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#divide">org.opencv.core.Core.divide</a>,
                <a href="../../../org/opencv/core/Core.html#multiply(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, int)"><code>multiply(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, double, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#add(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>add(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#subtract(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>subtract(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>
            </dd>
        </dl>
    </li>
</ul>
<a name="divide(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>divide</h4>
<pre>public static&nbsp;void&nbsp;divide(<a href="../../../org/opencv/core/Mat.html"
                                            title="class in org.opencv.core">Mat</a>&nbsp;src1,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Performs per-element division of two arrays or a scalar by an
            array.</p>

            <p>The functions <code>divide</code> divide one array by another:</p>

            <p><em>dst(I) = saturate(src1(I)*scale/src2(I))</em></p>

            <p>or a scalar by an array when there is no <code>src1</code> :</p>

            <p><em>dst(I) = saturate(scale/src2(I))</em></p>

            <p>When <code>src2(I)</code> is zero, <code>dst(I)</code> will also be zero.
                Different channels of multi-channel arrays are processed independently.</p>

            <p>Note: Saturation is not applied when the output array has the depth
                <code>CV_32S</code>. You may even get result of an incorrect sign in the case
                of overflow.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array.</dd>
            <dd><code>src2</code> - second input array of the same size and type as
                <code>src1</code>.
            </dd>
            <dd><code>dst</code> - output array of the same size and type as <code>src2</code>.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#divide">org.opencv.core.Core.divide</a>,
                <a href="../../../org/opencv/core/Core.html#multiply(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, int)"><code>multiply(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, double, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#add(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>add(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#subtract(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>subtract(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>
            </dd>
        </dl>
    </li>
</ul>
<a name="divide(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>divide</h4>
<pre>public static&nbsp;void&nbsp;divide(<a href="../../../org/opencv/core/Mat.html"
                                            title="class in org.opencv.core">Mat</a>&nbsp;src1,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
          double&nbsp;scale)</pre>
        <div class="block"><p>Performs per-element division of two arrays or a scalar by an
            array.</p>

            <p>The functions <code>divide</code> divide one array by another:</p>

            <p><em>dst(I) = saturate(src1(I)*scale/src2(I))</em></p>

            <p>or a scalar by an array when there is no <code>src1</code> :</p>

            <p><em>dst(I) = saturate(scale/src2(I))</em></p>

            <p>When <code>src2(I)</code> is zero, <code>dst(I)</code> will also be zero.
                Different channels of multi-channel arrays are processed independently.</p>

            <p>Note: Saturation is not applied when the output array has the depth
                <code>CV_32S</code>. You may even get result of an incorrect sign in the case
                of overflow.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array.</dd>
            <dd><code>src2</code> - second input array of the same size and type as
                <code>src1</code>.
            </dd>
            <dd><code>dst</code> - output array of the same size and type as <code>src2</code>.</dd>
            <dd><code>scale</code> - scalar factor.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#divide">org.opencv.core.Core.divide</a>,
                <a href="../../../org/opencv/core/Core.html#multiply(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, int)"><code>multiply(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, double, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#add(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>add(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#subtract(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>subtract(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>
            </dd>
        </dl>
    </li>
</ul>
<a name="divide(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>divide</h4>
<pre>public static&nbsp;void&nbsp;divide(<a href="../../../org/opencv/core/Mat.html"
                                            title="class in org.opencv.core">Mat</a>&nbsp;src1,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
          double&nbsp;scale,
          int&nbsp;dtype)</pre>
        <div class="block"><p>Performs per-element division of two arrays or a scalar by an
            array.</p>

            <p>The functions <code>divide</code> divide one array by another:</p>

            <p><em>dst(I) = saturate(src1(I)*scale/src2(I))</em></p>

            <p>or a scalar by an array when there is no <code>src1</code> :</p>

            <p><em>dst(I) = saturate(scale/src2(I))</em></p>

            <p>When <code>src2(I)</code> is zero, <code>dst(I)</code> will also be zero.
                Different channels of multi-channel arrays are processed independently.</p>

            <p>Note: Saturation is not applied when the output array has the depth
                <code>CV_32S</code>. You may even get result of an incorrect sign in the case
                of overflow.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array.</dd>
            <dd><code>src2</code> - second input array of the same size and type as
                <code>src1</code>.
            </dd>
            <dd><code>dst</code> - output array of the same size and type as <code>src2</code>.</dd>
            <dd><code>scale</code> - scalar factor.</dd>
            <dd><code>dtype</code> - optional depth of the output array; if <code>-1</code>,
                <code>dst</code> will have depth <code>src2.depth()</code>, but in case of an
                array-by-array division, you can only pass <code>-1</code> when
                <code>src1.depth()==src2.depth()</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#divide">org.opencv.core.Core.divide</a>,
                <a href="../../../org/opencv/core/Core.html#multiply(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, int)"><code>multiply(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, double, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#add(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>add(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#subtract(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>subtract(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>
            </dd>
        </dl>
    </li>
</ul>
<a name="divide(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>divide</h4>
<pre>public static&nbsp;void&nbsp;divide(<a href="../../../org/opencv/core/Mat.html"
                                            title="class in org.opencv.core">Mat</a>&nbsp;src1,
          <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Performs per-element division of two arrays or a scalar by an
            array.</p>

            <p>The functions <code>divide</code> divide one array by another:</p>

            <p><em>dst(I) = saturate(src1(I)*scale/src2(I))</em></p>

            <p>or a scalar by an array when there is no <code>src1</code> :</p>

            <p><em>dst(I) = saturate(scale/src2(I))</em></p>

            <p>When <code>src2(I)</code> is zero, <code>dst(I)</code> will also be zero.
                Different channels of multi-channel arrays are processed independently.</p>

            <p>Note: Saturation is not applied when the output array has the depth
                <code>CV_32S</code>. You may even get result of an incorrect sign in the case
                of overflow.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array.</dd>
            <dd><code>src2</code> - second input array of the same size and type as
                <code>src1</code>.
            </dd>
            <dd><code>dst</code> - output array of the same size and type as <code>src2</code>.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#divide">org.opencv.core.Core.divide</a>,
                <a href="../../../org/opencv/core/Core.html#multiply(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, int)"><code>multiply(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, double, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#add(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>add(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#subtract(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>subtract(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>
            </dd>
        </dl>
    </li>
</ul>
<a name="divide(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Mat, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>divide</h4>
<pre>public static&nbsp;void&nbsp;divide(<a href="../../../org/opencv/core/Mat.html"
                                            title="class in org.opencv.core">Mat</a>&nbsp;src1,
          <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
          double&nbsp;scale)</pre>
        <div class="block"><p>Performs per-element division of two arrays or a scalar by an
            array.</p>

            <p>The functions <code>divide</code> divide one array by another:</p>

            <p><em>dst(I) = saturate(src1(I)*scale/src2(I))</em></p>

            <p>or a scalar by an array when there is no <code>src1</code> :</p>

            <p><em>dst(I) = saturate(scale/src2(I))</em></p>

            <p>When <code>src2(I)</code> is zero, <code>dst(I)</code> will also be zero.
                Different channels of multi-channel arrays are processed independently.</p>

            <p>Note: Saturation is not applied when the output array has the depth
                <code>CV_32S</code>. You may even get result of an incorrect sign in the case
                of overflow.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array.</dd>
            <dd><code>src2</code> - second input array of the same size and type as
                <code>src1</code>.
            </dd>
            <dd><code>dst</code> - output array of the same size and type as <code>src2</code>.</dd>
            <dd><code>scale</code> - scalar factor.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#divide">org.opencv.core.Core.divide</a>,
                <a href="../../../org/opencv/core/Core.html#multiply(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, int)"><code>multiply(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, double, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#add(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>add(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#subtract(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>subtract(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>
            </dd>
        </dl>
    </li>
</ul>
<a name="divide(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Mat, double, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>divide</h4>
<pre>public static&nbsp;void&nbsp;divide(<a href="../../../org/opencv/core/Mat.html"
                                            title="class in org.opencv.core">Mat</a>&nbsp;src1,
          <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
          double&nbsp;scale,
          int&nbsp;dtype)</pre>
        <div class="block"><p>Performs per-element division of two arrays or a scalar by an
            array.</p>

            <p>The functions <code>divide</code> divide one array by another:</p>

            <p><em>dst(I) = saturate(src1(I)*scale/src2(I))</em></p>

            <p>or a scalar by an array when there is no <code>src1</code> :</p>

            <p><em>dst(I) = saturate(scale/src2(I))</em></p>

            <p>When <code>src2(I)</code> is zero, <code>dst(I)</code> will also be zero.
                Different channels of multi-channel arrays are processed independently.</p>

            <p>Note: Saturation is not applied when the output array has the depth
                <code>CV_32S</code>. You may even get result of an incorrect sign in the case
                of overflow.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array.</dd>
            <dd><code>src2</code> - second input array of the same size and type as
                <code>src1</code>.
            </dd>
            <dd><code>dst</code> - output array of the same size and type as <code>src2</code>.</dd>
            <dd><code>scale</code> - scalar factor.</dd>
            <dd><code>dtype</code> - optional depth of the output array; if <code>-1</code>,
                <code>dst</code> will have depth <code>src2.depth()</code>, but in case of an
                array-by-array division, you can only pass <code>-1</code> when
                <code>src1.depth()==src2.depth()</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#divide">org.opencv.core.Core.divide</a>,
                <a href="../../../org/opencv/core/Core.html#multiply(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, int)"><code>multiply(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, double, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#add(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>add(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#subtract(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>subtract(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>
            </dd>
        </dl>
    </li>
</ul>
<a name="eigen(org.opencv.core.Mat, boolean, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>eigen</h4>
<pre>public static&nbsp;boolean&nbsp;eigen(<a href="../../../org/opencv/core/Mat.html"
                                              title="class in org.opencv.core">Mat</a>&nbsp;src,
            boolean&nbsp;computeEigenvectors,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvalues,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvectors)</pre>
        <div class="block"><p>Calculates eigenvalues and eigenvectors of a symmetric matrix.</p>

            <p>The functions <code>eigen</code> calculate just eigenvalues, or eigenvalues
                and eigenvectors of the symmetric matrix <code>src</code> : <code></p>

            <p>// C++ code:</p>

            <p>src*eigenvectors.row(i).t() = eigenvalues.at
                <srcType>(i)*eigenvectors.row(i).t()
            </p>

            <p>Note: in the new and the old interfaces different ordering of eigenvalues and
                eigenvectors parameters is used.
                </code></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input matrix that must have <code>CV_32FC1</code> or
                <code>CV_64FC1</code> type, square size and be symmetrical (<code>src</code>^"T"
                == <code>src</code>).
            </dd>
            <dd><code>computeEigenvectors</code> - a computeEigenvectors</dd>
            <dd><code>eigenvalues</code> - output vector of eigenvalues of the same type as
                <code>src</code>; the eigenvalues are stored in the descending order.
            </dd>
            <dd><code>eigenvectors</code> - output matrix of eigenvectors; it has the same size and
                type as <code>src</code>; the eigenvectors are stored as subsequent matrix
                rows, in the same order as the corresponding eigenvalues.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#eigen">org.opencv.core.Core.eigen</a>,
                <a href="../../../org/opencv/core/Core.html#completeSymm(org.opencv.core.Mat, boolean)"><code>completeSymm(org.opencv.core.Mat,
                    boolean)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="ellipse(org.opencv.core.Mat, org.opencv.core.Point, org.opencv.core.Size, double, double, double, org.opencv.core.Scalar)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>ellipse</h4>
<pre>public static&nbsp;void&nbsp;ellipse(<a href="../../../org/opencv/core/Mat.html"
                                             title="class in org.opencv.core">Mat</a>&nbsp;img,
           <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
           <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;axes,
           double&nbsp;angle,
           double&nbsp;startAngle,
           double&nbsp;endAngle,
           <a href="../../../org/opencv/core/Scalar.html"
              title="class in org.opencv.core">Scalar</a>&nbsp;color)</pre>
        <div class="block"><p>Draws a simple or thick elliptic arc or fills an ellipse sector.</p>

            <p>The functions <code>ellipse</code> with less parameters draw an ellipse
                outline, a filled ellipse, an elliptic arc, or a filled ellipse sector.
                A piecewise-linear curve is used to approximate the elliptic arc boundary. If
                you need more control of the ellipse rendering, you can retrieve the curve
                using "ellipse2Poly" and then render it with "polylines" or fill it with
                "fillPoly". If you use the first variant of the function and want to draw the
                whole ellipse, not an arc, pass <code>startAngle=0</code> and
                <code>endAngle=360</code>. The figure below explains the meaning of the
                parameters.
                Figure 1. Parameters of Elliptic Arc</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>img</code> - Image.</dd>
            <dd><code>center</code> - Center of the ellipse.</dd>
            <dd><code>axes</code> - Half of the size of the ellipse main axes.</dd>
            <dd><code>angle</code> - Ellipse rotation angle in degrees.</dd>
            <dd><code>startAngle</code> - Starting angle of the elliptic arc in degrees.</dd>
            <dd><code>endAngle</code> - Ending angle of the elliptic arc in degrees.</dd>
            <dd><code>color</code> - Ellipse color.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#ellipse">org.opencv.core.Core.ellipse</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="ellipse(org.opencv.core.Mat, org.opencv.core.Point, org.opencv.core.Size, double, double, double, org.opencv.core.Scalar, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>ellipse</h4>
<pre>public static&nbsp;void&nbsp;ellipse(<a href="../../../org/opencv/core/Mat.html"
                                             title="class in org.opencv.core">Mat</a>&nbsp;img,
           <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
           <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;axes,
           double&nbsp;angle,
           double&nbsp;startAngle,
           double&nbsp;endAngle,
           <a href="../../../org/opencv/core/Scalar.html"
              title="class in org.opencv.core">Scalar</a>&nbsp;color,
           int&nbsp;thickness)</pre>
        <div class="block"><p>Draws a simple or thick elliptic arc or fills an ellipse sector.</p>

            <p>The functions <code>ellipse</code> with less parameters draw an ellipse
                outline, a filled ellipse, an elliptic arc, or a filled ellipse sector.
                A piecewise-linear curve is used to approximate the elliptic arc boundary. If
                you need more control of the ellipse rendering, you can retrieve the curve
                using "ellipse2Poly" and then render it with "polylines" or fill it with
                "fillPoly". If you use the first variant of the function and want to draw the
                whole ellipse, not an arc, pass <code>startAngle=0</code> and
                <code>endAngle=360</code>. The figure below explains the meaning of the
                parameters.
                Figure 1. Parameters of Elliptic Arc</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>img</code> - Image.</dd>
            <dd><code>center</code> - Center of the ellipse.</dd>
            <dd><code>axes</code> - Half of the size of the ellipse main axes.</dd>
            <dd><code>angle</code> - Ellipse rotation angle in degrees.</dd>
            <dd><code>startAngle</code> - Starting angle of the elliptic arc in degrees.</dd>
            <dd><code>endAngle</code> - Ending angle of the elliptic arc in degrees.</dd>
            <dd><code>color</code> - Ellipse color.</dd>
            <dd><code>thickness</code> - Thickness of the ellipse arc outline, if positive.
                Otherwise, this indicates that a filled ellipse sector is to be drawn.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#ellipse">org.opencv.core.Core.ellipse</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="ellipse(org.opencv.core.Mat, org.opencv.core.Point, org.opencv.core.Size, double, double, double, org.opencv.core.Scalar, int, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>ellipse</h4>
<pre>public static&nbsp;void&nbsp;ellipse(<a href="../../../org/opencv/core/Mat.html"
                                             title="class in org.opencv.core">Mat</a>&nbsp;img,
           <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
           <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;axes,
           double&nbsp;angle,
           double&nbsp;startAngle,
           double&nbsp;endAngle,
           <a href="../../../org/opencv/core/Scalar.html"
              title="class in org.opencv.core">Scalar</a>&nbsp;color,
           int&nbsp;thickness,
           int&nbsp;lineType,
           int&nbsp;shift)</pre>
        <div class="block"><p>Draws a simple or thick elliptic arc or fills an ellipse sector.</p>

            <p>The functions <code>ellipse</code> with less parameters draw an ellipse
                outline, a filled ellipse, an elliptic arc, or a filled ellipse sector.
                A piecewise-linear curve is used to approximate the elliptic arc boundary. If
                you need more control of the ellipse rendering, you can retrieve the curve
                using "ellipse2Poly" and then render it with "polylines" or fill it with
                "fillPoly". If you use the first variant of the function and want to draw the
                whole ellipse, not an arc, pass <code>startAngle=0</code> and
                <code>endAngle=360</code>. The figure below explains the meaning of the
                parameters.
                Figure 1. Parameters of Elliptic Arc</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>img</code> - Image.</dd>
            <dd><code>center</code> - Center of the ellipse.</dd>
            <dd><code>axes</code> - Half of the size of the ellipse main axes.</dd>
            <dd><code>angle</code> - Ellipse rotation angle in degrees.</dd>
            <dd><code>startAngle</code> - Starting angle of the elliptic arc in degrees.</dd>
            <dd><code>endAngle</code> - Ending angle of the elliptic arc in degrees.</dd>
            <dd><code>color</code> - Ellipse color.</dd>
            <dd><code>thickness</code> - Thickness of the ellipse arc outline, if positive.
                Otherwise, this indicates that a filled ellipse sector is to be drawn.
            </dd>
            <dd><code>lineType</code> - Type of the ellipse boundary. See the "line" description.
            </dd>
            <dd><code>shift</code> - Number of fractional bits in the coordinates of the center and
                values of axes.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#ellipse">org.opencv.core.Core.ellipse</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="ellipse(org.opencv.core.Mat, org.opencv.core.RotatedRect, org.opencv.core.Scalar)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>ellipse</h4>
<pre>public static&nbsp;void&nbsp;ellipse(<a href="../../../org/opencv/core/Mat.html"
                                             title="class in org.opencv.core">Mat</a>&nbsp;img,
           <a href="../../../org/opencv/core/RotatedRect.html" title="class in org.opencv.core">RotatedRect</a>&nbsp;box,
           <a href="../../../org/opencv/core/Scalar.html"
              title="class in org.opencv.core">Scalar</a>&nbsp;color)</pre>
        <div class="block"><p>Draws a simple or thick elliptic arc or fills an ellipse sector.</p>

            <p>The functions <code>ellipse</code> with less parameters draw an ellipse
                outline, a filled ellipse, an elliptic arc, or a filled ellipse sector.
                A piecewise-linear curve is used to approximate the elliptic arc boundary. If
                you need more control of the ellipse rendering, you can retrieve the curve
                using "ellipse2Poly" and then render it with "polylines" or fill it with
                "fillPoly". If you use the first variant of the function and want to draw the
                whole ellipse, not an arc, pass <code>startAngle=0</code> and
                <code>endAngle=360</code>. The figure below explains the meaning of the
                parameters.
                Figure 1. Parameters of Elliptic Arc</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>img</code> - Image.</dd>
            <dd><code>box</code> - Alternative ellipse representation via "RotatedRect" or
                <code>CvBox2D</code>. This means that the function draws an ellipse inscribed
                in the rotated rectangle.
            </dd>
            <dd><code>color</code> - Ellipse color.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#ellipse">org.opencv.core.Core.ellipse</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="ellipse(org.opencv.core.Mat, org.opencv.core.RotatedRect, org.opencv.core.Scalar, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>ellipse</h4>
<pre>public static&nbsp;void&nbsp;ellipse(<a href="../../../org/opencv/core/Mat.html"
                                             title="class in org.opencv.core">Mat</a>&nbsp;img,
           <a href="../../../org/opencv/core/RotatedRect.html" title="class in org.opencv.core">RotatedRect</a>&nbsp;box,
           <a href="../../../org/opencv/core/Scalar.html"
              title="class in org.opencv.core">Scalar</a>&nbsp;color,
           int&nbsp;thickness)</pre>
        <div class="block"><p>Draws a simple or thick elliptic arc or fills an ellipse sector.</p>

            <p>The functions <code>ellipse</code> with less parameters draw an ellipse
                outline, a filled ellipse, an elliptic arc, or a filled ellipse sector.
                A piecewise-linear curve is used to approximate the elliptic arc boundary. If
                you need more control of the ellipse rendering, you can retrieve the curve
                using "ellipse2Poly" and then render it with "polylines" or fill it with
                "fillPoly". If you use the first variant of the function and want to draw the
                whole ellipse, not an arc, pass <code>startAngle=0</code> and
                <code>endAngle=360</code>. The figure below explains the meaning of the
                parameters.
                Figure 1. Parameters of Elliptic Arc</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>img</code> - Image.</dd>
            <dd><code>box</code> - Alternative ellipse representation via "RotatedRect" or
                <code>CvBox2D</code>. This means that the function draws an ellipse inscribed
                in the rotated rectangle.
            </dd>
            <dd><code>color</code> - Ellipse color.</dd>
            <dd><code>thickness</code> - Thickness of the ellipse arc outline, if positive.
                Otherwise, this indicates that a filled ellipse sector is to be drawn.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#ellipse">org.opencv.core.Core.ellipse</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="ellipse(org.opencv.core.Mat, org.opencv.core.RotatedRect, org.opencv.core.Scalar, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>ellipse</h4>
<pre>public static&nbsp;void&nbsp;ellipse(<a href="../../../org/opencv/core/Mat.html"
                                             title="class in org.opencv.core">Mat</a>&nbsp;img,
           <a href="../../../org/opencv/core/RotatedRect.html" title="class in org.opencv.core">RotatedRect</a>&nbsp;box,
           <a href="../../../org/opencv/core/Scalar.html"
              title="class in org.opencv.core">Scalar</a>&nbsp;color,
           int&nbsp;thickness,
           int&nbsp;lineType)</pre>
        <div class="block"><p>Draws a simple or thick elliptic arc or fills an ellipse sector.</p>

            <p>The functions <code>ellipse</code> with less parameters draw an ellipse
                outline, a filled ellipse, an elliptic arc, or a filled ellipse sector.
                A piecewise-linear curve is used to approximate the elliptic arc boundary. If
                you need more control of the ellipse rendering, you can retrieve the curve
                using "ellipse2Poly" and then render it with "polylines" or fill it with
                "fillPoly". If you use the first variant of the function and want to draw the
                whole ellipse, not an arc, pass <code>startAngle=0</code> and
                <code>endAngle=360</code>. The figure below explains the meaning of the
                parameters.
                Figure 1. Parameters of Elliptic Arc</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>img</code> - Image.</dd>
            <dd><code>box</code> - Alternative ellipse representation via "RotatedRect" or
                <code>CvBox2D</code>. This means that the function draws an ellipse inscribed
                in the rotated rectangle.
            </dd>
            <dd><code>color</code> - Ellipse color.</dd>
            <dd><code>thickness</code> - Thickness of the ellipse arc outline, if positive.
                Otherwise, this indicates that a filled ellipse sector is to be drawn.
            </dd>
            <dd><code>lineType</code> - Type of the ellipse boundary. See the "line" description.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#ellipse">org.opencv.core.Core.ellipse</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="ellipse2Poly(org.opencv.core.Point, org.opencv.core.Size, int, int, int, int, org.opencv.core.MatOfPoint)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>ellipse2Poly</h4>
<pre>public static&nbsp;void&nbsp;ellipse2Poly(<a href="../../../org/opencv/core/Point.html"
                                                  title="class in org.opencv.core">Point</a>&nbsp;center,
                <a href="../../../org/opencv/core/Size.html"
                   title="class in org.opencv.core">Size</a>&nbsp;axes,
                int&nbsp;angle,
                int&nbsp;arcStart,
                int&nbsp;arcEnd,
                int&nbsp;delta,
                <a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;pts)</pre>
        <div class="block"><p>Approximates an elliptic arc with a polyline.</p>

            <p>The function <code>ellipse2Poly</code> computes the vertices of a polyline
                that approximates the specified elliptic arc. It is used by "ellipse".</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>center</code> - Center of the arc.</dd>
            <dd><code>axes</code> - Half of the size of the ellipse main axes. See the "ellipse" for
                details.
            </dd>
            <dd><code>angle</code> - Rotation angle of the ellipse in degrees. See the "ellipse" for
                details.
            </dd>
            <dd><code>arcStart</code> - Starting angle of the elliptic arc in degrees.</dd>
            <dd><code>arcEnd</code> - Ending angle of the elliptic arc in degrees.</dd>
            <dd><code>delta</code> - Angle between the subsequent polyline vertices. It defines the
                approximation accuracy.
            </dd>
            <dd><code>pts</code> - Output vector of polyline vertices.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#ellipse2poly">org.opencv.core.Core.ellipse2Poly</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="exp(org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>exp</h4>
<pre>public static&nbsp;void&nbsp;exp(<a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a>&nbsp;src,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Calculates the exponent of every array element.</p>

            <p>The function <code>exp</code> calculates the exponent of every element of the
                input array:</p>

            <p><em>dst [I] = e^(src(I))</em></p>

            <p>The maximum relative error is about <code>7e-6</code> for single-precision
                input and less than <code>1e-10</code> for double-precision input. Currently,
                the function converts denormalized values to zeros on output. Special values
                (NaN, Inf) are not handled.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input array.</dd>
            <dd><code>dst</code> - output array of the same size and type as <code>src</code>.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#exp">org.opencv.core.Core.exp</a>,
                <a href="../../../org/opencv/core/Core.html#log(org.opencv.core.Mat, org.opencv.core.Mat)"><code>log(org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#cartToPolar(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)"><code>cartToPolar(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat,
                    boolean)</code></a>,
                <a href="../../../org/opencv/core/Core.html#pow(org.opencv.core.Mat, double, org.opencv.core.Mat)"><code>pow(org.opencv.core.Mat,
                    double, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#sqrt(org.opencv.core.Mat, org.opencv.core.Mat)"><code>sqrt(org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#magnitude(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>magnitude(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#polarToCart(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)"><code>polarToCart(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat,
                    boolean)</code></a>,
                <a href="../../../org/opencv/core/Core.html#phase(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)"><code>phase(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, boolean)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="extractChannel(org.opencv.core.Mat, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>extractChannel</h4>
<pre>public static&nbsp;void&nbsp;extractChannel(<a href="../../../org/opencv/core/Mat.html"
                                                    title="class in org.opencv.core">Mat</a>&nbsp;src,
                  <a href="../../../org/opencv/core/Mat.html"
                     title="class in org.opencv.core">Mat</a>&nbsp;dst,
                  int&nbsp;coi)</pre>
    </li>
</ul>
<a name="fastAtan2(float, float)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>fastAtan2</h4>
<pre>public static&nbsp;float&nbsp;fastAtan2(float&nbsp;y,
              float&nbsp;x)</pre>
        <div class="block"><p>Calculates the angle of a 2D vector in degrees.</p>

            <p>The function <code>fastAtan2</code> calculates the full-range angle of an
                input 2D vector. The angle is measured in degrees and varies from 0 to 360
                degrees. The accuracy is about 0.3 degrees.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>y</code> - y-coordinate of the vector.</dd>
            <dd><code>x</code> - x-coordinate of the vector.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/utility_and_system_functions_and_macros.html#fastatan2">org.opencv.core.Core.fastAtan2</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="fillConvexPoly(org.opencv.core.Mat, org.opencv.core.MatOfPoint, org.opencv.core.Scalar)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>fillConvexPoly</h4>
<pre>public static&nbsp;void&nbsp;fillConvexPoly(<a href="../../../org/opencv/core/Mat.html"
                                                    title="class in org.opencv.core">Mat</a>&nbsp;img,
                  <a href="../../../org/opencv/core/MatOfPoint.html"
                     title="class in org.opencv.core">MatOfPoint</a>&nbsp;points,
                  <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</pre>
        <div class="block"><p>Fills a convex polygon.</p>

            <p>The function <code>fillConvexPoly</code> draws a filled convex polygon.
                This function is much faster than the function <code>fillPoly</code>. It can
                fill not only convex polygons but any monotonic polygon without
                self-intersections, that is, a polygon whose contour intersects every
                horizontal line (scan line) twice at the most (though, its top-most and/or
                the bottom edge could be horizontal).</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>img</code> - Image.</dd>
            <dd><code>points</code> - a points</dd>
            <dd><code>color</code> - Polygon color.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#fillconvexpoly">org.opencv.core.Core.fillConvexPoly</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="fillConvexPoly(org.opencv.core.Mat, org.opencv.core.MatOfPoint, org.opencv.core.Scalar, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>fillConvexPoly</h4>
<pre>public static&nbsp;void&nbsp;fillConvexPoly(<a href="../../../org/opencv/core/Mat.html"
                                                    title="class in org.opencv.core">Mat</a>&nbsp;img,
                  <a href="../../../org/opencv/core/MatOfPoint.html"
                     title="class in org.opencv.core">MatOfPoint</a>&nbsp;points,
                  <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                  int&nbsp;lineType,
                  int&nbsp;shift)</pre>
        <div class="block"><p>Fills a convex polygon.</p>

            <p>The function <code>fillConvexPoly</code> draws a filled convex polygon.
                This function is much faster than the function <code>fillPoly</code>. It can
                fill not only convex polygons but any monotonic polygon without
                self-intersections, that is, a polygon whose contour intersects every
                horizontal line (scan line) twice at the most (though, its top-most and/or
                the bottom edge could be horizontal).</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>img</code> - Image.</dd>
            <dd><code>points</code> - a points</dd>
            <dd><code>color</code> - Polygon color.</dd>
            <dd><code>lineType</code> - Type of the polygon boundaries. See the "line" description.
            </dd>
            <dd><code>shift</code> - Number of fractional bits in the vertex coordinates.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#fillconvexpoly">org.opencv.core.Core.fillConvexPoly</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="fillPoly(org.opencv.core.Mat, java.util.List, org.opencv.core.Scalar)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>fillPoly</h4>
<pre>public static&nbsp;void&nbsp;fillPoly(<a href="../../../org/opencv/core/Mat.html"
                                              title="class in org.opencv.core">Mat</a>&nbsp;img,
            java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html"
                                 title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;pts,
            <a href="../../../org/opencv/core/Scalar.html"
               title="class in org.opencv.core">Scalar</a>&nbsp;color)</pre>
        <div class="block"><p>Fills the area bounded by one or more polygons.</p>

            <p>The function <code>fillPoly</code> fills an area bounded by several polygonal
                contours. The function can fill complex areas, for example, areas with holes,
                contours with self-intersections (some of their parts), and so forth.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>img</code> - Image.</dd>
            <dd><code>pts</code> - Array of polygons where each polygon is represented as an array
                of
                points.
            </dd>
            <dd><code>color</code> - Polygon color.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#fillpoly">org.opencv.core.Core.fillPoly</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="fillPoly(org.opencv.core.Mat, java.util.List, org.opencv.core.Scalar, int, int, org.opencv.core.Point)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>fillPoly</h4>
<pre>public static&nbsp;void&nbsp;fillPoly(<a href="../../../org/opencv/core/Mat.html"
                                              title="class in org.opencv.core">Mat</a>&nbsp;img,
            java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html"
                                 title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;pts,
            <a href="../../../org/opencv/core/Scalar.html"
               title="class in org.opencv.core">Scalar</a>&nbsp;color,
            int&nbsp;lineType,
            int&nbsp;shift,
            <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;offset)</pre>
        <div class="block"><p>Fills the area bounded by one or more polygons.</p>

            <p>The function <code>fillPoly</code> fills an area bounded by several polygonal
                contours. The function can fill complex areas, for example, areas with holes,
                contours with self-intersections (some of their parts), and so forth.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>img</code> - Image.</dd>
            <dd><code>pts</code> - Array of polygons where each polygon is represented as an array
                of
                points.
            </dd>
            <dd><code>color</code> - Polygon color.</dd>
            <dd><code>lineType</code> - Type of the polygon boundaries. See the "line" description.
            </dd>
            <dd><code>shift</code> - Number of fractional bits in the vertex coordinates.</dd>
            <dd><code>offset</code> - Optional offset of all points of the contours.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#fillpoly">org.opencv.core.Core.fillPoly</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="findNonZero(org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>findNonZero</h4>
<pre>public static&nbsp;void&nbsp;findNonZero(<a href="../../../org/opencv/core/Mat.html"
                                                 title="class in org.opencv.core">Mat</a>&nbsp;src,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;idx)</pre>
    </li>
</ul>
<a name="flip(org.opencv.core.Mat, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>flip</h4>
<pre>public static&nbsp;void&nbsp;flip(<a href="../../../org/opencv/core/Mat.html"
                                          title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;flipCode)</pre>
        <div class="block"><p>Flips a 2D array around vertical, horizontal, or both axes.</p>

            <p>The function <code>flip</code> flips the array in one of three different ways
                (row and column indices are 0-based):</p>

            <p><em>dst _(ij) =&ltBR&gt <= ft(&ltBR&gt ltBR gtsrc _(src.rows-i-1,j) if
                flipCode = 0
                ltBR gtsrc _(i, src.cols -j-1) if flipCode gt 0
                ltBR gtsrc _(src.rows -i-1, src.cols -j-1) if flipCode lt 0
                ltBR gt&ltBR&gtright.</em></p>

            <p>The example scenarios of using the function are the following:</p>
            <ul>
                <li> Vertical flipping of the image (<code>flipCode == 0</code>) to switch
                    between top-left and bottom-left image origin. This is a typical operation in
                    video processing on Microsoft Windows* OS.
                <li> Horizontal flipping of the image with the subsequent horizontal shift
                    and absolute difference calculation to check for a vertical-axis symmetry
                    (<code>flipCode > 0</code>).
                <li> Simultaneous horizontal and vertical flipping of the image with the
                    subsequent shift and absolute difference calculation to check for a central
                    symmetry (<code>flipCode < 0</code>).
                <li> Reversing the order of point arrays (<code>flipCode > 0</code> or
                    <code>flipCode == 0</code>).
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input array.</dd>
            <dd><code>dst</code> - output array of the same size and type as <code>src</code>.</dd>
            <dd><code>flipCode</code> - a flag to specify how to flip the array; 0 means flipping
                around the x-axis and positive value (for example, 1) means flipping around
                y-axis. Negative value (for example, -1) means flipping around both axes (see
                the discussion below for the formulas).
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#flip">org.opencv.core.Core.flip</a>,
                <a href="../../../org/opencv/core/Core.html#repeat(org.opencv.core.Mat, int, int, org.opencv.core.Mat)"><code>repeat(org.opencv.core.Mat,
                    int, int, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#transpose(org.opencv.core.Mat, org.opencv.core.Mat)"><code>transpose(org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#completeSymm(org.opencv.core.Mat, boolean)"><code>completeSymm(org.opencv.core.Mat,
                    boolean)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="gemm(org.opencv.core.Mat, org.opencv.core.Mat, double, org.opencv.core.Mat, double, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>gemm</h4>
<pre>public static&nbsp;void&nbsp;gemm(<a href="../../../org/opencv/core/Mat.html"
                                          title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        double&nbsp;alpha,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src3,
        double&nbsp;beta,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Performs generalized matrix multiplication.</p>

            <p>The function performs generalized matrix multiplication similar to the
                <code>gemm</code> functions in BLAS level 3. For example, <code>gemm(src1,
                    src2, alpha, src3, beta, dst, GEMM_1_T + GEMM_3_T)</code> corresponds to</p>

            <p><em>dst = alpha * src1 ^T * src2 + beta * src3 ^T&ltBR&gtThe function can be
                replaced with a matrix expression. For example, the above call can be
                replaced with: &ltBR&gt&ltcode&gt</em></p>

            <p>// C++ code:</p>

            <p>dst = alpha*src1.t()*src2 + beta*src3.t();</p>

            <p></code></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first multiplied input matrix that should have
                <code>CV_32FC1</code>,
                <code>CV_64FC1</code>, <code>CV_32FC2</code>, or <code>CV_64FC2</code> type.
            </dd>
            <dd><code>src2</code> - second multiplied input matrix of the same type as
                <code>src1</code>.
            </dd>
            <dd><code>alpha</code> - weight of the matrix product.</dd>
            <dd><code>src3</code> - third optional delta matrix added to the matrix product; it
                should have the same type as <code>src1</code> and <code>src2</code>.
            </dd>
            <dd><code>beta</code> - weight of <code>src3</code>.</dd>
            <dd><code>dst</code> - output matrix; it has the proper size and the same type as input
                matrices.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#gemm">org.opencv.core.Core.gemm</a>,
                <a href="../../../org/opencv/core/Core.html#mulTransposed(org.opencv.core.Mat, org.opencv.core.Mat, boolean, org.opencv.core.Mat, double, int)"><code>mulTransposed(org.opencv.core.Mat,
                    org.opencv.core.Mat, boolean, org.opencv.core.Mat, double, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#transform(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>transform(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="gemm(org.opencv.core.Mat, org.opencv.core.Mat, double, org.opencv.core.Mat, double, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>gemm</h4>
<pre>public static&nbsp;void&nbsp;gemm(<a href="../../../org/opencv/core/Mat.html"
                                          title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        double&nbsp;alpha,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src3,
        double&nbsp;beta,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;flags)</pre>
        <div class="block"><p>Performs generalized matrix multiplication.</p>

            <p>The function performs generalized matrix multiplication similar to the
                <code>gemm</code> functions in BLAS level 3. For example, <code>gemm(src1,
                    src2, alpha, src3, beta, dst, GEMM_1_T + GEMM_3_T)</code> corresponds to</p>

            <p><em>dst = alpha * src1 ^T * src2 + beta * src3 ^T&ltBR&gtThe function can be
                replaced with a matrix expression. For example, the above call can be
                replaced with: &ltBR&gt&ltcode&gt</em></p>

            <p>// C++ code:</p>

            <p>dst = alpha*src1.t()*src2 + beta*src3.t();</p>

            <p></code></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first multiplied input matrix that should have
                <code>CV_32FC1</code>,
                <code>CV_64FC1</code>, <code>CV_32FC2</code>, or <code>CV_64FC2</code> type.
            </dd>
            <dd><code>src2</code> - second multiplied input matrix of the same type as
                <code>src1</code>.
            </dd>
            <dd><code>alpha</code> - weight of the matrix product.</dd>
            <dd><code>src3</code> - third optional delta matrix added to the matrix product; it
                should have the same type as <code>src1</code> and <code>src2</code>.
            </dd>
            <dd><code>beta</code> - weight of <code>src3</code>.</dd>
            <dd><code>dst</code> - output matrix; it has the proper size and the same type as input
                matrices.
            </dd>
            <dd><code>flags</code> - operation flags:
                <ul>
                    <li> GEMM_1_T transposes <code>src1</code>.
                    <li> GEMM_2_T transposes <code>src2</code>.
                    <li> GEMM_3_T transposes <code>src3</code>.
                </ul>
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#gemm">org.opencv.core.Core.gemm</a>,
                <a href="../../../org/opencv/core/Core.html#mulTransposed(org.opencv.core.Mat, org.opencv.core.Mat, boolean, org.opencv.core.Mat, double, int)"><code>mulTransposed(org.opencv.core.Mat,
                    org.opencv.core.Mat, boolean, org.opencv.core.Mat, double, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#transform(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>transform(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="getBuildInformation()">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>getBuildInformation</h4>
        <pre>public static&nbsp;java.lang.String&nbsp;getBuildInformation()</pre>
        <div class="block"><p>Returns full configuration time cmake output.</p>

            <p>Returned value is raw cmake output including version control system revision,
                compiler version, compiler flags, enabled modules and third party libraries,
                etc. Output format depends on target architecture.</p></div>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/utility_and_system_functions_and_macros.html#getbuildinformation">org.opencv.core.Core.getBuildInformation</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="getCPUTickCount()">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>getCPUTickCount</h4>
        <pre>public static&nbsp;long&nbsp;getCPUTickCount()</pre>
        <div class="block"><p>Returns the number of CPU ticks.</p>

            <p>The function returns the current number of CPU ticks on some architectures
                (such as x86, x64, PowerPC). On other platforms the function is equivalent to
                <code>getTickCount</code>. It can also be used for very accurate time
                measurements, as well as for RNG initialization. Note that in case of
                multi-CPU systems a thread, from which <code>getCPUTickCount</code> is
                called, can be suspended and resumed at another CPU with its own counter. So,
                theoretically (and practically) the subsequent calls to the function do not
                necessary return the monotonously increasing values. Also, since a modern CPU
                varies the CPU frequency depending on the load, the number of CPU clocks
                spent in some code cannot be directly converted to time units. Therefore,
                <code>getTickCount</code> is generally a preferable solution for measuring
                execution time.</p></div>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/utility_and_system_functions_and_macros.html#getcputickcount">org.opencv.core.Core.getCPUTickCount</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="getNumberOfCPUs()">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>getNumberOfCPUs</h4>
        <pre>public static&nbsp;int&nbsp;getNumberOfCPUs()</pre>
        <div class="block"><p>Returns the number of logical CPUs available for the process.</p>
        </div>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/utility_and_system_functions_and_macros.html#getnumberofcpus">org.opencv.core.Core.getNumberOfCPUs</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="getNumThreads()">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>getNumThreads</h4>
        <pre>public static&nbsp;int&nbsp;getNumThreads()</pre>
        <div class="block"><p>Returns the number of threads used by OpenCV for parallel regions.
            Always returns 1 if OpenCV is built without threading support.</p>

            <p>The exact meaning of return value depends on the threading framework used by
                OpenCV library:</p>
            <ul>
                <li> TBB  The number of threads, that OpenCV will try to use for
                    parallel regions.
            </ul>
            <p>If there is any <code>tbb.thread_scheduler_init</code> in user code
                conflicting with OpenCV, then function returns default number of threads used
                by TBB library.</p>
            <ul>
                <li> OpenMP  An upper bound on the number of threads that could be used
                    to form a new team.
                <li> Concurrency  The number of threads, that OpenCV will try to use for
                    parallel regions.
                <li> GCD  Unsupported; returns the GCD thread pool limit (512) for
                    compatibility.
                <li> C=  The number of threads, that OpenCV will try to use for parallel
                    regions, if before called <code>setNumThreads</code> with <code>threads >
                        0</code>, otherwise returns the number of logical CPUs, available for the
                    process.
            </ul>
        </div>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/utility_and_system_functions_and_macros.html#getnumthreads">org.opencv.core.Core.getNumThreads</a>,
                <a href="../../../org/opencv/core/Core.html#getThreadNum()"><code>getThreadNum()</code></a>,
                <a href="../../../org/opencv/core/Core.html#setNumThreads(int)"><code>setNumThreads(int)</code></a>
            </dd>
        </dl>
    </li>
</ul>
<a name="getOptimalDFTSize(int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>getOptimalDFTSize</h4>
        <pre>public static&nbsp;int&nbsp;getOptimalDFTSize(int&nbsp;vecsize)</pre>
        <div class="block"><p>Returns the optimal DFT size for a given vector size.</p>

            <p>DFT performance is not a monotonic function of a vector size. Therefore, when
                you calculate convolution of two arrays or perform the spectral analysis of
                an array, it usually makes sense to pad the input data with zeros to get a
                bit larger array that can be transformed much faster than the original one.
                Arrays whose size is a power-of-two (2, 4, 8, 16, 32,...) are the fastest to
                process. Though, the arrays whose size is a product of 2's, 3's, and 5's (for
                example, 300 = 5*5*3*2*2) are also processed quite efficiently.</p>

            <p>The function <code>getOptimalDFTSize</code> returns the minimum number
                <code>N</code> that is greater than or equal to <code>vecsize</code> so that
                the DFT of a vector of size <code>N</code> can be processed efficiently. In
                the current implementation <code>N</code> = 2^"p" * 3^"q" * 5^"r" for some
                integer <code>p</code>, <code>q</code>, <code>r</code>.</p>

            <p>The function returns a negative number if <code>vecsize</code> is too large
                (very close to <code>INT_MAX</code>).</p>

            <p>While the function cannot be used directly to estimate the optimal vector
                size for DCT transform (since the current DCT implementation supports only
                even-size vectors), it can be easily processed as <code>getOptimalDFTSize((vecsize+1)/2)*2</code>.
            </p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>vecsize</code> - vector size.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#getoptimaldftsize">org.opencv.core.Core.getOptimalDFTSize</a>,
                <a href="../../../org/opencv/core/Core.html#dft(org.opencv.core.Mat, org.opencv.core.Mat, int, int)"><code>dft(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#dct(org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>dct(org.opencv.core.Mat,
                    org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#idct(org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>idct(org.opencv.core.Mat,
                    org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#mulSpectrums(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, boolean)"><code>mulSpectrums(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, int, boolean)</code></a>,
                <a href="../../../org/opencv/core/Core.html#idft(org.opencv.core.Mat, org.opencv.core.Mat, int, int)"><code>idft(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="getTextSize(java.lang.String, int, double, int, int[])">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>getTextSize</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Size.html"
                           title="class in org.opencv.core">Size</a>&nbsp;getTextSize(java.lang.String&nbsp;text,
               int&nbsp;fontFace,
               double&nbsp;fontScale,
               int&nbsp;thickness,
               int[]&nbsp;baseLine)</pre>
        <div class="block"><p>Calculates the width and height of a text string.</p>

            <p>The function <code>getTextSize</code> calculates and returns the size of a
                box that contains the specified text.That is, the following code renders some
                text, the tight box surrounding it, and the baseline: <code></p>

            <p>// C++ code:</p>

            <p>string text = "Funny text inside the box";</p>

            <p>int fontFace = FONT_HERSHEY_SCRIPT_SIMPLEX;</p>

            <p>double fontScale = 2;</p>

            <p>int thickness = 3;</p>

            <p>Mat img(600, 800, CV_8UC3, Scalar.all(0));</p>

            <p>int baseline=0;</p>

            <p>Size textSize = getTextSize(text, fontFace,</p>

            <p>fontScale, thickness, &baseline);</p>

            <p>baseline += thickness;</p>

            <p>// center the text</p>

            <p>Point textOrg((img.cols - textSize.width)/2,</p>

            <p>(img.rows + textSize.height)/2);</p>

            <p>// draw the box</p>

            <p>rectangle(img, textOrg + Point(0, baseline),</p>

            <p>textOrg + Point(textSize.width, -textSize.height),</p>

            <p>Scalar(0,0,255));</p>

            <p>//... and the baseline first</p>

            <p>line(img, textOrg + Point(0, thickness),</p>

            <p>textOrg + Point(textSize.width, thickness),</p>

            <p>Scalar(0, 0, 255));</p>

            <p>// then put the text itself</p>

            <p>putText(img, text, textOrg, fontFace, fontScale,</p>

            <p>Scalar.all(255), thickness, 8);</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>text</code> - Input text string.</dd>
            <dd><code>fontFace</code> - Font to use. See the "putText" for details.</dd>
            <dd><code>fontScale</code> - Font scale. See the "putText" for details.</dd>
            <dd><code>thickness</code> - Thickness of lines used to render the text. See "putText"
                for details.
            </dd>
            <dd><code>baseLine</code> - Output parameter - y-coordinate of the baseline relative to
                the bottom-most text point.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#gettextsize">org.opencv.core.Core.getTextSize</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="getThreadNum()">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>getThreadNum</h4>
        <pre>public static&nbsp;int&nbsp;getThreadNum()</pre>
        <div class="block"><p>Returns the index of the currently executed thread within the current
            parallel region.
            Always returns 0 if called outside of parallel region.</p>

            <p>The exact meaning of return value depends on the threading framework used by
                OpenCV library:</p>
            <ul>
                <li> TBB  Unsupported with current 4.1 TBB release. May be will be
                    supported in future.
                <li> OpenMP  The thread number, within the current team, of the calling
                    thread.
                <li> Concurrency  An ID for the virtual processor that the current
                    context is executing on (0 for master thread and unique number for others,
                    but not necessary 1,2,3,...).
                <li> GCD  System calling thread's ID. Never returns 0 inside parallel
                    region.
                <li> C=  The index of the current parallel task.
            </ul>
        </div>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/utility_and_system_functions_and_macros.html#getthreadnum">org.opencv.core.Core.getThreadNum</a>,
                <a href="../../../org/opencv/core/Core.html#getNumThreads()"><code>getNumThreads()</code></a>,
                <a href="../../../org/opencv/core/Core.html#setNumThreads(int)"><code>setNumThreads(int)</code></a>
            </dd>
        </dl>
    </li>
</ul>
<a name="getTickCount()">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>getTickCount</h4>
        <pre>public static&nbsp;long&nbsp;getTickCount()</pre>
        <div class="block"><p>Returns the number of ticks.</p>

            <p>The function returns the number of ticks after the certain event (for
                example, when the machine was turned on).
                It can be used to initialize "RNG" or to measure a function execution time by
                reading the tick count before and after the function call. See also the tick
                frequency.</p></div>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/utility_and_system_functions_and_macros.html#gettickcount">org.opencv.core.Core.getTickCount</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="getTickFrequency()">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>getTickFrequency</h4>
        <pre>public static&nbsp;double&nbsp;getTickFrequency()</pre>
        <div class="block"><p>Returns the number of ticks per second.</p>

            <p>The function returns the number of ticks per second.That is, the following
                code computes the execution time in seconds: <code></p>

            <p>// C++ code:</p>

            <p>double t = (double)getTickCount();</p>

            <p>// do something...</p>

            <p>t = ((double)getTickCount() - t)/getTickFrequency();</p></div>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/utility_and_system_functions_and_macros.html#gettickfrequency">org.opencv.core.Core.getTickFrequency</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="hconcat(java.util.List, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>hconcat</h4>
<pre>public static&nbsp;void&nbsp;hconcat(java.util.List&lt;<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;src,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
    </li>
</ul>
<a name="idct(org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>idct</h4>
<pre>public static&nbsp;void&nbsp;idct(<a href="../../../org/opencv/core/Mat.html"
                                          title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Calculates the inverse Discrete Cosine Transform of a 1D or 2D
            array.</p>

            <p><code>idct(src, dst, flags)</code> is equivalent to <code>dct(src, dst, flags
                | DCT_INVERSE)</code>.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input floating-point single-channel array.</dd>
            <dd><code>dst</code> - output array of the same size and type as <code>src</code>.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#idct">org.opencv.core.Core.idct</a>,
                <a href="../../../org/opencv/core/Core.html#dft(org.opencv.core.Mat, org.opencv.core.Mat, int, int)"><code>dft(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#dct(org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>dct(org.opencv.core.Mat,
                    org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#getOptimalDFTSize(int)"><code>getOptimalDFTSize(int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#idft(org.opencv.core.Mat, org.opencv.core.Mat, int, int)"><code>idft(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="idct(org.opencv.core.Mat, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>idct</h4>
<pre>public static&nbsp;void&nbsp;idct(<a href="../../../org/opencv/core/Mat.html"
                                          title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;flags)</pre>
        <div class="block"><p>Calculates the inverse Discrete Cosine Transform of a 1D or 2D
            array.</p>

            <p><code>idct(src, dst, flags)</code> is equivalent to <code>dct(src, dst, flags
                | DCT_INVERSE)</code>.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input floating-point single-channel array.</dd>
            <dd><code>dst</code> - output array of the same size and type as <code>src</code>.</dd>
            <dd><code>flags</code> - operation flags.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#idct">org.opencv.core.Core.idct</a>,
                <a href="../../../org/opencv/core/Core.html#dft(org.opencv.core.Mat, org.opencv.core.Mat, int, int)"><code>dft(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#dct(org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>dct(org.opencv.core.Mat,
                    org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#getOptimalDFTSize(int)"><code>getOptimalDFTSize(int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#idft(org.opencv.core.Mat, org.opencv.core.Mat, int, int)"><code>idft(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="idft(org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>idft</h4>
<pre>public static&nbsp;void&nbsp;idft(<a href="../../../org/opencv/core/Mat.html"
                                          title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Calculates the inverse Discrete Fourier Transform of a 1D or 2D
            array.</p>

            <p><code>idft(src, dst, flags)</code> is equivalent to <code>dft(src, dst, flags
                | DFT_INVERSE)</code>.</p>

            <p>See "dft" for details.</p>

            <p>Note: None of <code>dft</code> and <code>idft</code> scales the result by
                default. So, you should pass <code>DFT_SCALE</code> to one of
                <code>dft</code> or <code>idft</code> explicitly to make these transforms
                mutually inverse.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input floating-point real or complex array.</dd>
            <dd><code>dst</code> - output array whose size and type depend on the <code>flags</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#idft">org.opencv.core.Core.idft</a>,
                <a href="../../../org/opencv/core/Core.html#dft(org.opencv.core.Mat, org.opencv.core.Mat, int, int)"><code>dft(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#dct(org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>dct(org.opencv.core.Mat,
                    org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#getOptimalDFTSize(int)"><code>getOptimalDFTSize(int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#idct(org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>idct(org.opencv.core.Mat,
                    org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#mulSpectrums(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, boolean)"><code>mulSpectrums(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, int, boolean)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="idft(org.opencv.core.Mat, org.opencv.core.Mat, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>idft</h4>
<pre>public static&nbsp;void&nbsp;idft(<a href="../../../org/opencv/core/Mat.html"
                                          title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;flags,
        int&nbsp;nonzeroRows)</pre>
        <div class="block"><p>Calculates the inverse Discrete Fourier Transform of a 1D or 2D
            array.</p>

            <p><code>idft(src, dst, flags)</code> is equivalent to <code>dft(src, dst, flags
                | DFT_INVERSE)</code>.</p>

            <p>See "dft" for details.</p>

            <p>Note: None of <code>dft</code> and <code>idft</code> scales the result by
                default. So, you should pass <code>DFT_SCALE</code> to one of
                <code>dft</code> or <code>idft</code> explicitly to make these transforms
                mutually inverse.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input floating-point real or complex array.</dd>
            <dd><code>dst</code> - output array whose size and type depend on the <code>flags</code>.
            </dd>
            <dd><code>flags</code> - operation flags (see "dft").</dd>
            <dd><code>nonzeroRows</code> - number of <code>dst</code> rows to process; the rest of
                the rows have undefined content (see the convolution sample in "dft"
                description.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#idft">org.opencv.core.Core.idft</a>,
                <a href="../../../org/opencv/core/Core.html#dft(org.opencv.core.Mat, org.opencv.core.Mat, int, int)"><code>dft(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#dct(org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>dct(org.opencv.core.Mat,
                    org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#getOptimalDFTSize(int)"><code>getOptimalDFTSize(int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#idct(org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>idct(org.opencv.core.Mat,
                    org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#mulSpectrums(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, boolean)"><code>mulSpectrums(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, int, boolean)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="inRange(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Scalar, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>inRange</h4>
<pre>public static&nbsp;void&nbsp;inRange(<a href="../../../org/opencv/core/Mat.html"
                                             title="class in org.opencv.core">Mat</a>&nbsp;src,
           <a href="../../../org/opencv/core/Scalar.html"
              title="class in org.opencv.core">Scalar</a>&nbsp;lowerb,
           <a href="../../../org/opencv/core/Scalar.html"
              title="class in org.opencv.core">Scalar</a>&nbsp;upperb,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Checks if array elements lie between the elements of two other
            arrays.</p>

            <p>The function checks the range as follows:</p>
            <ul>
                <li> For every element of a single-channel input array:
            </ul>

            <p><em>dst(I)= lowerb(I)_0 <= src(I)_0 <= upperb(I)_0</em></p>

            <ul>
                <li> For two-channel arrays:
            </ul>

            <p><em>dst(I)= lowerb(I)_0 <= src(I)_0 <= upperb(I)_0 land lowerb(I)_1 <=
                src(I)_1 <= upperb(I)_1</em></p>

            <ul>
                <li> and so forth.
            </ul>

            <p>That is, <code>dst</code> (I) is set to 255 (all <code>1</code> -bits) if
                <code>src</code> (I) is within the specified 1D, 2D, 3D,... box and 0
                otherwise.</p>

            <p>When the lower and/or upper boundary parameters are scalars, the indexes
                <code>(I)</code> at <code>lowerb</code> and <code>upperb</code> in the above
                formulas should be omitted.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - first input array.</dd>
            <dd><code>lowerb</code> - inclusive lower boundary array or a scalar.</dd>
            <dd><code>upperb</code> - inclusive upper boundary array or a scalar.</dd>
            <dd><code>dst</code> - output array of the same size as <code>src</code> and
                <code>CV_8U</code> type.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#inrange">org.opencv.core.Core.inRange</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="insertChannel(org.opencv.core.Mat, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>insertChannel</h4>
<pre>public static&nbsp;void&nbsp;insertChannel(<a href="../../../org/opencv/core/Mat.html"
                                                   title="class in org.opencv.core">Mat</a>&nbsp;src,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;dst,
                 int&nbsp;coi)</pre>
    </li>
</ul>
<a name="invert(org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>invert</h4>
<pre>public static&nbsp;double&nbsp;invert(<a href="../../../org/opencv/core/Mat.html"
                                              title="class in org.opencv.core">Mat</a>&nbsp;src,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Finds the inverse or pseudo-inverse of a matrix.</p>

            <p>The function <code>invert</code> inverts the matrix <code>src</code> and
                stores the result in <code>dst</code>.
                When the matrix <code>src</code> is singular or non-square, the function
                calculates the pseudo-inverse matrix (the <code>dst</code> matrix) so that
                <code>norm(src*dst - I)</code> is minimal, where I is an identity matrix.</p>

            <p>In case of the <code>DECOMP_LU</code> method, the function returns non-zero
                value if the inverse has been successfully calculated and 0 if
                <code>src</code> is singular.</p>

            <p>In case of the <code>DECOMP_SVD</code> method, the function returns the
                inverse condition number of <code>src</code> (the ratio of the smallest
                singular value to the largest singular value) and 0 if <code>src</code> is
                singular. The SVD method calculates a pseudo-inverse matrix if
                <code>src</code> is singular.</p>

            <p>Similarly to <code>DECOMP_LU</code>, the method <code>DECOMP_CHOLESKY</code>
                works only with non-singular square matrices that should also be symmetrical
                and positively defined. In this case, the function stores the inverted matrix
                in <code>dst</code> and returns non-zero. Otherwise, it returns 0.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input floating-point <code>M x N</code> matrix.</dd>
            <dd><code>dst</code> - output matrix of <code>N x M</code> size and the same type as
                <code>src</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#invert">org.opencv.core.Core.invert</a>,
                <a href="../../../org/opencv/core/Core.html#solve(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>solve(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="invert(org.opencv.core.Mat, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>invert</h4>
<pre>public static&nbsp;double&nbsp;invert(<a href="../../../org/opencv/core/Mat.html"
                                              title="class in org.opencv.core">Mat</a>&nbsp;src,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
            int&nbsp;flags)</pre>
        <div class="block"><p>Finds the inverse or pseudo-inverse of a matrix.</p>

            <p>The function <code>invert</code> inverts the matrix <code>src</code> and
                stores the result in <code>dst</code>.
                When the matrix <code>src</code> is singular or non-square, the function
                calculates the pseudo-inverse matrix (the <code>dst</code> matrix) so that
                <code>norm(src*dst - I)</code> is minimal, where I is an identity matrix.</p>

            <p>In case of the <code>DECOMP_LU</code> method, the function returns non-zero
                value if the inverse has been successfully calculated and 0 if
                <code>src</code> is singular.</p>

            <p>In case of the <code>DECOMP_SVD</code> method, the function returns the
                inverse condition number of <code>src</code> (the ratio of the smallest
                singular value to the largest singular value) and 0 if <code>src</code> is
                singular. The SVD method calculates a pseudo-inverse matrix if
                <code>src</code> is singular.</p>

            <p>Similarly to <code>DECOMP_LU</code>, the method <code>DECOMP_CHOLESKY</code>
                works only with non-singular square matrices that should also be symmetrical
                and positively defined. In this case, the function stores the inverted matrix
                in <code>dst</code> and returns non-zero. Otherwise, it returns 0.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input floating-point <code>M x N</code> matrix.</dd>
            <dd><code>dst</code> - output matrix of <code>N x M</code> size and the same type as
                <code>src</code>.
            </dd>
            <dd><code>flags</code> - inversion method :
                <ul>
                    <li> DECOMP_LU Gaussian elimination with the optimal pivot element chosen.
                    <li> DECOMP_SVD singular value decomposition (SVD) method.
                    <li> DECOMP_CHOLESKY Cholesky decomposition; the matrix must be symmetrical
                        and positively defined.
                </ul>
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#invert">org.opencv.core.Core.invert</a>,
                <a href="../../../org/opencv/core/Core.html#solve(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>solve(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="kmeans(org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.TermCriteria, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>kmeans</h4>
<pre>public static&nbsp;double&nbsp;kmeans(<a href="../../../org/opencv/core/Mat.html"
                                              title="class in org.opencv.core">Mat</a>&nbsp;data,
            int&nbsp;K,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;bestLabels,
            <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria,
            int&nbsp;attempts,
            int&nbsp;flags)</pre>
        <div class="block"><p>Finds centers of clusters and groups input samples around the
            clusters.</p>

            <p>The function <code>kmeans</code> implements a k-means algorithm that finds
                the centers of <code>cluster_count</code> clusters and groups the input
                samples around the clusters. As an output, <em>labels_i</em> contains a
                0-based cluster index for the sample stored in the <em>i^(th)</em> row of the
                <code>samples</code> matrix.</p>

            <p>The function returns the compactness measure that is computed as</p>

            <p><em>sum _i|samples _i - centers _(labels _i)| ^2</em></p>

            <p>after every attempt. The best (minimum) value is chosen and the corresponding
                labels and the compactness value are returned by the function.
                Basically, you can use only the core of the function, set the number of
                attempts to 1, initialize labels each time using a custom algorithm, pass
                them with the (<code>flags</code> = <code>KMEANS_USE_INITIAL_LABELS</code>)
                flag, and then choose the best (most-compact) clustering.</p>

            <p>Note:</p>
            <ul>
                <li> An example on K-means clustering can be found at
                    opencv_source_code/samples/cpp/kmeans.cpp
                <li> (Python) An example on K-means clustering can be found at
                    opencv_source_code/samples/python2/kmeans.py
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>data</code> - Data for clustering. An array of N-Dimensional points with float
                coordinates is needed. Examples of this array can be:
                <ul>
                    <li><code>Mat points(count, 2, CV_32F);</code>
                    <li><code>Mat points(count, 1, CV_32FC2);</code>
                    <li><code>Mat points(1, count, CV_32FC2);</code>
                    <li><code>std.vector
                        <cv.Point2f> points(sampleCount);
                    </code>
                </ul>
            </dd>
            <dd><code>K</code> - Number of clusters to split the set by.</dd>
            <dd><code>bestLabels</code> - a bestLabels</dd>
            <dd><code>criteria</code> - The algorithm termination criteria, that is, the maximum
                number of iterations and/or the desired accuracy. The accuracy is specified
                as <code>criteria.epsilon</code>. As soon as each of the cluster centers
                moves by less than <code>criteria.epsilon</code> on some iteration, the
                algorithm stops.
            </dd>
            <dd><code>attempts</code> - Flag to specify the number of times the algorithm is
                executed
                using different initial labellings. The algorithm returns the labels that
                yield the best compactness (see the last function parameter).
            </dd>
            <dd><code>flags</code> - Flag that can take the following values:
                <ul>
                    <li> KMEANS_RANDOM_CENTERS Select random initial centers in each attempt.
                    <li> KMEANS_PP_CENTERS Use <code>kmeans++</code> center initialization by
                        Arthur and Vassilvitskii [Arthur2007].
                    <li> KMEANS_USE_INITIAL_LABELS During the first (and possibly the only)
                        attempt, use the user-supplied labels instead of computing them from the
                        initial centers. For the second and further attempts, use the random or
                        semi-random centers. Use one of <code>KMEANS_*_CENTERS</code> flag to
                        specify
                        the exact method.
                </ul>
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/clustering.html#kmeans">org.opencv.core.Core.kmeans</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="kmeans(org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.TermCriteria, int, int, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>kmeans</h4>
<pre>public static&nbsp;double&nbsp;kmeans(<a href="../../../org/opencv/core/Mat.html"
                                              title="class in org.opencv.core">Mat</a>&nbsp;data,
            int&nbsp;K,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;bestLabels,
            <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria,
            int&nbsp;attempts,
            int&nbsp;flags,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;centers)</pre>
        <div class="block"><p>Finds centers of clusters and groups input samples around the
            clusters.</p>

            <p>The function <code>kmeans</code> implements a k-means algorithm that finds
                the centers of <code>cluster_count</code> clusters and groups the input
                samples around the clusters. As an output, <em>labels_i</em> contains a
                0-based cluster index for the sample stored in the <em>i^(th)</em> row of the
                <code>samples</code> matrix.</p>

            <p>The function returns the compactness measure that is computed as</p>

            <p><em>sum _i|samples _i - centers _(labels _i)| ^2</em></p>

            <p>after every attempt. The best (minimum) value is chosen and the corresponding
                labels and the compactness value are returned by the function.
                Basically, you can use only the core of the function, set the number of
                attempts to 1, initialize labels each time using a custom algorithm, pass
                them with the (<code>flags</code> = <code>KMEANS_USE_INITIAL_LABELS</code>)
                flag, and then choose the best (most-compact) clustering.</p>

            <p>Note:</p>
            <ul>
                <li> An example on K-means clustering can be found at
                    opencv_source_code/samples/cpp/kmeans.cpp
                <li> (Python) An example on K-means clustering can be found at
                    opencv_source_code/samples/python2/kmeans.py
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>data</code> - Data for clustering. An array of N-Dimensional points with float
                coordinates is needed. Examples of this array can be:
                <ul>
                    <li><code>Mat points(count, 2, CV_32F);</code>
                    <li><code>Mat points(count, 1, CV_32FC2);</code>
                    <li><code>Mat points(1, count, CV_32FC2);</code>
                    <li><code>std.vector
                        <cv.Point2f> points(sampleCount);
                    </code>
                </ul>
            </dd>
            <dd><code>K</code> - Number of clusters to split the set by.</dd>
            <dd><code>bestLabels</code> - a bestLabels</dd>
            <dd><code>criteria</code> - The algorithm termination criteria, that is, the maximum
                number of iterations and/or the desired accuracy. The accuracy is specified
                as <code>criteria.epsilon</code>. As soon as each of the cluster centers
                moves by less than <code>criteria.epsilon</code> on some iteration, the
                algorithm stops.
            </dd>
            <dd><code>attempts</code> - Flag to specify the number of times the algorithm is
                executed
                using different initial labellings. The algorithm returns the labels that
                yield the best compactness (see the last function parameter).
            </dd>
            <dd><code>flags</code> - Flag that can take the following values:
                <ul>
                    <li> KMEANS_RANDOM_CENTERS Select random initial centers in each attempt.
                    <li> KMEANS_PP_CENTERS Use <code>kmeans++</code> center initialization by
                        Arthur and Vassilvitskii [Arthur2007].
                    <li> KMEANS_USE_INITIAL_LABELS During the first (and possibly the only)
                        attempt, use the user-supplied labels instead of computing them from the
                        initial centers. For the second and further attempts, use the random or
                        semi-random centers. Use one of <code>KMEANS_*_CENTERS</code> flag to
                        specify
                        the exact method.
                </ul>
            </dd>
            <dd><code>centers</code> - Output matrix of the cluster centers, one row per each
                cluster
                center.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/clustering.html#kmeans">org.opencv.core.Core.kmeans</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="line(org.opencv.core.Mat, org.opencv.core.Point, org.opencv.core.Point, org.opencv.core.Scalar)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>line</h4>
<pre>public static&nbsp;void&nbsp;line(<a href="../../../org/opencv/core/Mat.html"
                                          title="class in org.opencv.core">Mat</a>&nbsp;img,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</pre>
        <div class="block"><p>Draws a line segment connecting two points.</p>

            <p>The function <code>line</code> draws the line segment between
                <code>pt1</code> and <code>pt2</code> points in the image. The line is
                clipped by the image boundaries. For non-antialiased lines with integer
                coordinates, the 8-connected or 4-connected Bresenham algorithm is used.
                Thick lines are drawn with rounding endings.
                Antialiased lines are drawn using Gaussian filtering. To specify the line
                color, you may use the macro <code>CV_RGB(r, g, b)</code>.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>img</code> - Image.</dd>
            <dd><code>pt1</code> - First point of the line segment.</dd>
            <dd><code>pt2</code> - Second point of the line segment.</dd>
            <dd><code>color</code> - Line color.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#line">org.opencv.core.Core.line</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="line(org.opencv.core.Mat, org.opencv.core.Point, org.opencv.core.Point, org.opencv.core.Scalar, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>line</h4>
<pre>public static&nbsp;void&nbsp;line(<a href="../../../org/opencv/core/Mat.html"
                                          title="class in org.opencv.core">Mat</a>&nbsp;img,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
        int&nbsp;thickness)</pre>
        <div class="block"><p>Draws a line segment connecting two points.</p>

            <p>The function <code>line</code> draws the line segment between
                <code>pt1</code> and <code>pt2</code> points in the image. The line is
                clipped by the image boundaries. For non-antialiased lines with integer
                coordinates, the 8-connected or 4-connected Bresenham algorithm is used.
                Thick lines are drawn with rounding endings.
                Antialiased lines are drawn using Gaussian filtering. To specify the line
                color, you may use the macro <code>CV_RGB(r, g, b)</code>.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>img</code> - Image.</dd>
            <dd><code>pt1</code> - First point of the line segment.</dd>
            <dd><code>pt2</code> - Second point of the line segment.</dd>
            <dd><code>color</code> - Line color.</dd>
            <dd><code>thickness</code> - Line thickness.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#line">org.opencv.core.Core.line</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="line(org.opencv.core.Mat, org.opencv.core.Point, org.opencv.core.Point, org.opencv.core.Scalar, int, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>line</h4>
<pre>public static&nbsp;void&nbsp;line(<a href="../../../org/opencv/core/Mat.html"
                                          title="class in org.opencv.core">Mat</a>&nbsp;img,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
        int&nbsp;thickness,
        int&nbsp;lineType,
        int&nbsp;shift)</pre>
        <div class="block"><p>Draws a line segment connecting two points.</p>

            <p>The function <code>line</code> draws the line segment between
                <code>pt1</code> and <code>pt2</code> points in the image. The line is
                clipped by the image boundaries. For non-antialiased lines with integer
                coordinates, the 8-connected or 4-connected Bresenham algorithm is used.
                Thick lines are drawn with rounding endings.
                Antialiased lines are drawn using Gaussian filtering. To specify the line
                color, you may use the macro <code>CV_RGB(r, g, b)</code>.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>img</code> - Image.</dd>
            <dd><code>pt1</code> - First point of the line segment.</dd>
            <dd><code>pt2</code> - Second point of the line segment.</dd>
            <dd><code>color</code> - Line color.</dd>
            <dd><code>thickness</code> - Line thickness.</dd>
            <dd><code>lineType</code> - Type of the line:
                <ul>
                    <li> 8 (or omitted) - 8-connected line.
                    <li> 4 - 4-connected line.
                    <li> CV_AA - antialiased line.
                </ul>
            </dd>
            <dd><code>shift</code> - Number of fractional bits in the point coordinates.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#line">org.opencv.core.Core.line</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="log(org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>log</h4>
<pre>public static&nbsp;void&nbsp;log(<a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a>&nbsp;src,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Calculates the natural logarithm of every array element.</p>

            <p>The function <code>log</code> calculates the natural logarithm of the
                absolute value of every element of the input array:</p>

            <p><em>dst(I) = log|src(I)| if src(I) != 0 ; C otherwise</em></p>

            <p>where <code>C</code> is a large negative number (about -700 in the current
                implementation).
                The maximum relative error is about <code>7e-6</code> for single-precision
                input and less than <code>1e-10</code> for double-precision input. Special
                values (NaN, Inf) are not handled.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input array.</dd>
            <dd><code>dst</code> - output array of the same size and type as <code>src</code>.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#log">org.opencv.core.Core.log</a>,
                <a href="../../../org/opencv/core/Core.html#cartToPolar(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)"><code>cartToPolar(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat,
                    boolean)</code></a>,
                <a href="../../../org/opencv/core/Core.html#pow(org.opencv.core.Mat, double, org.opencv.core.Mat)"><code>pow(org.opencv.core.Mat,
                    double, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#sqrt(org.opencv.core.Mat, org.opencv.core.Mat)"><code>sqrt(org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#magnitude(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>magnitude(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#polarToCart(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)"><code>polarToCart(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat,
                    boolean)</code></a>,
                <a href="../../../org/opencv/core/Core.html#exp(org.opencv.core.Mat, org.opencv.core.Mat)"><code>exp(org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#phase(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)"><code>phase(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, boolean)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="LUT(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>LUT</h4>
<pre>public static&nbsp;void&nbsp;LUT(<a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a>&nbsp;src,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lut,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Performs a look-up table transform of an array.</p>

            <p>The function <code>LUT</code> fills the output array with values from the
                look-up table. Indices of the entries are taken from the input array. That
                is, the function processes each element of <code>src</code> as follows:</p>

            <p><em>dst(I) <- lut(src(I) + d)</em></p>

            <p>where</p>

            <p><em>d = 0 if src has depth CV_8U; 128 if src has depth CV_8S</em></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input array of 8-bit elements.</dd>
            <dd><code>lut</code> - look-up table of 256 elements; in case of multi-channel input
                array, the table should either have a single channel (in this case the same
                table is used for all channels) or the same number of channels as in the
                input array.
            </dd>
            <dd><code>dst</code> - output array of the same size and number of channels as
                <code>src</code>, and the same depth as <code>lut</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#lut">org.opencv.core.Core.LUT</a>,
                <a href="../../../org/opencv/core/Mat.html#convertTo(org.opencv.core.Mat, int, double, double)"><code>Mat.convertTo(org.opencv.core.Mat,
                    int, double, double)</code></a>,
                <a href="../../../org/opencv/core/Core.html#convertScaleAbs(org.opencv.core.Mat, org.opencv.core.Mat, double, double)"><code>convertScaleAbs(org.opencv.core.Mat,
                    org.opencv.core.Mat, double, double)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="LUT(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>LUT</h4>
<pre>public static&nbsp;void&nbsp;LUT(<a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a>&nbsp;src,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lut,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
       int&nbsp;interpolation)</pre>
        <div class="block"><p>Performs a look-up table transform of an array.</p>

            <p>The function <code>LUT</code> fills the output array with values from the
                look-up table. Indices of the entries are taken from the input array. That
                is, the function processes each element of <code>src</code> as follows:</p>

            <p><em>dst(I) <- lut(src(I) + d)</em></p>

            <p>where</p>

            <p><em>d = 0 if src has depth CV_8U; 128 if src has depth CV_8S</em></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input array of 8-bit elements.</dd>
            <dd><code>lut</code> - look-up table of 256 elements; in case of multi-channel input
                array, the table should either have a single channel (in this case the same
                table is used for all channels) or the same number of channels as in the
                input array.
            </dd>
            <dd><code>dst</code> - output array of the same size and number of channels as
                <code>src</code>, and the same depth as <code>lut</code>.
            </dd>
            <dd><code>interpolation</code> - a interpolation</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#lut">org.opencv.core.Core.LUT</a>,
                <a href="../../../org/opencv/core/Mat.html#convertTo(org.opencv.core.Mat, int, double, double)"><code>Mat.convertTo(org.opencv.core.Mat,
                    int, double, double)</code></a>,
                <a href="../../../org/opencv/core/Core.html#convertScaleAbs(org.opencv.core.Mat, org.opencv.core.Mat, double, double)"><code>convertScaleAbs(org.opencv.core.Mat,
                    org.opencv.core.Mat, double, double)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="magnitude(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>magnitude</h4>
<pre>public static&nbsp;void&nbsp;magnitude(<a href="../../../org/opencv/core/Mat.html"
                                               title="class in org.opencv.core">Mat</a>&nbsp;x,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;y,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;magnitude)</pre>
        <div class="block"><p>Calculates the magnitude of 2D vectors.</p>

            <p>The function <code>magnitude</code> calculates the magnitude of 2D vectors
                formed from the corresponding elements of <code>x</code> and <code>y</code>
                arrays:</p>

            <p><em>dst(I) = sqrt(x(I)^2 + y(I)^2)</em></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>x</code> - floating-point array of x-coordinates of the vectors.</dd>
            <dd><code>y</code> - floating-point array of y-coordinates of the vectors; it must have
                the same size as <code>x</code>.
            </dd>
            <dd><code>magnitude</code> - output array of the same size and type as <code>x</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#magnitude">org.opencv.core.Core.magnitude</a>,
                <a href="../../../org/opencv/core/Core.html#cartToPolar(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)"><code>cartToPolar(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat,
                    boolean)</code></a>,
                <a href="../../../org/opencv/core/Core.html#phase(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)"><code>phase(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, boolean)</code></a>,
                <a href="../../../org/opencv/core/Core.html#sqrt(org.opencv.core.Mat, org.opencv.core.Mat)"><code>sqrt(org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#polarToCart(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)"><code>polarToCart(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat,
                    boolean)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="Mahalanobis(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>Mahalanobis</h4>
<pre>public static&nbsp;double&nbsp;Mahalanobis(<a href="../../../org/opencv/core/Mat.html"
                                                   title="class in org.opencv.core">Mat</a>&nbsp;v1,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;v2,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;icovar)</pre>
        <div class="block"><p>Calculates the Mahalanobis distance between two vectors.</p>

            <p>The function <code>Mahalanobis</code> calculates and returns the weighted
                distance between two vectors:</p>

            <p><em>d(vec1, vec2)=
                sqrt(sum_(i,j)(icovar(i,j)*(vec1(I)-vec2(I))*(vec1(j)-vec2(j))))</em></p>

            <p>The covariance matrix may be calculated using the "calcCovarMatrix" function
                and then inverted using the "invert" function (preferably using the
                <code>DECOMP_SVD</code> method, as the most accurate).</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>v1</code> - a v1</dd>
            <dd><code>v2</code> - a v2</dd>
            <dd><code>icovar</code> - inverse covariance matrix.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#mahalanobis">org.opencv.core.Core.Mahalanobis</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="max(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>max</h4>
<pre>public static&nbsp;void&nbsp;max(<a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a>&nbsp;src1,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Calculates per-element maximum of two arrays or an array and a
            scalar.</p>

            <p>The functions <code>max</code> calculate the per-element maximum of two
                arrays:</p>

            <p><em>dst(I)= max(src1(I), src2(I))</em></p>

            <p>or array and a scalar:</p>

            <p><em>dst(I)= max(src1(I), value)</em></p>

            <p>In the second variant, when the input array is multi-channel, each channel is
                compared with <code>value</code> independently.</p>

            <p>The first 3 variants of the function listed above are actually a part of
                "MatrixExpressions". They return an expression object that can be further
                either transformed/ assigned to a matrix, or passed to a function, and so on.</p>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array.</dd>
            <dd><code>src2</code> - second input array of the same size and type as
                <code>src1</code>.
            </dd>
            <dd><code>dst</code> - output array of the same size and type as <code>src1</code>.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#max">org.opencv.core.Core.max</a>,
                <a href="../../../org/opencv/core/Core.html#compare(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>compare(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#inRange(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Scalar, org.opencv.core.Mat)"><code>inRange(org.opencv.core.Mat,
                    org.opencv.core.Scalar, org.opencv.core.Scalar, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#minMaxLoc(org.opencv.core.Mat, org.opencv.core.Mat)"><code>minMaxLoc(org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#min(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>min(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="max(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>max</h4>
<pre>public static&nbsp;void&nbsp;max(<a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a>&nbsp;src1,
       <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Calculates per-element maximum of two arrays or an array and a
            scalar.</p>

            <p>The functions <code>max</code> calculate the per-element maximum of two
                arrays:</p>

            <p><em>dst(I)= max(src1(I), src2(I))</em></p>

            <p>or array and a scalar:</p>

            <p><em>dst(I)= max(src1(I), value)</em></p>

            <p>In the second variant, when the input array is multi-channel, each channel is
                compared with <code>value</code> independently.</p>

            <p>The first 3 variants of the function listed above are actually a part of
                "MatrixExpressions". They return an expression object that can be further
                either transformed/ assigned to a matrix, or passed to a function, and so on.</p>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array.</dd>
            <dd><code>src2</code> - second input array of the same size and type as
                <code>src1</code>.
            </dd>
            <dd><code>dst</code> - output array of the same size and type as <code>src1</code>.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#max">org.opencv.core.Core.max</a>,
                <a href="../../../org/opencv/core/Core.html#compare(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>compare(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#inRange(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Scalar, org.opencv.core.Mat)"><code>inRange(org.opencv.core.Mat,
                    org.opencv.core.Scalar, org.opencv.core.Scalar, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#minMaxLoc(org.opencv.core.Mat, org.opencv.core.Mat)"><code>minMaxLoc(org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#min(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>min(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="mean(org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>mean</h4>
        <pre>public static&nbsp;<a href="../../../org/opencv/core/Scalar.html"
                                   title="class in org.opencv.core">Scalar</a>&nbsp;mean(<a
                href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src)</pre>
        <div class="block"><p>Calculates an average (mean) of array elements.</p>

            <p>The function <code>mean</code> calculates the mean value <code>M</code> of
                array elements, independently for each channel, and return it:</p>

            <p><em>N = sum(by: I: mask(I) != 0) 1
                M_c = (sum(by: I: mask(I) != 0)(mtx(I)_c))/N </em></p>

            <p>When all the mask elements are 0's, the functions return <code>Scalar.all(0)</code>.
            </p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input array that should have from 1 to 4 channels so that the
                result can be stored in "Scalar_".
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#mean">org.opencv.core.Core.mean</a>,
                <a href="../../../org/opencv/core/Core.html#countNonZero(org.opencv.core.Mat)"><code>countNonZero(org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#meanStdDev(org.opencv.core.Mat, org.opencv.core.MatOfDouble, org.opencv.core.MatOfDouble, org.opencv.core.Mat)"><code>meanStdDev(org.opencv.core.Mat,
                    org.opencv.core.MatOfDouble, org.opencv.core.MatOfDouble,
                    org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#norm(org.opencv.core.Mat, int, org.opencv.core.Mat)"><code>norm(org.opencv.core.Mat,
                    int, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#minMaxLoc(org.opencv.core.Mat, org.opencv.core.Mat)"><code>minMaxLoc(org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="mean(org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>mean</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Scalar.html"
                           title="class in org.opencv.core">Scalar</a>&nbsp;mean(<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
        <div class="block"><p>Calculates an average (mean) of array elements.</p>

            <p>The function <code>mean</code> calculates the mean value <code>M</code> of
                array elements, independently for each channel, and return it:</p>

            <p><em>N = sum(by: I: mask(I) != 0) 1
                M_c = (sum(by: I: mask(I) != 0)(mtx(I)_c))/N </em></p>

            <p>When all the mask elements are 0's, the functions return <code>Scalar.all(0)</code>.
            </p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input array that should have from 1 to 4 channels so that the
                result can be stored in "Scalar_".
            </dd>
            <dd><code>mask</code> - optional operation mask.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#mean">org.opencv.core.Core.mean</a>,
                <a href="../../../org/opencv/core/Core.html#countNonZero(org.opencv.core.Mat)"><code>countNonZero(org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#meanStdDev(org.opencv.core.Mat, org.opencv.core.MatOfDouble, org.opencv.core.MatOfDouble, org.opencv.core.Mat)"><code>meanStdDev(org.opencv.core.Mat,
                    org.opencv.core.MatOfDouble, org.opencv.core.MatOfDouble,
                    org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#norm(org.opencv.core.Mat, int, org.opencv.core.Mat)"><code>norm(org.opencv.core.Mat,
                    int, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#minMaxLoc(org.opencv.core.Mat, org.opencv.core.Mat)"><code>minMaxLoc(org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="meanStdDev(org.opencv.core.Mat, org.opencv.core.MatOfDouble, org.opencv.core.MatOfDouble)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>meanStdDev</h4>
<pre>public static&nbsp;void&nbsp;meanStdDev(<a href="../../../org/opencv/core/Mat.html"
                                                title="class in org.opencv.core">Mat</a>&nbsp;src,
              <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;mean,
              <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;stddev)</pre>
        <div class="block"><p>Calculates a mean and standard deviation of array elements.</p>

            <p>The function <code>meanStdDev</code> calculates the mean and the standard
                deviation <code>M</code> of array elements independently for each channel and
                returns it via the output parameters:</p>

            <p><em>N = sum(by: I, mask(I) != 0) 1
                mean _c = (sum_(I: mask(I) != 0) src(I)_c)/(N)
                stddev _c = sqrt((sum_(I: mask(I) != 0)(src(I)_c - mean _c)^2)/(N)) </em></p>

            <p>When all the mask elements are 0's, the functions return <code>mean=stddev=Scalar.all(0)</code>.
            </p>

            <p>Note: The calculated standard deviation is only the diagonal of the complete
                normalized covariance matrix. If the full matrix is needed, you can reshape
                the multi-channel array <code>M x N</code> to the single-channel array
                <code>M*N x mtx.channels()</code> (only possible when the matrix is
                continuous) and then pass the matrix to "calcCovarMatrix".</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input array that should have from 1 to 4 channels so that the
                results can be stored in "Scalar_" 's.
            </dd>
            <dd><code>mean</code> - output parameter: calculated mean value.</dd>
            <dd><code>stddev</code> - output parameter: calculateded standard deviation.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#meanstddev">org.opencv.core.Core.meanStdDev</a>,
                <a href="../../../org/opencv/core/Core.html#countNonZero(org.opencv.core.Mat)"><code>countNonZero(org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#calcCovarMatrix(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int)"><code>calcCovarMatrix(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, int, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#minMaxLoc(org.opencv.core.Mat, org.opencv.core.Mat)"><code>minMaxLoc(org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#norm(org.opencv.core.Mat, int, org.opencv.core.Mat)"><code>norm(org.opencv.core.Mat,
                    int, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#mean(org.opencv.core.Mat, org.opencv.core.Mat)"><code>mean(org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="meanStdDev(org.opencv.core.Mat, org.opencv.core.MatOfDouble, org.opencv.core.MatOfDouble, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>meanStdDev</h4>
<pre>public static&nbsp;void&nbsp;meanStdDev(<a href="../../../org/opencv/core/Mat.html"
                                                title="class in org.opencv.core">Mat</a>&nbsp;src,
              <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;mean,
              <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;stddev,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
        <div class="block"><p>Calculates a mean and standard deviation of array elements.</p>

            <p>The function <code>meanStdDev</code> calculates the mean and the standard
                deviation <code>M</code> of array elements independently for each channel and
                returns it via the output parameters:</p>

            <p><em>N = sum(by: I, mask(I) != 0) 1
                mean _c = (sum_(I: mask(I) != 0) src(I)_c)/(N)
                stddev _c = sqrt((sum_(I: mask(I) != 0)(src(I)_c - mean _c)^2)/(N)) </em></p>

            <p>When all the mask elements are 0's, the functions return <code>mean=stddev=Scalar.all(0)</code>.
            </p>

            <p>Note: The calculated standard deviation is only the diagonal of the complete
                normalized covariance matrix. If the full matrix is needed, you can reshape
                the multi-channel array <code>M x N</code> to the single-channel array
                <code>M*N x mtx.channels()</code> (only possible when the matrix is
                continuous) and then pass the matrix to "calcCovarMatrix".</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input array that should have from 1 to 4 channels so that the
                results can be stored in "Scalar_" 's.
            </dd>
            <dd><code>mean</code> - output parameter: calculated mean value.</dd>
            <dd><code>stddev</code> - output parameter: calculateded standard deviation.</dd>
            <dd><code>mask</code> - optional operation mask.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#meanstddev">org.opencv.core.Core.meanStdDev</a>,
                <a href="../../../org/opencv/core/Core.html#countNonZero(org.opencv.core.Mat)"><code>countNonZero(org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#calcCovarMatrix(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int)"><code>calcCovarMatrix(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, int, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#minMaxLoc(org.opencv.core.Mat, org.opencv.core.Mat)"><code>minMaxLoc(org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#norm(org.opencv.core.Mat, int, org.opencv.core.Mat)"><code>norm(org.opencv.core.Mat,
                    int, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#mean(org.opencv.core.Mat, org.opencv.core.Mat)"><code>mean(org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="merge(java.util.List, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>merge</h4>
<pre>public static&nbsp;void&nbsp;merge(java.util.List&lt;<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;mv,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Creates one multichannel array out of several single-channel ones.</p>

            <p>The functions <code>merge</code> merge several arrays to make a single
                multi-channel array. That is, each element of the output array will be a
                concatenation of the elements of the input arrays, where elements of i-th
                input array are treated as <code>mv[i].channels()</code>-element vectors.</p>

            <p>The function "split" does the reverse operation. If you need to shuffle
                channels in some other advanced way, use "mixChannels".</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>mv</code> - input array or vector of matrices to be merged; all the matrices
                in
                <code>mv</code> must have the same size and the same depth.
            </dd>
            <dd><code>dst</code> - output array of the same size and the same depth as
                <code>mv[0]</code>; The number of channels will be the total number of
                channels in the matrix array.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#merge">org.opencv.core.Core.merge</a>,
                <a href="../../../org/opencv/core/Mat.html#reshape(int, int)"><code>Mat.reshape(int,
                    int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#mixChannels(java.util.List, java.util.List, org.opencv.core.MatOfInt)"><code>mixChannels(java.util.List
                    <org.opencv.core.Mat>, java.util.List
                        <org.opencv.core.Mat>, org.opencv.core.MatOfInt)
                </code></a>,
                <a href="../../../org/opencv/core/Core.html#split(org.opencv.core.Mat, java.util.List)"><code>split(org.opencv.core.Mat,
                    java.util.List
                    <org.opencv.core.Mat>)
                </code></a></dd>
        </dl>
    </li>
</ul>
<a name="min(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>min</h4>
<pre>public static&nbsp;void&nbsp;min(<a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a>&nbsp;src1,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Calculates per-element minimum of two arrays or an array and a
            scalar.</p>

            <p>The functions <code>min</code> calculate the per-element minimum of two
                arrays:</p>

            <p><em>dst(I)= min(src1(I), src2(I))</em></p>

            <p>or array and a scalar:</p>

            <p><em>dst(I)= min(src1(I), value)</em></p>

            <p>In the second variant, when the input array is multi-channel, each channel is
                compared with <code>value</code> independently.</p>

            <p>The first three variants of the function listed above are actually a part of
                "MatrixExpressions". They return the expression object that can be further
                either transformed/assigned to a matrix, or passed to a function, and so on.</p>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array.</dd>
            <dd><code>src2</code> - second input array of the same size and type as
                <code>src1</code>.
            </dd>
            <dd><code>dst</code> - output array of the same size and type as <code>src1</code>.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#min">org.opencv.core.Core.min</a>,
                <a href="../../../org/opencv/core/Core.html#max(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>max(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#compare(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>compare(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#inRange(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Scalar, org.opencv.core.Mat)"><code>inRange(org.opencv.core.Mat,
                    org.opencv.core.Scalar, org.opencv.core.Scalar, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#minMaxLoc(org.opencv.core.Mat, org.opencv.core.Mat)"><code>minMaxLoc(org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="min(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>min</h4>
<pre>public static&nbsp;void&nbsp;min(<a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a>&nbsp;src1,
       <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Calculates per-element minimum of two arrays or an array and a
            scalar.</p>

            <p>The functions <code>min</code> calculate the per-element minimum of two
                arrays:</p>

            <p><em>dst(I)= min(src1(I), src2(I))</em></p>

            <p>or array and a scalar:</p>

            <p><em>dst(I)= min(src1(I), value)</em></p>

            <p>In the second variant, when the input array is multi-channel, each channel is
                compared with <code>value</code> independently.</p>

            <p>The first three variants of the function listed above are actually a part of
                "MatrixExpressions". They return the expression object that can be further
                either transformed/assigned to a matrix, or passed to a function, and so on.</p>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array.</dd>
            <dd><code>src2</code> - second input array of the same size and type as
                <code>src1</code>.
            </dd>
            <dd><code>dst</code> - output array of the same size and type as <code>src1</code>.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#min">org.opencv.core.Core.min</a>,
                <a href="../../../org/opencv/core/Core.html#max(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>max(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#compare(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>compare(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#inRange(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Scalar, org.opencv.core.Mat)"><code>inRange(org.opencv.core.Mat,
                    org.opencv.core.Scalar, org.opencv.core.Scalar, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#minMaxLoc(org.opencv.core.Mat, org.opencv.core.Mat)"><code>minMaxLoc(org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="minMaxLoc(org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>minMaxLoc</h4>
        <pre>public static&nbsp;<a href="../../../org/opencv/core/Core.MinMaxLocResult.html"
                                   title="class in org.opencv.core">Core.MinMaxLocResult</a>&nbsp;minMaxLoc(<a
                href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src)</pre>
        <div class="block"><p>Finds the global minimum and maximum in an array.</p>

            <p>The functions <code>minMaxLoc</code> find the minimum and maximum element
                values and their positions. The extremums are searched across the whole array
                or, if <code>mask</code> is not an empty array, in the specified array
                region.</p>

            <p>The functions do not work with multi-channel arrays. If you need to find
                minimum or maximum elements across all the channels, use "Mat.reshape" first
                to reinterpret the array as single-channel. Or you may extract the particular
                channel using either "extractImageCOI", or "mixChannels", or "split".</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input single-channel array.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#minmaxloc">org.opencv.core.Core.minMaxLoc</a>,
                <a href="../../../org/opencv/core/Core.html#compare(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>compare(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#min(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>min(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#mixChannels(java.util.List, java.util.List, org.opencv.core.MatOfInt)"><code>mixChannels(java.util.List
                    <org.opencv.core.Mat>, java.util.List
                        <org.opencv.core.Mat>, org.opencv.core.MatOfInt)
                </code></a>,
                <a href="../../../org/opencv/core/Mat.html#reshape(int, int)"><code>Mat.reshape(int,
                    int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#split(org.opencv.core.Mat, java.util.List)"><code>split(org.opencv.core.Mat,
                    java.util.List
                    <org.opencv.core.Mat>)
                </code></a>,
                <a href="../../../org/opencv/core/Core.html#max(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>max(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#inRange(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Scalar, org.opencv.core.Mat)"><code>inRange(org.opencv.core.Mat,
                    org.opencv.core.Scalar, org.opencv.core.Scalar, org.opencv.core.Mat)</code></a>
            </dd>
        </dl>
    </li>
</ul>
<a name="minMaxLoc(org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>minMaxLoc</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Core.MinMaxLocResult.html"
                           title="class in org.opencv.core">Core.MinMaxLocResult</a>&nbsp;minMaxLoc(<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                             <a href="../../../org/opencv/core/Mat.html"
                                title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
        <div class="block"><p>Finds the global minimum and maximum in an array.</p>

            <p>The functions <code>minMaxLoc</code> find the minimum and maximum element
                values and their positions. The extremums are searched across the whole array
                or, if <code>mask</code> is not an empty array, in the specified array
                region.</p>

            <p>The functions do not work with multi-channel arrays. If you need to find
                minimum or maximum elements across all the channels, use "Mat.reshape" first
                to reinterpret the array as single-channel. Or you may extract the particular
                channel using either "extractImageCOI", or "mixChannels", or "split".</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input single-channel array.</dd>
            <dd><code>mask</code> - optional mask used to select a sub-array.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#minmaxloc">org.opencv.core.Core.minMaxLoc</a>,
                <a href="../../../org/opencv/core/Core.html#compare(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>compare(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#min(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>min(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#mixChannels(java.util.List, java.util.List, org.opencv.core.MatOfInt)"><code>mixChannels(java.util.List
                    <org.opencv.core.Mat>, java.util.List
                        <org.opencv.core.Mat>, org.opencv.core.MatOfInt)
                </code></a>,
                <a href="../../../org/opencv/core/Mat.html#reshape(int, int)"><code>Mat.reshape(int,
                    int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#split(org.opencv.core.Mat, java.util.List)"><code>split(org.opencv.core.Mat,
                    java.util.List
                    <org.opencv.core.Mat>)
                </code></a>,
                <a href="../../../org/opencv/core/Core.html#max(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>max(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#inRange(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Scalar, org.opencv.core.Mat)"><code>inRange(org.opencv.core.Mat,
                    org.opencv.core.Scalar, org.opencv.core.Scalar, org.opencv.core.Mat)</code></a>
            </dd>
        </dl>
    </li>
</ul>
<a name="mixChannels(java.util.List, java.util.List, org.opencv.core.MatOfInt)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>mixChannels</h4>
<pre>public static&nbsp;void&nbsp;mixChannels(java.util.List&lt;<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;src,
               java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                                    title="class in org.opencv.core">Mat</a>&gt;&nbsp;dst,
               <a href="../../../org/opencv/core/MatOfInt.html" title="class in org.opencv.core">MatOfInt</a>&nbsp;fromTo)</pre>
        <div class="block"><p>Copies specified channels from input arrays to the specified channels
            of
            output arrays.</p>

            <p>The functions <code>mixChannels</code> provide an advanced mechanism for
                shuffling image channels.</p>

            <p>"split" and "merge" and some forms of "cvtColor" are partial cases of
                <code>mixChannels</code>.
                In the example below, the code splits a 4-channel RGBA image into a 3-channel
                BGR (with R and B channels swapped) and a separate alpha-channel image:
                <code></p>

            <p>// C++ code:</p>

            <p>Mat rgba(100, 100, CV_8UC4, Scalar(1,2,3,4));</p>

            <p>Mat bgr(rgba.rows, rgba.cols, CV_8UC3);</p>

            <p>Mat alpha(rgba.rows, rgba.cols, CV_8UC1);</p>

            <p>// forming an array of matrices is a quite efficient operation,</p>

            <p>// because the matrix data is not copied, only the headers</p>

            <p>Mat out[] = { bgr, alpha };</p>

            <p>// rgba[0] -> bgr[2], rgba[1] -> bgr[1],</p>

            <p>// rgba[2] -> bgr[0], rgba[3] -> alpha[0]</p>

            <p>int from_to[] = { 0,2, 1,1, 2,0, 3,3 };</p>

            <p>mixChannels(&rgba, 1, out, 2, from_to, 4);</p>

            <p>Note: Unlike many other new-style C++ functions in OpenCV (see the
                introduction section and "Mat.create"), <code>mixChannels</code> requires
                the output arrays to be pre-allocated before calling the function.
                </code></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input array or vector of matricesl; all of the matrices must have
                the same size and the same depth.
            </dd>
            <dd><code>dst</code> - output array or vector of matrices; all the matrices *must be
                allocated*; their size and depth must be the same as in <code>src[0]</code>.
            </dd>
            <dd><code>fromTo</code> - array of index pairs specifying which channels are copied and
                where; <code>fromTo[k*2]</code> is a 0-based index of the input channel in
                <code>src</code>, <code>fromTo[k*2+1]</code> is an index of the output
                channel in <code>dst</code>; the continuous channel numbering is used: the
                first input image channels are indexed from <code>0</code> to
                <code>src[0].channels()-1</code>, the second input image channels are indexed
                from <code>src[0].channels()</code> to <code>src[0].channels() +
                    src[1].channels()-1</code>, and so on, the same scheme is used for the output
                image channels; as a special case, when <code>fromTo[k*2]</code> is negative,
                the corresponding output channel is filled with zero.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#mixchannels">org.opencv.core.Core.mixChannels</a>,
                <a href="../../../org/opencv/core/Core.html#merge(java.util.List, org.opencv.core.Mat)"><code>merge(java.util.List
                    <org.opencv.core.Mat>, org.opencv.core.Mat)
                </code></a>,
                <a href="../../../org/opencv/core/Core.html#split(org.opencv.core.Mat, java.util.List)"><code>split(org.opencv.core.Mat,
                    java.util.List
                    <org.opencv.core.Mat>)
                </code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#cvtColor(org.opencv.core.Mat, org.opencv.core.Mat, int, int)"><code>Imgproc.cvtColor(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="mulSpectrums(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>mulSpectrums</h4>
<pre>public static&nbsp;void&nbsp;mulSpectrums(<a href="../../../org/opencv/core/Mat.html"
                                                  title="class in org.opencv.core">Mat</a>&nbsp;a,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;b,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;c,
                int&nbsp;flags)</pre>
        <div class="block"><p>Performs the per-element multiplication of two Fourier spectrums.</p>

            <p>The function <code>mulSpectrums</code> performs the per-element
                multiplication of the two CCS-packed or complex matrices that are results of
                a real or complex Fourier transform.</p>

            <p>The function, together with "dft" and "idft", may be used to calculate
                convolution (pass <code>conjB=false</code>) or correlation (pass
                <code>conjB=true</code>) of two arrays rapidly. When the arrays are complex,
                they are simply multiplied (per element) with an optional conjugation of the
                second-array elements. When the arrays are real, they are assumed to be
                CCS-packed (see "dft" for details).</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>a</code> - a a</dd>
            <dd><code>b</code> - a b</dd>
            <dd><code>c</code> - a c</dd>
            <dd><code>flags</code> - operation flags; currently, the only supported flag is
                <code>DFT_ROWS</code>, which indicates that each row of <code>src1</code> and
                <code>src2</code> is an independent 1D Fourier spectrum. If you do not want
                to use this flag, then simply add a "0" as value.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#mulspectrums">org.opencv.core.Core.mulSpectrums</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="mulSpectrums(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, boolean)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>mulSpectrums</h4>
<pre>public static&nbsp;void&nbsp;mulSpectrums(<a href="../../../org/opencv/core/Mat.html"
                                                  title="class in org.opencv.core">Mat</a>&nbsp;a,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;b,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;c,
                int&nbsp;flags,
                boolean&nbsp;conjB)</pre>
        <div class="block"><p>Performs the per-element multiplication of two Fourier spectrums.</p>

            <p>The function <code>mulSpectrums</code> performs the per-element
                multiplication of the two CCS-packed or complex matrices that are results of
                a real or complex Fourier transform.</p>

            <p>The function, together with "dft" and "idft", may be used to calculate
                convolution (pass <code>conjB=false</code>) or correlation (pass
                <code>conjB=true</code>) of two arrays rapidly. When the arrays are complex,
                they are simply multiplied (per element) with an optional conjugation of the
                second-array elements. When the arrays are real, they are assumed to be
                CCS-packed (see "dft" for details).</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>a</code> - a a</dd>
            <dd><code>b</code> - a b</dd>
            <dd><code>c</code> - a c</dd>
            <dd><code>flags</code> - operation flags; currently, the only supported flag is
                <code>DFT_ROWS</code>, which indicates that each row of <code>src1</code> and
                <code>src2</code> is an independent 1D Fourier spectrum. If you do not want
                to use this flag, then simply add a "0" as value.
            </dd>
            <dd><code>conjB</code> - optional flag that conjugates the second input array before the
                multiplication (true) or not (false).
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#mulspectrums">org.opencv.core.Core.mulSpectrums</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="multiply(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>multiply</h4>
<pre>public static&nbsp;void&nbsp;multiply(<a href="../../../org/opencv/core/Mat.html"
                                              title="class in org.opencv.core">Mat</a>&nbsp;src1,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Calculates the per-element scaled product of two arrays.</p>

            <p>The function <code>multiply</code> calculates the per-element product of two
                arrays:</p>

            <p><em>dst(I)= saturate(scale * src1(I) * src2(I))</em></p>

            <p>There is also a "MatrixExpressions" -friendly variant of the first function.
                See "Mat.mul".</p>

            <p>For a not-per-element matrix product, see "gemm".</p>

            <p>Note: Saturation is not applied when the output array has the depth
                <code>CV_32S</code>. You may even get result of an incorrect sign in the case
                of overflow.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array.</dd>
            <dd><code>src2</code> - second input array of the same size and the same type as
                <code>src1</code>.
            </dd>
            <dd><code>dst</code> - output array of the same size and type as <code>src1</code>.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#multiply">org.opencv.core.Core.multiply</a>,
                <a href="../../../org/opencv/core/Core.html#divide(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, int)"><code>divide(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, double, int)</code></a>,
                <a href="../../../org/opencv/core/Mat.html#convertTo(org.opencv.core.Mat, int, double, double)"><code>Mat.convertTo(org.opencv.core.Mat,
                    int, double, double)</code></a>,
                <a href="../../../org/opencv/core/Core.html#addWeighted(org.opencv.core.Mat, double, org.opencv.core.Mat, double, double, org.opencv.core.Mat, int)"><code>addWeighted(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, double, double, org.opencv.core.Mat,
                    int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#add(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>add(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulateSquare(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Imgproc.accumulateSquare(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulate(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Imgproc.accumulate(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#scaleAdd(org.opencv.core.Mat, double, org.opencv.core.Mat, org.opencv.core.Mat)"><code>scaleAdd(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#subtract(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>subtract(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulateProduct(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Imgproc.accumulateProduct(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="multiply(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>multiply</h4>
<pre>public static&nbsp;void&nbsp;multiply(<a href="../../../org/opencv/core/Mat.html"
                                              title="class in org.opencv.core">Mat</a>&nbsp;src1,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
            double&nbsp;scale)</pre>
        <div class="block"><p>Calculates the per-element scaled product of two arrays.</p>

            <p>The function <code>multiply</code> calculates the per-element product of two
                arrays:</p>

            <p><em>dst(I)= saturate(scale * src1(I) * src2(I))</em></p>

            <p>There is also a "MatrixExpressions" -friendly variant of the first function.
                See "Mat.mul".</p>

            <p>For a not-per-element matrix product, see "gemm".</p>

            <p>Note: Saturation is not applied when the output array has the depth
                <code>CV_32S</code>. You may even get result of an incorrect sign in the case
                of overflow.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array.</dd>
            <dd><code>src2</code> - second input array of the same size and the same type as
                <code>src1</code>.
            </dd>
            <dd><code>dst</code> - output array of the same size and type as <code>src1</code>.</dd>
            <dd><code>scale</code> - optional scale factor.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#multiply">org.opencv.core.Core.multiply</a>,
                <a href="../../../org/opencv/core/Core.html#divide(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, int)"><code>divide(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, double, int)</code></a>,
                <a href="../../../org/opencv/core/Mat.html#convertTo(org.opencv.core.Mat, int, double, double)"><code>Mat.convertTo(org.opencv.core.Mat,
                    int, double, double)</code></a>,
                <a href="../../../org/opencv/core/Core.html#addWeighted(org.opencv.core.Mat, double, org.opencv.core.Mat, double, double, org.opencv.core.Mat, int)"><code>addWeighted(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, double, double, org.opencv.core.Mat,
                    int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#add(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>add(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulateSquare(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Imgproc.accumulateSquare(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulate(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Imgproc.accumulate(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#scaleAdd(org.opencv.core.Mat, double, org.opencv.core.Mat, org.opencv.core.Mat)"><code>scaleAdd(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#subtract(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>subtract(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulateProduct(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Imgproc.accumulateProduct(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="multiply(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>multiply</h4>
<pre>public static&nbsp;void&nbsp;multiply(<a href="../../../org/opencv/core/Mat.html"
                                              title="class in org.opencv.core">Mat</a>&nbsp;src1,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
            double&nbsp;scale,
            int&nbsp;dtype)</pre>
        <div class="block"><p>Calculates the per-element scaled product of two arrays.</p>

            <p>The function <code>multiply</code> calculates the per-element product of two
                arrays:</p>

            <p><em>dst(I)= saturate(scale * src1(I) * src2(I))</em></p>

            <p>There is also a "MatrixExpressions" -friendly variant of the first function.
                See "Mat.mul".</p>

            <p>For a not-per-element matrix product, see "gemm".</p>

            <p>Note: Saturation is not applied when the output array has the depth
                <code>CV_32S</code>. You may even get result of an incorrect sign in the case
                of overflow.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array.</dd>
            <dd><code>src2</code> - second input array of the same size and the same type as
                <code>src1</code>.
            </dd>
            <dd><code>dst</code> - output array of the same size and type as <code>src1</code>.</dd>
            <dd><code>scale</code> - optional scale factor.</dd>
            <dd><code>dtype</code> - a dtype</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#multiply">org.opencv.core.Core.multiply</a>,
                <a href="../../../org/opencv/core/Core.html#divide(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, int)"><code>divide(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, double, int)</code></a>,
                <a href="../../../org/opencv/core/Mat.html#convertTo(org.opencv.core.Mat, int, double, double)"><code>Mat.convertTo(org.opencv.core.Mat,
                    int, double, double)</code></a>,
                <a href="../../../org/opencv/core/Core.html#addWeighted(org.opencv.core.Mat, double, org.opencv.core.Mat, double, double, org.opencv.core.Mat, int)"><code>addWeighted(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, double, double, org.opencv.core.Mat,
                    int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#add(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>add(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulateSquare(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Imgproc.accumulateSquare(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulate(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Imgproc.accumulate(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#scaleAdd(org.opencv.core.Mat, double, org.opencv.core.Mat, org.opencv.core.Mat)"><code>scaleAdd(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#subtract(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>subtract(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulateProduct(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Imgproc.accumulateProduct(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="multiply(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>multiply</h4>
<pre>public static&nbsp;void&nbsp;multiply(<a href="../../../org/opencv/core/Mat.html"
                                              title="class in org.opencv.core">Mat</a>&nbsp;src1,
            <a href="../../../org/opencv/core/Scalar.html"
               title="class in org.opencv.core">Scalar</a>&nbsp;src2,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Calculates the per-element scaled product of two arrays.</p>

            <p>The function <code>multiply</code> calculates the per-element product of two
                arrays:</p>

            <p><em>dst(I)= saturate(scale * src1(I) * src2(I))</em></p>

            <p>There is also a "MatrixExpressions" -friendly variant of the first function.
                See "Mat.mul".</p>

            <p>For a not-per-element matrix product, see "gemm".</p>

            <p>Note: Saturation is not applied when the output array has the depth
                <code>CV_32S</code>. You may even get result of an incorrect sign in the case
                of overflow.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array.</dd>
            <dd><code>src2</code> - second input array of the same size and the same type as
                <code>src1</code>.
            </dd>
            <dd><code>dst</code> - output array of the same size and type as <code>src1</code>.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#multiply">org.opencv.core.Core.multiply</a>,
                <a href="../../../org/opencv/core/Core.html#divide(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, int)"><code>divide(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, double, int)</code></a>,
                <a href="../../../org/opencv/core/Mat.html#convertTo(org.opencv.core.Mat, int, double, double)"><code>Mat.convertTo(org.opencv.core.Mat,
                    int, double, double)</code></a>,
                <a href="../../../org/opencv/core/Core.html#addWeighted(org.opencv.core.Mat, double, org.opencv.core.Mat, double, double, org.opencv.core.Mat, int)"><code>addWeighted(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, double, double, org.opencv.core.Mat,
                    int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#add(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>add(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulateSquare(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Imgproc.accumulateSquare(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulate(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Imgproc.accumulate(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#scaleAdd(org.opencv.core.Mat, double, org.opencv.core.Mat, org.opencv.core.Mat)"><code>scaleAdd(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#subtract(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>subtract(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulateProduct(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Imgproc.accumulateProduct(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="multiply(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Mat, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>multiply</h4>
<pre>public static&nbsp;void&nbsp;multiply(<a href="../../../org/opencv/core/Mat.html"
                                              title="class in org.opencv.core">Mat</a>&nbsp;src1,
            <a href="../../../org/opencv/core/Scalar.html"
               title="class in org.opencv.core">Scalar</a>&nbsp;src2,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
            double&nbsp;scale)</pre>
        <div class="block"><p>Calculates the per-element scaled product of two arrays.</p>

            <p>The function <code>multiply</code> calculates the per-element product of two
                arrays:</p>

            <p><em>dst(I)= saturate(scale * src1(I) * src2(I))</em></p>

            <p>There is also a "MatrixExpressions" -friendly variant of the first function.
                See "Mat.mul".</p>

            <p>For a not-per-element matrix product, see "gemm".</p>

            <p>Note: Saturation is not applied when the output array has the depth
                <code>CV_32S</code>. You may even get result of an incorrect sign in the case
                of overflow.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array.</dd>
            <dd><code>src2</code> - second input array of the same size and the same type as
                <code>src1</code>.
            </dd>
            <dd><code>dst</code> - output array of the same size and type as <code>src1</code>.</dd>
            <dd><code>scale</code> - optional scale factor.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#multiply">org.opencv.core.Core.multiply</a>,
                <a href="../../../org/opencv/core/Core.html#divide(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, int)"><code>divide(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, double, int)</code></a>,
                <a href="../../../org/opencv/core/Mat.html#convertTo(org.opencv.core.Mat, int, double, double)"><code>Mat.convertTo(org.opencv.core.Mat,
                    int, double, double)</code></a>,
                <a href="../../../org/opencv/core/Core.html#addWeighted(org.opencv.core.Mat, double, org.opencv.core.Mat, double, double, org.opencv.core.Mat, int)"><code>addWeighted(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, double, double, org.opencv.core.Mat,
                    int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#add(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>add(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulateSquare(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Imgproc.accumulateSquare(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulate(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Imgproc.accumulate(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#scaleAdd(org.opencv.core.Mat, double, org.opencv.core.Mat, org.opencv.core.Mat)"><code>scaleAdd(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#subtract(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>subtract(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulateProduct(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Imgproc.accumulateProduct(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="multiply(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Mat, double, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>multiply</h4>
<pre>public static&nbsp;void&nbsp;multiply(<a href="../../../org/opencv/core/Mat.html"
                                              title="class in org.opencv.core">Mat</a>&nbsp;src1,
            <a href="../../../org/opencv/core/Scalar.html"
               title="class in org.opencv.core">Scalar</a>&nbsp;src2,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
            double&nbsp;scale,
            int&nbsp;dtype)</pre>
        <div class="block"><p>Calculates the per-element scaled product of two arrays.</p>

            <p>The function <code>multiply</code> calculates the per-element product of two
                arrays:</p>

            <p><em>dst(I)= saturate(scale * src1(I) * src2(I))</em></p>

            <p>There is also a "MatrixExpressions" -friendly variant of the first function.
                See "Mat.mul".</p>

            <p>For a not-per-element matrix product, see "gemm".</p>

            <p>Note: Saturation is not applied when the output array has the depth
                <code>CV_32S</code>. You may even get result of an incorrect sign in the case
                of overflow.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array.</dd>
            <dd><code>src2</code> - second input array of the same size and the same type as
                <code>src1</code>.
            </dd>
            <dd><code>dst</code> - output array of the same size and type as <code>src1</code>.</dd>
            <dd><code>scale</code> - optional scale factor.</dd>
            <dd><code>dtype</code> - a dtype</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#multiply">org.opencv.core.Core.multiply</a>,
                <a href="../../../org/opencv/core/Core.html#divide(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, int)"><code>divide(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, double, int)</code></a>,
                <a href="../../../org/opencv/core/Mat.html#convertTo(org.opencv.core.Mat, int, double, double)"><code>Mat.convertTo(org.opencv.core.Mat,
                    int, double, double)</code></a>,
                <a href="../../../org/opencv/core/Core.html#addWeighted(org.opencv.core.Mat, double, org.opencv.core.Mat, double, double, org.opencv.core.Mat, int)"><code>addWeighted(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, double, double, org.opencv.core.Mat,
                    int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#add(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>add(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulateSquare(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Imgproc.accumulateSquare(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulate(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Imgproc.accumulate(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#scaleAdd(org.opencv.core.Mat, double, org.opencv.core.Mat, org.opencv.core.Mat)"><code>scaleAdd(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#subtract(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>subtract(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulateProduct(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Imgproc.accumulateProduct(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="mulTransposed(org.opencv.core.Mat, org.opencv.core.Mat, boolean)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>mulTransposed</h4>
<pre>public static&nbsp;void&nbsp;mulTransposed(<a href="../../../org/opencv/core/Mat.html"
                                                   title="class in org.opencv.core">Mat</a>&nbsp;src,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;dst,
                 boolean&nbsp;aTa)</pre>
        <div class="block"><p>Calculates the product of a matrix and its transposition.</p>

            <p>The function <code>mulTransposed</code> calculates the product of
                <code>src</code> and its transposition:</p>

            <p><em>dst = scale(src - delta)^T(src - delta)</em></p>

            <p>if <code>aTa=true</code>, and</p>

            <p><em>dst = scale(src - delta)(src - delta)^T</em></p>

            <p>otherwise. The function is used to calculate the covariance matrix. With zero
                delta, it can be used as a faster substitute for general matrix product
                <code>A*B</code> when <code>B=A'</code></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input single-channel matrix. Note that unlike "gemm", the
                function
                can multiply not only floating-point matrices.
            </dd>
            <dd><code>dst</code> - output square matrix.</dd>
            <dd><code>aTa</code> - Flag specifying the multiplication ordering. See the description
                below.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#multransposed">org.opencv.core.Core.mulTransposed</a>,
                <a href="../../../org/opencv/core/Core.html#calcCovarMatrix(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int)"><code>calcCovarMatrix(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, int, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#repeat(org.opencv.core.Mat, int, int, org.opencv.core.Mat)"><code>repeat(org.opencv.core.Mat,
                    int, int, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#reduce(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int)"><code>reduce(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#gemm(org.opencv.core.Mat, org.opencv.core.Mat, double, org.opencv.core.Mat, double, org.opencv.core.Mat, int)"><code>gemm(org.opencv.core.Mat,
                    org.opencv.core.Mat, double, org.opencv.core.Mat, double, org.opencv.core.Mat,
                    int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="mulTransposed(org.opencv.core.Mat, org.opencv.core.Mat, boolean, org.opencv.core.Mat, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>mulTransposed</h4>
<pre>public static&nbsp;void&nbsp;mulTransposed(<a href="../../../org/opencv/core/Mat.html"
                                                   title="class in org.opencv.core">Mat</a>&nbsp;src,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;dst,
                 boolean&nbsp;aTa,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;delta,
                 double&nbsp;scale)</pre>
        <div class="block"><p>Calculates the product of a matrix and its transposition.</p>

            <p>The function <code>mulTransposed</code> calculates the product of
                <code>src</code> and its transposition:</p>

            <p><em>dst = scale(src - delta)^T(src - delta)</em></p>

            <p>if <code>aTa=true</code>, and</p>

            <p><em>dst = scale(src - delta)(src - delta)^T</em></p>

            <p>otherwise. The function is used to calculate the covariance matrix. With zero
                delta, it can be used as a faster substitute for general matrix product
                <code>A*B</code> when <code>B=A'</code></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input single-channel matrix. Note that unlike "gemm", the
                function
                can multiply not only floating-point matrices.
            </dd>
            <dd><code>dst</code> - output square matrix.</dd>
            <dd><code>aTa</code> - Flag specifying the multiplication ordering. See the description
                below.
            </dd>
            <dd><code>delta</code> - Optional delta matrix subtracted from <code>src</code> before
                the multiplication. When the matrix is empty (<code>delta=noArray()</code>),
                it is assumed to be zero, that is, nothing is subtracted. If it has the same
                size as <code>src</code>, it is simply subtracted. Otherwise, it is
                "repeated" (see "repeat") to cover the full <code>src</code> and then
                subtracted. Type of the delta matrix, when it is not empty, must be the same
                as the type of created output matrix. See the <code>dtype</code> parameter
                description below.
            </dd>
            <dd><code>scale</code> - Optional scale factor for the matrix product.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#multransposed">org.opencv.core.Core.mulTransposed</a>,
                <a href="../../../org/opencv/core/Core.html#calcCovarMatrix(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int)"><code>calcCovarMatrix(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, int, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#repeat(org.opencv.core.Mat, int, int, org.opencv.core.Mat)"><code>repeat(org.opencv.core.Mat,
                    int, int, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#reduce(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int)"><code>reduce(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#gemm(org.opencv.core.Mat, org.opencv.core.Mat, double, org.opencv.core.Mat, double, org.opencv.core.Mat, int)"><code>gemm(org.opencv.core.Mat,
                    org.opencv.core.Mat, double, org.opencv.core.Mat, double, org.opencv.core.Mat,
                    int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="mulTransposed(org.opencv.core.Mat, org.opencv.core.Mat, boolean, org.opencv.core.Mat, double, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>mulTransposed</h4>
<pre>public static&nbsp;void&nbsp;mulTransposed(<a href="../../../org/opencv/core/Mat.html"
                                                   title="class in org.opencv.core">Mat</a>&nbsp;src,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;dst,
                 boolean&nbsp;aTa,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;delta,
                 double&nbsp;scale,
                 int&nbsp;dtype)</pre>
        <div class="block"><p>Calculates the product of a matrix and its transposition.</p>

            <p>The function <code>mulTransposed</code> calculates the product of
                <code>src</code> and its transposition:</p>

            <p><em>dst = scale(src - delta)^T(src - delta)</em></p>

            <p>if <code>aTa=true</code>, and</p>

            <p><em>dst = scale(src - delta)(src - delta)^T</em></p>

            <p>otherwise. The function is used to calculate the covariance matrix. With zero
                delta, it can be used as a faster substitute for general matrix product
                <code>A*B</code> when <code>B=A'</code></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input single-channel matrix. Note that unlike "gemm", the
                function
                can multiply not only floating-point matrices.
            </dd>
            <dd><code>dst</code> - output square matrix.</dd>
            <dd><code>aTa</code> - Flag specifying the multiplication ordering. See the description
                below.
            </dd>
            <dd><code>delta</code> - Optional delta matrix subtracted from <code>src</code> before
                the multiplication. When the matrix is empty (<code>delta=noArray()</code>),
                it is assumed to be zero, that is, nothing is subtracted. If it has the same
                size as <code>src</code>, it is simply subtracted. Otherwise, it is
                "repeated" (see "repeat") to cover the full <code>src</code> and then
                subtracted. Type of the delta matrix, when it is not empty, must be the same
                as the type of created output matrix. See the <code>dtype</code> parameter
                description below.
            </dd>
            <dd><code>scale</code> - Optional scale factor for the matrix product.</dd>
            <dd><code>dtype</code> - Optional type of the output matrix. When it is negative, the
                output matrix will have the same type as <code>src</code>. Otherwise, it will
                be <code>type=CV_MAT_DEPTH(dtype)</code> that should be either
                <code>CV_32F</code> or <code>CV_64F</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#multransposed">org.opencv.core.Core.mulTransposed</a>,
                <a href="../../../org/opencv/core/Core.html#calcCovarMatrix(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int)"><code>calcCovarMatrix(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, int, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#repeat(org.opencv.core.Mat, int, int, org.opencv.core.Mat)"><code>repeat(org.opencv.core.Mat,
                    int, int, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#reduce(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int)"><code>reduce(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#gemm(org.opencv.core.Mat, org.opencv.core.Mat, double, org.opencv.core.Mat, double, org.opencv.core.Mat, int)"><code>gemm(org.opencv.core.Mat,
                    org.opencv.core.Mat, double, org.opencv.core.Mat, double, org.opencv.core.Mat,
                    int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="norm(org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>norm</h4>
        <pre>public static&nbsp;double&nbsp;norm(<a href="../../../org/opencv/core/Mat.html"
                                                    title="class in org.opencv.core">Mat</a>&nbsp;src1)</pre>
        <div class="block"><p>Calculates an absolute array norm, an absolute difference norm, or a
            relative
            difference norm.</p>

            <p>The functions <code>norm</code> calculate an absolute norm of
                <code>src1</code> (when there is no <code>src2</code>):</p>

            <p><em>norm = forkthree(|src1|_(L_(infty)) = max _I|src1(I)|)(if normType =
                NORM_INF)&ltBR&gt(|src1|_(L_1) = sum _I|src1(I)|)(if normType =
                NORM_L1)&ltBR&gt(|src1|_(L_2) = sqrt(sum_I src1(I)^2))(if normType =
                NORM_L2)</em></p>

            <p>or an absolute or relative difference norm if <code>src2</code> is there:</p>

            <p><em>norm = forkthree(|src1-src2|_(L_(infty)) = max _I|src1(I) - src2(I)|)(if
                normType = NORM_INF)&ltBR&gt(|src1 - src2|_(L_1) = sum _I|src1(I) -
                src2(I)|)(if normType = NORM_L1)&ltBR&gt(|src1 - src2|_(L_2) =
                sqrt(sum_I(src1(I) - src2(I))^2))(if normType = NORM_L2)</em></p>

            <p>or</p>

            <p><em>norm = forkthree((|src1-src2|_(L_(infty)))/(|src2|_(L_(infty))))(if
                normType = NORM_RELATIVE_INF)&ltBR&gt((|src1-src2|_(L_1))/(|src2|_(L_1)))(if
                normType = NORM_RELATIVE_L1)&ltBR&gt((|src1-src2|_(L_2))/(|src2|_(L_2)))(if
                normType = NORM_RELATIVE_L2)</em></p>

            <p>The functions <code>norm</code> return the calculated norm.</p>

            <p>When the <code>mask</code> parameter is specified and it is not empty, the
                norm is calculated only over the region specified by the mask.</p>

            <p>A multi-channel input arrays are treated as a single-channel, that is, the
                results for all channels are combined.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#norm">org.opencv.core.Core.norm</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="norm(org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>norm</h4>
<pre>public static&nbsp;double&nbsp;norm(<a href="../../../org/opencv/core/Mat.html"
                                            title="class in org.opencv.core">Mat</a>&nbsp;src1,
          int&nbsp;normType)</pre>
        <div class="block"><p>Calculates an absolute array norm, an absolute difference norm, or a
            relative
            difference norm.</p>

            <p>The functions <code>norm</code> calculate an absolute norm of
                <code>src1</code> (when there is no <code>src2</code>):</p>

            <p><em>norm = forkthree(|src1|_(L_(infty)) = max _I|src1(I)|)(if normType =
                NORM_INF)&ltBR&gt(|src1|_(L_1) = sum _I|src1(I)|)(if normType =
                NORM_L1)&ltBR&gt(|src1|_(L_2) = sqrt(sum_I src1(I)^2))(if normType =
                NORM_L2)</em></p>

            <p>or an absolute or relative difference norm if <code>src2</code> is there:</p>

            <p><em>norm = forkthree(|src1-src2|_(L_(infty)) = max _I|src1(I) - src2(I)|)(if
                normType = NORM_INF)&ltBR&gt(|src1 - src2|_(L_1) = sum _I|src1(I) -
                src2(I)|)(if normType = NORM_L1)&ltBR&gt(|src1 - src2|_(L_2) =
                sqrt(sum_I(src1(I) - src2(I))^2))(if normType = NORM_L2)</em></p>

            <p>or</p>

            <p><em>norm = forkthree((|src1-src2|_(L_(infty)))/(|src2|_(L_(infty))))(if
                normType = NORM_RELATIVE_INF)&ltBR&gt((|src1-src2|_(L_1))/(|src2|_(L_1)))(if
                normType = NORM_RELATIVE_L1)&ltBR&gt((|src1-src2|_(L_2))/(|src2|_(L_2)))(if
                normType = NORM_RELATIVE_L2)</em></p>

            <p>The functions <code>norm</code> return the calculated norm.</p>

            <p>When the <code>mask</code> parameter is specified and it is not empty, the
                norm is calculated only over the region specified by the mask.</p>

            <p>A multi-channel input arrays are treated as a single-channel, that is, the
                results for all channels are combined.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array.</dd>
            <dd><code>normType</code> - type of the norm (see the details below).</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#norm">org.opencv.core.Core.norm</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="norm(org.opencv.core.Mat, int, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>norm</h4>
<pre>public static&nbsp;double&nbsp;norm(<a href="../../../org/opencv/core/Mat.html"
                                            title="class in org.opencv.core">Mat</a>&nbsp;src1,
          int&nbsp;normType,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
        <div class="block"><p>Calculates an absolute array norm, an absolute difference norm, or a
            relative
            difference norm.</p>

            <p>The functions <code>norm</code> calculate an absolute norm of
                <code>src1</code> (when there is no <code>src2</code>):</p>

            <p><em>norm = forkthree(|src1|_(L_(infty)) = max _I|src1(I)|)(if normType =
                NORM_INF)&ltBR&gt(|src1|_(L_1) = sum _I|src1(I)|)(if normType =
                NORM_L1)&ltBR&gt(|src1|_(L_2) = sqrt(sum_I src1(I)^2))(if normType =
                NORM_L2)</em></p>

            <p>or an absolute or relative difference norm if <code>src2</code> is there:</p>

            <p><em>norm = forkthree(|src1-src2|_(L_(infty)) = max _I|src1(I) - src2(I)|)(if
                normType = NORM_INF)&ltBR&gt(|src1 - src2|_(L_1) = sum _I|src1(I) -
                src2(I)|)(if normType = NORM_L1)&ltBR&gt(|src1 - src2|_(L_2) =
                sqrt(sum_I(src1(I) - src2(I))^2))(if normType = NORM_L2)</em></p>

            <p>or</p>

            <p><em>norm = forkthree((|src1-src2|_(L_(infty)))/(|src2|_(L_(infty))))(if
                normType = NORM_RELATIVE_INF)&ltBR&gt((|src1-src2|_(L_1))/(|src2|_(L_1)))(if
                normType = NORM_RELATIVE_L1)&ltBR&gt((|src1-src2|_(L_2))/(|src2|_(L_2)))(if
                normType = NORM_RELATIVE_L2)</em></p>

            <p>The functions <code>norm</code> return the calculated norm.</p>

            <p>When the <code>mask</code> parameter is specified and it is not empty, the
                norm is calculated only over the region specified by the mask.</p>

            <p>A multi-channel input arrays are treated as a single-channel, that is, the
                results for all channels are combined.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array.</dd>
            <dd><code>normType</code> - type of the norm (see the details below).</dd>
            <dd><code>mask</code> - optional operation mask; it must have the same size as
                <code>src1</code> and <code>CV_8UC1</code> type.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#norm">org.opencv.core.Core.norm</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="norm(org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>norm</h4>
<pre>public static&nbsp;double&nbsp;norm(<a href="../../../org/opencv/core/Mat.html"
                                            title="class in org.opencv.core">Mat</a>&nbsp;src1,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2)</pre>
        <div class="block"><p>Calculates an absolute array norm, an absolute difference norm, or a
            relative
            difference norm.</p>

            <p>The functions <code>norm</code> calculate an absolute norm of
                <code>src1</code> (when there is no <code>src2</code>):</p>

            <p><em>norm = forkthree(|src1|_(L_(infty)) = max _I|src1(I)|)(if normType =
                NORM_INF)&ltBR&gt(|src1|_(L_1) = sum _I|src1(I)|)(if normType =
                NORM_L1)&ltBR&gt(|src1|_(L_2) = sqrt(sum_I src1(I)^2))(if normType =
                NORM_L2)</em></p>

            <p>or an absolute or relative difference norm if <code>src2</code> is there:</p>

            <p><em>norm = forkthree(|src1-src2|_(L_(infty)) = max _I|src1(I) - src2(I)|)(if
                normType = NORM_INF)&ltBR&gt(|src1 - src2|_(L_1) = sum _I|src1(I) -
                src2(I)|)(if normType = NORM_L1)&ltBR&gt(|src1 - src2|_(L_2) =
                sqrt(sum_I(src1(I) - src2(I))^2))(if normType = NORM_L2)</em></p>

            <p>or</p>

            <p><em>norm = forkthree((|src1-src2|_(L_(infty)))/(|src2|_(L_(infty))))(if
                normType = NORM_RELATIVE_INF)&ltBR&gt((|src1-src2|_(L_1))/(|src2|_(L_1)))(if
                normType = NORM_RELATIVE_L1)&ltBR&gt((|src1-src2|_(L_2))/(|src2|_(L_2)))(if
                normType = NORM_RELATIVE_L2)</em></p>

            <p>The functions <code>norm</code> return the calculated norm.</p>

            <p>When the <code>mask</code> parameter is specified and it is not empty, the
                norm is calculated only over the region specified by the mask.</p>

            <p>A multi-channel input arrays are treated as a single-channel, that is, the
                results for all channels are combined.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array.</dd>
            <dd><code>src2</code> - second input array of the same size and the same type as
                <code>src1</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#norm">org.opencv.core.Core.norm</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="norm(org.opencv.core.Mat, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>norm</h4>
<pre>public static&nbsp;double&nbsp;norm(<a href="../../../org/opencv/core/Mat.html"
                                            title="class in org.opencv.core">Mat</a>&nbsp;src1,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
          int&nbsp;normType)</pre>
        <div class="block"><p>Calculates an absolute array norm, an absolute difference norm, or a
            relative
            difference norm.</p>

            <p>The functions <code>norm</code> calculate an absolute norm of
                <code>src1</code> (when there is no <code>src2</code>):</p>

            <p><em>norm = forkthree(|src1|_(L_(infty)) = max _I|src1(I)|)(if normType =
                NORM_INF)&ltBR&gt(|src1|_(L_1) = sum _I|src1(I)|)(if normType =
                NORM_L1)&ltBR&gt(|src1|_(L_2) = sqrt(sum_I src1(I)^2))(if normType =
                NORM_L2)</em></p>

            <p>or an absolute or relative difference norm if <code>src2</code> is there:</p>

            <p><em>norm = forkthree(|src1-src2|_(L_(infty)) = max _I|src1(I) - src2(I)|)(if
                normType = NORM_INF)&ltBR&gt(|src1 - src2|_(L_1) = sum _I|src1(I) -
                src2(I)|)(if normType = NORM_L1)&ltBR&gt(|src1 - src2|_(L_2) =
                sqrt(sum_I(src1(I) - src2(I))^2))(if normType = NORM_L2)</em></p>

            <p>or</p>

            <p><em>norm = forkthree((|src1-src2|_(L_(infty)))/(|src2|_(L_(infty))))(if
                normType = NORM_RELATIVE_INF)&ltBR&gt((|src1-src2|_(L_1))/(|src2|_(L_1)))(if
                normType = NORM_RELATIVE_L1)&ltBR&gt((|src1-src2|_(L_2))/(|src2|_(L_2)))(if
                normType = NORM_RELATIVE_L2)</em></p>

            <p>The functions <code>norm</code> return the calculated norm.</p>

            <p>When the <code>mask</code> parameter is specified and it is not empty, the
                norm is calculated only over the region specified by the mask.</p>

            <p>A multi-channel input arrays are treated as a single-channel, that is, the
                results for all channels are combined.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array.</dd>
            <dd><code>src2</code> - second input array of the same size and the same type as
                <code>src1</code>.
            </dd>
            <dd><code>normType</code> - type of the norm (see the details below).</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#norm">org.opencv.core.Core.norm</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="norm(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>norm</h4>
<pre>public static&nbsp;double&nbsp;norm(<a href="../../../org/opencv/core/Mat.html"
                                            title="class in org.opencv.core">Mat</a>&nbsp;src1,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
          int&nbsp;normType,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
        <div class="block"><p>Calculates an absolute array norm, an absolute difference norm, or a
            relative
            difference norm.</p>

            <p>The functions <code>norm</code> calculate an absolute norm of
                <code>src1</code> (when there is no <code>src2</code>):</p>

            <p><em>norm = forkthree(|src1|_(L_(infty)) = max _I|src1(I)|)(if normType =
                NORM_INF)&ltBR&gt(|src1|_(L_1) = sum _I|src1(I)|)(if normType =
                NORM_L1)&ltBR&gt(|src1|_(L_2) = sqrt(sum_I src1(I)^2))(if normType =
                NORM_L2)</em></p>

            <p>or an absolute or relative difference norm if <code>src2</code> is there:</p>

            <p><em>norm = forkthree(|src1-src2|_(L_(infty)) = max _I|src1(I) - src2(I)|)(if
                normType = NORM_INF)&ltBR&gt(|src1 - src2|_(L_1) = sum _I|src1(I) -
                src2(I)|)(if normType = NORM_L1)&ltBR&gt(|src1 - src2|_(L_2) =
                sqrt(sum_I(src1(I) - src2(I))^2))(if normType = NORM_L2)</em></p>

            <p>or</p>

            <p><em>norm = forkthree((|src1-src2|_(L_(infty)))/(|src2|_(L_(infty))))(if
                normType = NORM_RELATIVE_INF)&ltBR&gt((|src1-src2|_(L_1))/(|src2|_(L_1)))(if
                normType = NORM_RELATIVE_L1)&ltBR&gt((|src1-src2|_(L_2))/(|src2|_(L_2)))(if
                normType = NORM_RELATIVE_L2)</em></p>

            <p>The functions <code>norm</code> return the calculated norm.</p>

            <p>When the <code>mask</code> parameter is specified and it is not empty, the
                norm is calculated only over the region specified by the mask.</p>

            <p>A multi-channel input arrays are treated as a single-channel, that is, the
                results for all channels are combined.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array.</dd>
            <dd><code>src2</code> - second input array of the same size and the same type as
                <code>src1</code>.
            </dd>
            <dd><code>normType</code> - type of the norm (see the details below).</dd>
            <dd><code>mask</code> - optional operation mask; it must have the same size as
                <code>src1</code> and <code>CV_8UC1</code> type.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#norm">org.opencv.core.Core.norm</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="normalize(org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>normalize</h4>
<pre>public static&nbsp;void&nbsp;normalize(<a href="../../../org/opencv/core/Mat.html"
                                               title="class in org.opencv.core">Mat</a>&nbsp;src,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Normalizes the norm or value range of an array.</p>

            <p>The functions <code>normalize</code> scale and shift the input array elements
                so that</p>

            <p><em>| dst|_(L_p)= alpha</em></p>

            <p>(where p=Inf, 1 or 2) when <code>normType=NORM_INF</code>, <code>NORM_L1</code>,
                or <code>NORM_L2</code>, respectively; or so that</p>

            <p><em>min _I dst(I)= alpha, max _I dst(I)= beta</em></p>

            <p>when <code>normType=NORM_MINMAX</code> (for dense arrays only).
                The optional mask specifies a sub-array to be normalized. This means that the
                norm or min-n-max are calculated over the sub-array, and then this sub-array
                is modified to be normalized. If you want to only use the mask to calculate
                the norm or min-max but modify the whole array, you can use "norm" and
                "Mat.convertTo".</p>

            <p>In case of sparse matrices, only the non-zero values are analyzed and
                transformed. Because of this, the range transformation for sparse matrices is
                not allowed since it can shift the zero level.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input array.</dd>
            <dd><code>dst</code> - output array of the same size as <code>src</code>.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#normalize">org.opencv.core.Core.normalize</a>,
                <a href="../../../org/opencv/core/Mat.html#convertTo(org.opencv.core.Mat, int, double, double)"><code>Mat.convertTo(org.opencv.core.Mat,
                    int, double, double)</code></a>,
                <a href="../../../org/opencv/core/Core.html#norm(org.opencv.core.Mat, int, org.opencv.core.Mat)"><code>norm(org.opencv.core.Mat,
                    int, org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="normalize(org.opencv.core.Mat, org.opencv.core.Mat, double, double, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>normalize</h4>
<pre>public static&nbsp;void&nbsp;normalize(<a href="../../../org/opencv/core/Mat.html"
                                               title="class in org.opencv.core">Mat</a>&nbsp;src,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
             double&nbsp;alpha,
             double&nbsp;beta,
             int&nbsp;norm_type)</pre>
        <div class="block"><p>Normalizes the norm or value range of an array.</p>

            <p>The functions <code>normalize</code> scale and shift the input array elements
                so that</p>

            <p><em>| dst|_(L_p)= alpha</em></p>

            <p>(where p=Inf, 1 or 2) when <code>normType=NORM_INF</code>, <code>NORM_L1</code>,
                or <code>NORM_L2</code>, respectively; or so that</p>

            <p><em>min _I dst(I)= alpha, max _I dst(I)= beta</em></p>

            <p>when <code>normType=NORM_MINMAX</code> (for dense arrays only).
                The optional mask specifies a sub-array to be normalized. This means that the
                norm or min-n-max are calculated over the sub-array, and then this sub-array
                is modified to be normalized. If you want to only use the mask to calculate
                the norm or min-max but modify the whole array, you can use "norm" and
                "Mat.convertTo".</p>

            <p>In case of sparse matrices, only the non-zero values are analyzed and
                transformed. Because of this, the range transformation for sparse matrices is
                not allowed since it can shift the zero level.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input array.</dd>
            <dd><code>dst</code> - output array of the same size as <code>src</code>.</dd>
            <dd><code>alpha</code> - norm value to normalize to or the lower range boundary in case
                of the range normalization.
            </dd>
            <dd><code>beta</code> - upper range boundary in case of the range normalization; it is
                not used for the norm normalization.
            </dd>
            <dd><code>norm_type</code> - a norm_type</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#normalize">org.opencv.core.Core.normalize</a>,
                <a href="../../../org/opencv/core/Mat.html#convertTo(org.opencv.core.Mat, int, double, double)"><code>Mat.convertTo(org.opencv.core.Mat,
                    int, double, double)</code></a>,
                <a href="../../../org/opencv/core/Core.html#norm(org.opencv.core.Mat, int, org.opencv.core.Mat)"><code>norm(org.opencv.core.Mat,
                    int, org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="normalize(org.opencv.core.Mat, org.opencv.core.Mat, double, double, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>normalize</h4>
<pre>public static&nbsp;void&nbsp;normalize(<a href="../../../org/opencv/core/Mat.html"
                                               title="class in org.opencv.core">Mat</a>&nbsp;src,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
             double&nbsp;alpha,
             double&nbsp;beta,
             int&nbsp;norm_type,
             int&nbsp;dtype)</pre>
        <div class="block"><p>Normalizes the norm or value range of an array.</p>

            <p>The functions <code>normalize</code> scale and shift the input array elements
                so that</p>

            <p><em>| dst|_(L_p)= alpha</em></p>

            <p>(where p=Inf, 1 or 2) when <code>normType=NORM_INF</code>, <code>NORM_L1</code>,
                or <code>NORM_L2</code>, respectively; or so that</p>

            <p><em>min _I dst(I)= alpha, max _I dst(I)= beta</em></p>

            <p>when <code>normType=NORM_MINMAX</code> (for dense arrays only).
                The optional mask specifies a sub-array to be normalized. This means that the
                norm or min-n-max are calculated over the sub-array, and then this sub-array
                is modified to be normalized. If you want to only use the mask to calculate
                the norm or min-max but modify the whole array, you can use "norm" and
                "Mat.convertTo".</p>

            <p>In case of sparse matrices, only the non-zero values are analyzed and
                transformed. Because of this, the range transformation for sparse matrices is
                not allowed since it can shift the zero level.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input array.</dd>
            <dd><code>dst</code> - output array of the same size as <code>src</code>.</dd>
            <dd><code>alpha</code> - norm value to normalize to or the lower range boundary in case
                of the range normalization.
            </dd>
            <dd><code>beta</code> - upper range boundary in case of the range normalization; it is
                not used for the norm normalization.
            </dd>
            <dd><code>norm_type</code> - a norm_type</dd>
            <dd><code>dtype</code> - when negative, the output array has the same type as
                <code>src</code>; otherwise, it has the same number of channels as
                <code>src</code> and the depth <code>=CV_MAT_DEPTH(dtype)</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#normalize">org.opencv.core.Core.normalize</a>,
                <a href="../../../org/opencv/core/Mat.html#convertTo(org.opencv.core.Mat, int, double, double)"><code>Mat.convertTo(org.opencv.core.Mat,
                    int, double, double)</code></a>,
                <a href="../../../org/opencv/core/Core.html#norm(org.opencv.core.Mat, int, org.opencv.core.Mat)"><code>norm(org.opencv.core.Mat,
                    int, org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="normalize(org.opencv.core.Mat, org.opencv.core.Mat, double, double, int, int, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>normalize</h4>
<pre>public static&nbsp;void&nbsp;normalize(<a href="../../../org/opencv/core/Mat.html"
                                               title="class in org.opencv.core">Mat</a>&nbsp;src,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
             double&nbsp;alpha,
             double&nbsp;beta,
             int&nbsp;norm_type,
             int&nbsp;dtype,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
        <div class="block"><p>Normalizes the norm or value range of an array.</p>

            <p>The functions <code>normalize</code> scale and shift the input array elements
                so that</p>

            <p><em>| dst|_(L_p)= alpha</em></p>

            <p>(where p=Inf, 1 or 2) when <code>normType=NORM_INF</code>, <code>NORM_L1</code>,
                or <code>NORM_L2</code>, respectively; or so that</p>

            <p><em>min _I dst(I)= alpha, max _I dst(I)= beta</em></p>

            <p>when <code>normType=NORM_MINMAX</code> (for dense arrays only).
                The optional mask specifies a sub-array to be normalized. This means that the
                norm or min-n-max are calculated over the sub-array, and then this sub-array
                is modified to be normalized. If you want to only use the mask to calculate
                the norm or min-max but modify the whole array, you can use "norm" and
                "Mat.convertTo".</p>

            <p>In case of sparse matrices, only the non-zero values are analyzed and
                transformed. Because of this, the range transformation for sparse matrices is
                not allowed since it can shift the zero level.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input array.</dd>
            <dd><code>dst</code> - output array of the same size as <code>src</code>.</dd>
            <dd><code>alpha</code> - norm value to normalize to or the lower range boundary in case
                of the range normalization.
            </dd>
            <dd><code>beta</code> - upper range boundary in case of the range normalization; it is
                not used for the norm normalization.
            </dd>
            <dd><code>norm_type</code> - a norm_type</dd>
            <dd><code>dtype</code> - when negative, the output array has the same type as
                <code>src</code>; otherwise, it has the same number of channels as
                <code>src</code> and the depth <code>=CV_MAT_DEPTH(dtype)</code>.
            </dd>
            <dd><code>mask</code> - optional operation mask.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#normalize">org.opencv.core.Core.normalize</a>,
                <a href="../../../org/opencv/core/Mat.html#convertTo(org.opencv.core.Mat, int, double, double)"><code>Mat.convertTo(org.opencv.core.Mat,
                    int, double, double)</code></a>,
                <a href="../../../org/opencv/core/Core.html#norm(org.opencv.core.Mat, int, org.opencv.core.Mat)"><code>norm(org.opencv.core.Mat,
                    int, org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="patchNaNs(org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>patchNaNs</h4>
        <pre>public static&nbsp;void&nbsp;patchNaNs(<a href="../../../org/opencv/core/Mat.html"
                                                       title="class in org.opencv.core">Mat</a>&nbsp;a)</pre>
    </li>
</ul>
<a name="patchNaNs(org.opencv.core.Mat, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>patchNaNs</h4>
<pre>public static&nbsp;void&nbsp;patchNaNs(<a href="../../../org/opencv/core/Mat.html"
                                               title="class in org.opencv.core">Mat</a>&nbsp;a,
             double&nbsp;val)</pre>
    </li>
</ul>
<a name="PCABackProject(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>PCABackProject</h4>
<pre>public static&nbsp;void&nbsp;PCABackProject(<a href="../../../org/opencv/core/Mat.html"
                                                    title="class in org.opencv.core">Mat</a>&nbsp;data,
                  <a href="../../../org/opencv/core/Mat.html"
                     title="class in org.opencv.core">Mat</a>&nbsp;mean,
                  <a href="../../../org/opencv/core/Mat.html"
                     title="class in org.opencv.core">Mat</a>&nbsp;eigenvectors,
                  <a href="../../../org/opencv/core/Mat.html"
                     title="class in org.opencv.core">Mat</a>&nbsp;result)</pre>
    </li>
</ul>
<a name="PCACompute(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>PCACompute</h4>
<pre>public static&nbsp;void&nbsp;PCACompute(<a href="../../../org/opencv/core/Mat.html"
                                                title="class in org.opencv.core">Mat</a>&nbsp;data,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mean,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvectors)</pre>
    </li>
</ul>
<a name="PCACompute(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>PCACompute</h4>
<pre>public static&nbsp;void&nbsp;PCACompute(<a href="../../../org/opencv/core/Mat.html"
                                                title="class in org.opencv.core">Mat</a>&nbsp;data,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mean,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvectors,
              int&nbsp;maxComponents)</pre>
    </li>
</ul>
<a name="PCAComputeVar(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>PCAComputeVar</h4>
<pre>public static&nbsp;void&nbsp;PCAComputeVar(<a href="../../../org/opencv/core/Mat.html"
                                                   title="class in org.opencv.core">Mat</a>&nbsp;data,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;mean,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;eigenvectors,
                 double&nbsp;retainedVariance)</pre>
    </li>
</ul>
<a name="PCAProject(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>PCAProject</h4>
<pre>public static&nbsp;void&nbsp;PCAProject(<a href="../../../org/opencv/core/Mat.html"
                                                title="class in org.opencv.core">Mat</a>&nbsp;data,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mean,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvectors,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;result)</pre>
    </li>
</ul>
<a name="perspectiveTransform(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>perspectiveTransform</h4>
<pre>public static&nbsp;void&nbsp;perspectiveTransform(<a href="../../../org/opencv/core/Mat.html"
                                                          title="class in org.opencv.core">Mat</a>&nbsp;src,
                        <a href="../../../org/opencv/core/Mat.html"
                           title="class in org.opencv.core">Mat</a>&nbsp;dst,
                        <a href="../../../org/opencv/core/Mat.html"
                           title="class in org.opencv.core">Mat</a>&nbsp;m)</pre>
        <div class="block"><p>Performs the perspective matrix transformation of vectors.</p>

            <p>The function <code>perspectiveTransform</code> transforms every element of
                <code>src</code> by treating it as a 2D or 3D vector, in the following way:</p>

            <p><em>(x, y, z) -> (x'/w, y'/w, z'/w)</em></p>

            <p>where</p>

            <p><em>(x', y', z', w') = mat * x y z 1 </em></p>

            <p>and</p>

            <p><em>w = w' if w' != 0; infty otherwise</em></p>

            <p>Here a 3D vector transformation is shown. In case of a 2D vector
                transformation, the <code>z</code> component is omitted.</p>

            <p>Note: The function transforms a sparse set of 2D or 3D vectors. If you want
                to transform an image using perspective transformation, use "warpPerspective".
                If you have an inverse problem, that is, you want to compute the most
                probable perspective transformation out of several pairs of corresponding
                points, you can use "getPerspectiveTransform" or "findHomography".</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input two-channel or three-channel floating-point array; each
                element is a 2D/3D vector to be transformed.
            </dd>
            <dd><code>dst</code> - output array of the same size and type as <code>src</code>.</dd>
            <dd><code>m</code> - <code>3x3</code> or <code>4x4</code> floating-point transformation
                matrix.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#perspectivetransform">org.opencv.core.Core.perspectiveTransform</a>,
                <a href="../../../org/opencv/calib3d/Calib3d.html#findHomography(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, int, double, org.opencv.core.Mat)"><code>Calib3d.findHomography(org.opencv.core.MatOfPoint2f,
                    org.opencv.core.MatOfPoint2f, int, double, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#warpPerspective(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int, org.opencv.core.Scalar)"><code>Imgproc.warpPerspective(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/core/Core.html#transform(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>transform(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#getPerspectiveTransform(org.opencv.core.Mat, org.opencv.core.Mat)"><code>Imgproc.getPerspectiveTransform(org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="phase(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>phase</h4>
<pre>public static&nbsp;void&nbsp;phase(<a href="../../../org/opencv/core/Mat.html"
                                           title="class in org.opencv.core">Mat</a>&nbsp;x,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;y,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;angle)</pre>
        <div class="block"><p>Calculates the rotation angle of 2D vectors.</p>

            <p>The function <code>phase</code> calculates the rotation angle of each 2D
                vector that is formed from the corresponding elements of <code>x</code> and
                <code>y</code> :</p>

            <p><em>angle(I) = atan2(y(I), x(I))</em></p>

            <p>The angle estimation accuracy is about 0.3 degrees. When <code>x(I)=y(I)=0</code>,
                the corresponding <code>angle(I)</code> is set to 0.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>x</code> - input floating-point array of x-coordinates of 2D vectors.</dd>
            <dd><code>y</code> - input array of y-coordinates of 2D vectors; it must have the same
                size and the same type as <code>x</code>.
            </dd>
            <dd><code>angle</code> - output array of vector angles; it has the same size and same
                type as <code>x</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#phase">org.opencv.core.Core.phase</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="phase(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>phase</h4>
<pre>public static&nbsp;void&nbsp;phase(<a href="../../../org/opencv/core/Mat.html"
                                           title="class in org.opencv.core">Mat</a>&nbsp;x,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;y,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;angle,
         boolean&nbsp;angleInDegrees)</pre>
        <div class="block"><p>Calculates the rotation angle of 2D vectors.</p>

            <p>The function <code>phase</code> calculates the rotation angle of each 2D
                vector that is formed from the corresponding elements of <code>x</code> and
                <code>y</code> :</p>

            <p><em>angle(I) = atan2(y(I), x(I))</em></p>

            <p>The angle estimation accuracy is about 0.3 degrees. When <code>x(I)=y(I)=0</code>,
                the corresponding <code>angle(I)</code> is set to 0.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>x</code> - input floating-point array of x-coordinates of 2D vectors.</dd>
            <dd><code>y</code> - input array of y-coordinates of 2D vectors; it must have the same
                size and the same type as <code>x</code>.
            </dd>
            <dd><code>angle</code> - output array of vector angles; it has the same size and same
                type as <code>x</code>.
            </dd>
            <dd><code>angleInDegrees</code> - when true, the function calculates the angle in
                degrees, otherwise, they are measured in radians.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#phase">org.opencv.core.Core.phase</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="polarToCart(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>polarToCart</h4>
<pre>public static&nbsp;void&nbsp;polarToCart(<a href="../../../org/opencv/core/Mat.html"
                                                 title="class in org.opencv.core">Mat</a>&nbsp;magnitude,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;angle,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;x,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;y)</pre>
        <div class="block"><p>Calculates x and y coordinates of 2D vectors from their magnitude and
            angle.</p>

            <p>The function <code>polarToCart</code> calculates the Cartesian coordinates of
                each 2D vector represented by the corresponding elements of <code>magnitude</code>
                and <code>angle</code> :</p>

            <p><em>x(I) = magnitude(I) cos(angle(I))
                y(I) = magnitude(I) sin(angle(I))
            </em></p>

            <p>The relative accuracy of the estimated coordinates is about <code>1e-6</code>.</p>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>magnitude</code> - input floating-point array of magnitudes of 2D vectors; it
                can be an empty matrix (<code>=Mat()</code>), in this case, the function
                assumes that all the magnitudes are =1; if it is not empty, it must have the
                same size and type as <code>angle</code>.
            </dd>
            <dd><code>angle</code> - input floating-point array of angles of 2D vectors.</dd>
            <dd><code>x</code> - output array of x-coordinates of 2D vectors; it has the same size
                and type as <code>angle</code>.
            </dd>
            <dd><code>y</code> - output array of y-coordinates of 2D vectors; it has the same size
                and type as <code>angle</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#polartocart">org.opencv.core.Core.polarToCart</a>,
                <a href="../../../org/opencv/core/Core.html#log(org.opencv.core.Mat, org.opencv.core.Mat)"><code>log(org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#cartToPolar(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)"><code>cartToPolar(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat,
                    boolean)</code></a>,
                <a href="../../../org/opencv/core/Core.html#pow(org.opencv.core.Mat, double, org.opencv.core.Mat)"><code>pow(org.opencv.core.Mat,
                    double, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#sqrt(org.opencv.core.Mat, org.opencv.core.Mat)"><code>sqrt(org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#magnitude(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>magnitude(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#exp(org.opencv.core.Mat, org.opencv.core.Mat)"><code>exp(org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#phase(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)"><code>phase(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, boolean)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="polarToCart(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>polarToCart</h4>
<pre>public static&nbsp;void&nbsp;polarToCart(<a href="../../../org/opencv/core/Mat.html"
                                                 title="class in org.opencv.core">Mat</a>&nbsp;magnitude,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;angle,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;x,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;y,
               boolean&nbsp;angleInDegrees)</pre>
        <div class="block"><p>Calculates x and y coordinates of 2D vectors from their magnitude and
            angle.</p>

            <p>The function <code>polarToCart</code> calculates the Cartesian coordinates of
                each 2D vector represented by the corresponding elements of <code>magnitude</code>
                and <code>angle</code> :</p>

            <p><em>x(I) = magnitude(I) cos(angle(I))
                y(I) = magnitude(I) sin(angle(I))
            </em></p>

            <p>The relative accuracy of the estimated coordinates is about <code>1e-6</code>.</p>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>magnitude</code> - input floating-point array of magnitudes of 2D vectors; it
                can be an empty matrix (<code>=Mat()</code>), in this case, the function
                assumes that all the magnitudes are =1; if it is not empty, it must have the
                same size and type as <code>angle</code>.
            </dd>
            <dd><code>angle</code> - input floating-point array of angles of 2D vectors.</dd>
            <dd><code>x</code> - output array of x-coordinates of 2D vectors; it has the same size
                and type as <code>angle</code>.
            </dd>
            <dd><code>y</code> - output array of y-coordinates of 2D vectors; it has the same size
                and type as <code>angle</code>.
            </dd>
            <dd><code>angleInDegrees</code> - when true, the input angles are measured in degrees,
                otherwise, they are measured in radians.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#polartocart">org.opencv.core.Core.polarToCart</a>,
                <a href="../../../org/opencv/core/Core.html#log(org.opencv.core.Mat, org.opencv.core.Mat)"><code>log(org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#cartToPolar(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)"><code>cartToPolar(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat,
                    boolean)</code></a>,
                <a href="../../../org/opencv/core/Core.html#pow(org.opencv.core.Mat, double, org.opencv.core.Mat)"><code>pow(org.opencv.core.Mat,
                    double, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#sqrt(org.opencv.core.Mat, org.opencv.core.Mat)"><code>sqrt(org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#magnitude(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>magnitude(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#exp(org.opencv.core.Mat, org.opencv.core.Mat)"><code>exp(org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#phase(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)"><code>phase(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, boolean)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="polylines(org.opencv.core.Mat, java.util.List, boolean, org.opencv.core.Scalar)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>polylines</h4>
<pre>public static&nbsp;void&nbsp;polylines(<a href="../../../org/opencv/core/Mat.html"
                                               title="class in org.opencv.core">Mat</a>&nbsp;img,
             java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html"
                                  title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;pts,
             boolean&nbsp;isClosed,
             <a href="../../../org/opencv/core/Scalar.html"
                title="class in org.opencv.core">Scalar</a>&nbsp;color)</pre>
        <div class="block"><p>Draws several polygonal curves.</p>

            <p>The function <code>polylines</code> draws one or more polygonal curves.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>img</code> - Image.</dd>
            <dd><code>pts</code> - Array of polygonal curves.</dd>
            <dd><code>isClosed</code> - Flag indicating whether the drawn polylines are closed or
                not. If they are closed, the function draws a line from the last vertex of
                each curve to its first vertex.
            </dd>
            <dd><code>color</code> - Polyline color.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#polylines">org.opencv.core.Core.polylines</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="polylines(org.opencv.core.Mat, java.util.List, boolean, org.opencv.core.Scalar, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>polylines</h4>
<pre>public static&nbsp;void&nbsp;polylines(<a href="../../../org/opencv/core/Mat.html"
                                               title="class in org.opencv.core">Mat</a>&nbsp;img,
             java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html"
                                  title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;pts,
             boolean&nbsp;isClosed,
             <a href="../../../org/opencv/core/Scalar.html"
                title="class in org.opencv.core">Scalar</a>&nbsp;color,
             int&nbsp;thickness)</pre>
        <div class="block"><p>Draws several polygonal curves.</p>

            <p>The function <code>polylines</code> draws one or more polygonal curves.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>img</code> - Image.</dd>
            <dd><code>pts</code> - Array of polygonal curves.</dd>
            <dd><code>isClosed</code> - Flag indicating whether the drawn polylines are closed or
                not. If they are closed, the function draws a line from the last vertex of
                each curve to its first vertex.
            </dd>
            <dd><code>color</code> - Polyline color.</dd>
            <dd><code>thickness</code> - Thickness of the polyline edges.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#polylines">org.opencv.core.Core.polylines</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="polylines(org.opencv.core.Mat, java.util.List, boolean, org.opencv.core.Scalar, int, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>polylines</h4>
<pre>public static&nbsp;void&nbsp;polylines(<a href="../../../org/opencv/core/Mat.html"
                                               title="class in org.opencv.core">Mat</a>&nbsp;img,
             java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html"
                                  title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;pts,
             boolean&nbsp;isClosed,
             <a href="../../../org/opencv/core/Scalar.html"
                title="class in org.opencv.core">Scalar</a>&nbsp;color,
             int&nbsp;thickness,
             int&nbsp;lineType,
             int&nbsp;shift)</pre>
        <div class="block"><p>Draws several polygonal curves.</p>

            <p>The function <code>polylines</code> draws one or more polygonal curves.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>img</code> - Image.</dd>
            <dd><code>pts</code> - Array of polygonal curves.</dd>
            <dd><code>isClosed</code> - Flag indicating whether the drawn polylines are closed or
                not. If they are closed, the function draws a line from the last vertex of
                each curve to its first vertex.
            </dd>
            <dd><code>color</code> - Polyline color.</dd>
            <dd><code>thickness</code> - Thickness of the polyline edges.</dd>
            <dd><code>lineType</code> - Type of the line segments. See the "line" description.</dd>
            <dd><code>shift</code> - Number of fractional bits in the vertex coordinates.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#polylines">org.opencv.core.Core.polylines</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="pow(org.opencv.core.Mat, double, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>pow</h4>
<pre>public static&nbsp;void&nbsp;pow(<a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a>&nbsp;src,
       double&nbsp;power,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Raises every array element to a power.</p>

            <p>The function <code>pow</code> raises every element of the input array to
                <code>power</code> :</p>

            <p><em>dst(I) = src(I)^power if power is integer; |src(I)|^power
                otherwise&ltBR&gtSo, for a non-integer power exponent, the absolute values of
                input array elements are used. However, it is possible to get true values for
                negative values using some extra operations. In the example below, computing
                the 5th root of array <code>src</code> shows: &ltBR&gt&ltcode&gt</em></p>

            <p>// C++ code:</p>

            <p>Mat mask = src < 0;</p>

            <p>pow(src, 1./5, dst);</p>

            <p>subtract(Scalar.all(0), dst, dst, mask);</p>

            <p>For some values of <code>power</code>, such as integer values, 0.5 and -0.5,
                specialized faster algorithms are used.
                </code></p>

            <p>Special values (NaN, Inf) are not handled.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input array.</dd>
            <dd><code>power</code> - exponent of power.</dd>
            <dd><code>dst</code> - output array of the same size and type as <code>src</code>.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#pow">org.opencv.core.Core.pow</a>,
                <a href="../../../org/opencv/core/Core.html#cartToPolar(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)"><code>cartToPolar(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat,
                    boolean)</code></a>,
                <a href="../../../org/opencv/core/Core.html#polarToCart(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)"><code>polarToCart(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat,
                    boolean)</code></a>,
                <a href="../../../org/opencv/core/Core.html#exp(org.opencv.core.Mat, org.opencv.core.Mat)"><code>exp(org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#sqrt(org.opencv.core.Mat, org.opencv.core.Mat)"><code>sqrt(org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#log(org.opencv.core.Mat, org.opencv.core.Mat)"><code>log(org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="putText(org.opencv.core.Mat, java.lang.String, org.opencv.core.Point, int, double, org.opencv.core.Scalar)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>putText</h4>
<pre>public static&nbsp;void&nbsp;putText(<a href="../../../org/opencv/core/Mat.html"
                                             title="class in org.opencv.core">Mat</a>&nbsp;img,
           java.lang.String&nbsp;text,
           <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;org,
           int&nbsp;fontFace,
           double&nbsp;fontScale,
           <a href="../../../org/opencv/core/Scalar.html"
              title="class in org.opencv.core">Scalar</a>&nbsp;color)</pre>
        <div class="block"><p>Draws a text string.</p>

            <p>The function <code>putText</code> renders the specified text string in the
                image.
                Symbols that cannot be rendered using the specified font are replaced by
                question marks. See "getTextSize" for a text rendering code example.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>img</code> - Image.</dd>
            <dd><code>text</code> - Text string to be drawn.</dd>
            <dd><code>org</code> - Bottom-left corner of the text string in the image.</dd>
            <dd><code>fontFace</code> - Font type. One of <code>FONT_HERSHEY_SIMPLEX</code>,
                <code>FONT_HERSHEY_PLAIN</code>, <code>FONT_HERSHEY_DUPLEX</code>,
                <code>FONT_HERSHEY_COMPLEX</code>, <code>FONT_HERSHEY_TRIPLEX</code>,
                <code>FONT_HERSHEY_COMPLEX_SMALL</code>, <code>FONT_HERSHEY_SCRIPT_SIMPLEX</code>,
                or <code>FONT_HERSHEY_SCRIPT_COMPLEX</code>, where each of the font ID's can
                be combined with <code>FONT_ITALIC</code> to get the slanted letters.
            </dd>
            <dd><code>fontScale</code> - Font scale factor that is multiplied by the font-specific
                base size.
            </dd>
            <dd><code>color</code> - Text color.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#puttext">org.opencv.core.Core.putText</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="putText(org.opencv.core.Mat, java.lang.String, org.opencv.core.Point, int, double, org.opencv.core.Scalar, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>putText</h4>
<pre>public static&nbsp;void&nbsp;putText(<a href="../../../org/opencv/core/Mat.html"
                                             title="class in org.opencv.core">Mat</a>&nbsp;img,
           java.lang.String&nbsp;text,
           <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;org,
           int&nbsp;fontFace,
           double&nbsp;fontScale,
           <a href="../../../org/opencv/core/Scalar.html"
              title="class in org.opencv.core">Scalar</a>&nbsp;color,
           int&nbsp;thickness)</pre>
        <div class="block"><p>Draws a text string.</p>

            <p>The function <code>putText</code> renders the specified text string in the
                image.
                Symbols that cannot be rendered using the specified font are replaced by
                question marks. See "getTextSize" for a text rendering code example.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>img</code> - Image.</dd>
            <dd><code>text</code> - Text string to be drawn.</dd>
            <dd><code>org</code> - Bottom-left corner of the text string in the image.</dd>
            <dd><code>fontFace</code> - Font type. One of <code>FONT_HERSHEY_SIMPLEX</code>,
                <code>FONT_HERSHEY_PLAIN</code>, <code>FONT_HERSHEY_DUPLEX</code>,
                <code>FONT_HERSHEY_COMPLEX</code>, <code>FONT_HERSHEY_TRIPLEX</code>,
                <code>FONT_HERSHEY_COMPLEX_SMALL</code>, <code>FONT_HERSHEY_SCRIPT_SIMPLEX</code>,
                or <code>FONT_HERSHEY_SCRIPT_COMPLEX</code>, where each of the font ID's can
                be combined with <code>FONT_ITALIC</code> to get the slanted letters.
            </dd>
            <dd><code>fontScale</code> - Font scale factor that is multiplied by the font-specific
                base size.
            </dd>
            <dd><code>color</code> - Text color.</dd>
            <dd><code>thickness</code> - Thickness of the lines used to draw a text.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#puttext">org.opencv.core.Core.putText</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="putText(org.opencv.core.Mat, java.lang.String, org.opencv.core.Point, int, double, org.opencv.core.Scalar, int, int, boolean)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>putText</h4>
<pre>public static&nbsp;void&nbsp;putText(<a href="../../../org/opencv/core/Mat.html"
                                             title="class in org.opencv.core">Mat</a>&nbsp;img,
           java.lang.String&nbsp;text,
           <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;org,
           int&nbsp;fontFace,
           double&nbsp;fontScale,
           <a href="../../../org/opencv/core/Scalar.html"
              title="class in org.opencv.core">Scalar</a>&nbsp;color,
           int&nbsp;thickness,
           int&nbsp;lineType,
           boolean&nbsp;bottomLeftOrigin)</pre>
        <div class="block"><p>Draws a text string.</p>

            <p>The function <code>putText</code> renders the specified text string in the
                image.
                Symbols that cannot be rendered using the specified font are replaced by
                question marks. See "getTextSize" for a text rendering code example.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>img</code> - Image.</dd>
            <dd><code>text</code> - Text string to be drawn.</dd>
            <dd><code>org</code> - Bottom-left corner of the text string in the image.</dd>
            <dd><code>fontFace</code> - Font type. One of <code>FONT_HERSHEY_SIMPLEX</code>,
                <code>FONT_HERSHEY_PLAIN</code>, <code>FONT_HERSHEY_DUPLEX</code>,
                <code>FONT_HERSHEY_COMPLEX</code>, <code>FONT_HERSHEY_TRIPLEX</code>,
                <code>FONT_HERSHEY_COMPLEX_SMALL</code>, <code>FONT_HERSHEY_SCRIPT_SIMPLEX</code>,
                or <code>FONT_HERSHEY_SCRIPT_COMPLEX</code>, where each of the font ID's can
                be combined with <code>FONT_ITALIC</code> to get the slanted letters.
            </dd>
            <dd><code>fontScale</code> - Font scale factor that is multiplied by the font-specific
                base size.
            </dd>
            <dd><code>color</code> - Text color.</dd>
            <dd><code>thickness</code> - Thickness of the lines used to draw a text.</dd>
            <dd><code>lineType</code> - Line type. See the <code>line</code> for details.</dd>
            <dd><code>bottomLeftOrigin</code> - When true, the image data origin is at the
                bottom-left corner. Otherwise, it is at the top-left corner.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#puttext">org.opencv.core.Core.putText</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="randn(org.opencv.core.Mat, double, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>randn</h4>
<pre>public static&nbsp;void&nbsp;randn(<a href="../../../org/opencv/core/Mat.html"
                                           title="class in org.opencv.core">Mat</a>&nbsp;dst,
         double&nbsp;mean,
         double&nbsp;stddev)</pre>
        <div class="block"><p>Fills the array with normally distributed random numbers.</p>

            <p>The function <code>randn</code> fills the matrix <code>dst</code> with
                normally distributed random numbers with the specified mean vector and the
                standard deviation matrix. The generated random numbers are clipped to fit
                the value range of the output array data type.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>dst</code> - output array of random numbers; the array must be pre-allocated
                and have 1 to 4 channels.
            </dd>
            <dd><code>mean</code> - mean value (expectation) of the generated random numbers.</dd>
            <dd><code>stddev</code> - standard deviation of the generated random numbers; it can be
                either a vector (in which case a diagonal standard deviation matrix is
                assumed) or a square matrix.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#randn">org.opencv.core.Core.randn</a>,
                <a href="../../../org/opencv/core/Core.html#randu(org.opencv.core.Mat, double, double)"><code>randu(org.opencv.core.Mat,
                    double, double)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="randShuffle(org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>randShuffle</h4>
        <pre>public static&nbsp;void&nbsp;randShuffle(<a href="../../../org/opencv/core/Mat.html"
                                                         title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
    </li>
</ul>
<a name="randShuffle(org.opencv.core.Mat, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>randShuffle</h4>
<pre>public static&nbsp;void&nbsp;randShuffle(<a href="../../../org/opencv/core/Mat.html"
                                                 title="class in org.opencv.core">Mat</a>&nbsp;dst,
               double&nbsp;iterFactor)</pre>
    </li>
</ul>
<a name="randu(org.opencv.core.Mat, double, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>randu</h4>
<pre>public static&nbsp;void&nbsp;randu(<a href="../../../org/opencv/core/Mat.html"
                                           title="class in org.opencv.core">Mat</a>&nbsp;dst,
         double&nbsp;low,
         double&nbsp;high)</pre>
        <div class="block"><p>Generates a single uniformly-distributed random number or an array of
            random
            numbers.</p>

            <p>The template functions <code>randu</code> generate and return the next
                uniformly-distributed random value of the specified type. <code>randu
                    <int>()
                </code>
                is an equivalent to <code>(int)theRNG();</code>, and so on. See "RNG"
                description.
            </p>

            <p>The second non-template variant of the function fills the matrix
                <code>dst</code> with uniformly-distributed random numbers from the specified
                range:</p>

            <p><em>low _c <= dst(I)_c &lt high _c</em></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>dst</code> - output array of random numbers; the array must be pre-allocated.
            </dd>
            <dd><code>low</code> - inclusive lower boundary of the generated random numbers.</dd>
            <dd><code>high</code> - exclusive upper boundary of the generated random numbers.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#randu">org.opencv.core.Core.randu</a>,
                <a href="../../../org/opencv/core/Core.html#randn(org.opencv.core.Mat, double, double)"><code>randn(org.opencv.core.Mat,
                    double, double)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="rectangle(org.opencv.core.Mat, org.opencv.core.Point, org.opencv.core.Point, org.opencv.core.Scalar)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>rectangle</h4>
<pre>public static&nbsp;void&nbsp;rectangle(<a href="../../../org/opencv/core/Mat.html"
                                               title="class in org.opencv.core">Mat</a>&nbsp;img,
             <a href="../../../org/opencv/core/Point.html"
                title="class in org.opencv.core">Point</a>&nbsp;pt1,
             <a href="../../../org/opencv/core/Point.html"
                title="class in org.opencv.core">Point</a>&nbsp;pt2,
             <a href="../../../org/opencv/core/Scalar.html"
                title="class in org.opencv.core">Scalar</a>&nbsp;color)</pre>
        <div class="block"><p>Draws a simple, thick, or filled up-right rectangle.</p>

            <p>The function <code>rectangle</code> draws a rectangle outline or a filled
                rectangle whose two opposite corners are <code>pt1</code> and
                <code>pt2</code>, or <code>r.tl()</code> and <code>r.br()-Point(1,1)</code>.</p>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>img</code> - Image.</dd>
            <dd><code>pt1</code> - Vertex of the rectangle.</dd>
            <dd><code>pt2</code> - Vertex of the rectangle opposite to <code>pt1</code>.</dd>
            <dd><code>color</code> - Rectangle color or brightness (grayscale image).</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#rectangle">org.opencv.core.Core.rectangle</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="rectangle(org.opencv.core.Mat, org.opencv.core.Point, org.opencv.core.Point, org.opencv.core.Scalar, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>rectangle</h4>
<pre>public static&nbsp;void&nbsp;rectangle(<a href="../../../org/opencv/core/Mat.html"
                                               title="class in org.opencv.core">Mat</a>&nbsp;img,
             <a href="../../../org/opencv/core/Point.html"
                title="class in org.opencv.core">Point</a>&nbsp;pt1,
             <a href="../../../org/opencv/core/Point.html"
                title="class in org.opencv.core">Point</a>&nbsp;pt2,
             <a href="../../../org/opencv/core/Scalar.html"
                title="class in org.opencv.core">Scalar</a>&nbsp;color,
             int&nbsp;thickness)</pre>
        <div class="block"><p>Draws a simple, thick, or filled up-right rectangle.</p>

            <p>The function <code>rectangle</code> draws a rectangle outline or a filled
                rectangle whose two opposite corners are <code>pt1</code> and
                <code>pt2</code>, or <code>r.tl()</code> and <code>r.br()-Point(1,1)</code>.</p>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>img</code> - Image.</dd>
            <dd><code>pt1</code> - Vertex of the rectangle.</dd>
            <dd><code>pt2</code> - Vertex of the rectangle opposite to <code>pt1</code>.</dd>
            <dd><code>color</code> - Rectangle color or brightness (grayscale image).</dd>
            <dd><code>thickness</code> - Thickness of lines that make up the rectangle. Negative
                values, like <code>CV_FILLED</code>, mean that the function has to draw a
                filled rectangle.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#rectangle">org.opencv.core.Core.rectangle</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="rectangle(org.opencv.core.Mat, org.opencv.core.Point, org.opencv.core.Point, org.opencv.core.Scalar, int, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>rectangle</h4>
<pre>public static&nbsp;void&nbsp;rectangle(<a href="../../../org/opencv/core/Mat.html"
                                               title="class in org.opencv.core">Mat</a>&nbsp;img,
             <a href="../../../org/opencv/core/Point.html"
                title="class in org.opencv.core">Point</a>&nbsp;pt1,
             <a href="../../../org/opencv/core/Point.html"
                title="class in org.opencv.core">Point</a>&nbsp;pt2,
             <a href="../../../org/opencv/core/Scalar.html"
                title="class in org.opencv.core">Scalar</a>&nbsp;color,
             int&nbsp;thickness,
             int&nbsp;lineType,
             int&nbsp;shift)</pre>
        <div class="block"><p>Draws a simple, thick, or filled up-right rectangle.</p>

            <p>The function <code>rectangle</code> draws a rectangle outline or a filled
                rectangle whose two opposite corners are <code>pt1</code> and
                <code>pt2</code>, or <code>r.tl()</code> and <code>r.br()-Point(1,1)</code>.</p>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>img</code> - Image.</dd>
            <dd><code>pt1</code> - Vertex of the rectangle.</dd>
            <dd><code>pt2</code> - Vertex of the rectangle opposite to <code>pt1</code>.</dd>
            <dd><code>color</code> - Rectangle color or brightness (grayscale image).</dd>
            <dd><code>thickness</code> - Thickness of lines that make up the rectangle. Negative
                values, like <code>CV_FILLED</code>, mean that the function has to draw a
                filled rectangle.
            </dd>
            <dd><code>lineType</code> - Type of the line. See the "line" description.</dd>
            <dd><code>shift</code> - Number of fractional bits in the point coordinates.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/drawing_functions.html#rectangle">org.opencv.core.Core.rectangle</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="reduce(org.opencv.core.Mat, org.opencv.core.Mat, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>reduce</h4>
<pre>public static&nbsp;void&nbsp;reduce(<a href="../../../org/opencv/core/Mat.html"
                                            title="class in org.opencv.core">Mat</a>&nbsp;src,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
          int&nbsp;dim,
          int&nbsp;rtype)</pre>
        <div class="block"><p>Reduces a matrix to a vector.</p>

            <p>The function <code>reduce</code> reduces the matrix to a vector by treating
                the matrix rows/columns as a set of 1D vectors and performing the specified
                operation on the vectors until a single row/column is obtained. For example,
                the function can be used to compute horizontal and vertical projections of a
                raster image. In case of <code>CV_REDUCE_SUM</code> and <code>CV_REDUCE_AVG</code>,
                the output may have a larger element bit-depth to preserve accuracy. And
                multi-channel arrays are also supported in these two reduction modes.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input 2D matrix.</dd>
            <dd><code>dst</code> - output vector. Its size and type is defined by <code>dim</code>
                and <code>dtype</code> parameters.
            </dd>
            <dd><code>dim</code> - dimension index along which the matrix is reduced. 0 means that
                the matrix is reduced to a single row. 1 means that the matrix is reduced to
                a single column.
            </dd>
            <dd><code>rtype</code> - reduction operation that could be one of the following:
                <ul>
                    <li> CV_REDUCE_SUM: the output is the sum of all rows/columns of the
                        matrix.
                    <li> CV_REDUCE_AVG: the output is the mean vector of all rows/columns of
                        the matrix.
                    <li> CV_REDUCE_MAX: the output is the maximum (column/row-wise) of all
                        rows/columns of the matrix.
                    <li> CV_REDUCE_MIN: the output is the minimum (column/row-wise) of all
                        rows/columns of the matrix.
                </ul>
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#reduce">org.opencv.core.Core.reduce</a>,
                <a href="../../../org/opencv/core/Core.html#repeat(org.opencv.core.Mat, int, int, org.opencv.core.Mat)"><code>repeat(org.opencv.core.Mat,
                    int, int, org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="reduce(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>reduce</h4>
<pre>public static&nbsp;void&nbsp;reduce(<a href="../../../org/opencv/core/Mat.html"
                                            title="class in org.opencv.core">Mat</a>&nbsp;src,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
          int&nbsp;dim,
          int&nbsp;rtype,
          int&nbsp;dtype)</pre>
        <div class="block"><p>Reduces a matrix to a vector.</p>

            <p>The function <code>reduce</code> reduces the matrix to a vector by treating
                the matrix rows/columns as a set of 1D vectors and performing the specified
                operation on the vectors until a single row/column is obtained. For example,
                the function can be used to compute horizontal and vertical projections of a
                raster image. In case of <code>CV_REDUCE_SUM</code> and <code>CV_REDUCE_AVG</code>,
                the output may have a larger element bit-depth to preserve accuracy. And
                multi-channel arrays are also supported in these two reduction modes.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input 2D matrix.</dd>
            <dd><code>dst</code> - output vector. Its size and type is defined by <code>dim</code>
                and <code>dtype</code> parameters.
            </dd>
            <dd><code>dim</code> - dimension index along which the matrix is reduced. 0 means that
                the matrix is reduced to a single row. 1 means that the matrix is reduced to
                a single column.
            </dd>
            <dd><code>rtype</code> - reduction operation that could be one of the following:
                <ul>
                    <li> CV_REDUCE_SUM: the output is the sum of all rows/columns of the
                        matrix.
                    <li> CV_REDUCE_AVG: the output is the mean vector of all rows/columns of
                        the matrix.
                    <li> CV_REDUCE_MAX: the output is the maximum (column/row-wise) of all
                        rows/columns of the matrix.
                    <li> CV_REDUCE_MIN: the output is the minimum (column/row-wise) of all
                        rows/columns of the matrix.
                </ul>
            </dd>
            <dd><code>dtype</code> - when negative, the output vector will have the same type as the
                input matrix, otherwise, its type will be <code>CV_MAKE_TYPE(CV_MAT_DEPTH(dtype),
                    src.channels())</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#reduce">org.opencv.core.Core.reduce</a>,
                <a href="../../../org/opencv/core/Core.html#repeat(org.opencv.core.Mat, int, int, org.opencv.core.Mat)"><code>repeat(org.opencv.core.Mat,
                    int, int, org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="repeat(org.opencv.core.Mat, int, int, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>repeat</h4>
<pre>public static&nbsp;void&nbsp;repeat(<a href="../../../org/opencv/core/Mat.html"
                                            title="class in org.opencv.core">Mat</a>&nbsp;src,
          int&nbsp;ny,
          int&nbsp;nx,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Fills the output array with repeated copies of the input array.</p>

            <p>The functions "repeat" duplicate the input array one or more times along each
                of the two axes:</p>

            <p><em>dst _(ij)= src _(i mod src.rows, j mod src.cols)</em></p>

            <p>The second variant of the function is more convenient to use with
                "MatrixExpressions".</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input array to replicate.</dd>
            <dd><code>ny</code> - Flag to specify how many times the <code>src</code> is repeated
                along the vertical axis.
            </dd>
            <dd><code>nx</code> - Flag to specify how many times the <code>src</code> is repeated
                along the horizontal axis.
            </dd>
            <dd><code>dst</code> - output array of the same type as <code>src</code>.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#repeat">org.opencv.core.Core.repeat</a>,
                <a href="../../../org/opencv/core/Core.html#reduce(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int)"><code>reduce(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="scaleAdd(org.opencv.core.Mat, double, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>scaleAdd</h4>
<pre>public static&nbsp;void&nbsp;scaleAdd(<a href="../../../org/opencv/core/Mat.html"
                                              title="class in org.opencv.core">Mat</a>&nbsp;src1,
            double&nbsp;alpha,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Calculates the sum of a scaled array and another array.</p>

            <p>The function <code>scaleAdd</code> is one of the classical primitive linear
                algebra operations, known as <code>DAXPY</code> or <code>SAXPY</code> in BLAS
                (http://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms). It
                calculates the sum of a scaled array and another array:</p>

            <p><em>dst(I)= scale * src1(I) + src2(I)&ltBR&gtThe function can also be
                emulated with a matrix expression, for example: &ltBR&gt&ltcode&gt</em></p>

            <p>// C++ code:</p>

            <p>Mat A(3, 3, CV_64F);...</p>

            <p>A.row(0) = A.row(1)*2 + A.row(2);</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array.</dd>
            <dd><code>alpha</code> - a alpha</dd>
            <dd><code>src2</code> - second input array of the same size and type as
                <code>src1</code>.
            </dd>
            <dd><code>dst</code> - output array of the same size and type as <code>src1</code>.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#scaleadd">org.opencv.core.Core.scaleAdd</a>,
                <a href="../../../org/opencv/core/Mat.html#dot(org.opencv.core.Mat)"><code>Mat.dot(org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Mat.html#convertTo(org.opencv.core.Mat, int, double, double)"><code>Mat.convertTo(org.opencv.core.Mat,
                    int, double, double)</code></a>,
                <a href="../../../org/opencv/core/Core.html#addWeighted(org.opencv.core.Mat, double, org.opencv.core.Mat, double, double, org.opencv.core.Mat, int)"><code>addWeighted(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, double, double, org.opencv.core.Mat,
                    int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#add(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>add(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#subtract(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>subtract(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>
            </dd>
        </dl>
    </li>
</ul>
<a name="setErrorVerbosity(boolean)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>setErrorVerbosity</h4>
        <pre>public static&nbsp;void&nbsp;setErrorVerbosity(boolean&nbsp;verbose)</pre>
    </li>
</ul>
<a name="setIdentity(org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>setIdentity</h4>
        <pre>public static&nbsp;void&nbsp;setIdentity(<a href="../../../org/opencv/core/Mat.html"
                                                         title="class in org.opencv.core">Mat</a>&nbsp;mtx)</pre>
        <div class="block"><p>Initializes a scaled identity matrix.</p>

            <p>The function "setIdentity" initializes a scaled identity matrix:</p>

            <p><em>mtx(i,j)= value if i=j; 0 otherwise&ltBR&gtThe function can also be
                emulated using the matrix initializers and the matrix expressions:
                &ltBR&gt&ltcode&gt</em></p>

            <p>// C++ code:</p>

            <p>Mat A = Mat.eye(4, 3, CV_32F)*5;</p>

            <p>// A will be set to [[5, 0, 0], [0, 5, 0], [0, 0, 5], [0, 0, 0]]</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>mtx</code> - matrix to initialize (not necessarily square).</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#setidentity">org.opencv.core.Core.setIdentity</a>,
                <a href="../../../org/opencv/core/Mat.html#setTo(org.opencv.core.Scalar)"><code>Mat.setTo(org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/core/Mat.html#ones(int, int, int)"><code>Mat.ones(int,
                    int, int)</code></a>,
                <a href="../../../org/opencv/core/Mat.html#zeros(int, int, int)"><code>Mat.zeros(int,
                    int, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="setIdentity(org.opencv.core.Mat, org.opencv.core.Scalar)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>setIdentity</h4>
<pre>public static&nbsp;void&nbsp;setIdentity(<a href="../../../org/opencv/core/Mat.html"
                                                 title="class in org.opencv.core">Mat</a>&nbsp;mtx,
               <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;s)</pre>
        <div class="block"><p>Initializes a scaled identity matrix.</p>

            <p>The function "setIdentity" initializes a scaled identity matrix:</p>

            <p><em>mtx(i,j)= value if i=j; 0 otherwise&ltBR&gtThe function can also be
                emulated using the matrix initializers and the matrix expressions:
                &ltBR&gt&ltcode&gt</em></p>

            <p>// C++ code:</p>

            <p>Mat A = Mat.eye(4, 3, CV_32F)*5;</p>

            <p>// A will be set to [[5, 0, 0], [0, 5, 0], [0, 0, 5], [0, 0, 0]]</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>mtx</code> - matrix to initialize (not necessarily square).</dd>
            <dd><code>s</code> - a s</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#setidentity">org.opencv.core.Core.setIdentity</a>,
                <a href="../../../org/opencv/core/Mat.html#setTo(org.opencv.core.Scalar)"><code>Mat.setTo(org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/core/Mat.html#ones(int, int, int)"><code>Mat.ones(int,
                    int, int)</code></a>,
                <a href="../../../org/opencv/core/Mat.html#zeros(int, int, int)"><code>Mat.zeros(int,
                    int, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="setNumThreads(int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>setNumThreads</h4>
        <pre>public static&nbsp;void&nbsp;setNumThreads(int&nbsp;nthreads)</pre>
        <div class="block"><p>OpenCV will try to set the number of threads for the next parallel
            region.
            If <code>threads == 0</code>, OpenCV will disable threading optimizations and
            run all it's functions sequentially. Passing <code>threads < 0</code> will
            reset threads number to system default.
            This function must be called outside of parallel region.</p>

            <p>OpenCV will try to run it's functions with specified threads number, but some
                behaviour differs from framework:</p>
            <ul>
                <li> TBB  User-defined parallel constructions will run with the same
                    threads number, if another does not specified. If late on user creates own
                    scheduler, OpenCV will be use it.
                <li> OpenMP  No special defined behaviour.
                <li> Concurrency  If <code>threads == 1</code>, OpenCV will disable
                    threading optimizations and run it's functions sequentially.
                <li> GCD  Supports only values <= 0.
                <li> C=  No special defined behaviour.
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>nthreads</code> - Number of threads used by OpenCV.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/utility_and_system_functions_and_macros.html#setnumthreads">org.opencv.core.Core.setNumThreads</a>,
                <a href="../../../org/opencv/core/Core.html#getThreadNum()"><code>getThreadNum()</code></a>,
                <a href="../../../org/opencv/core/Core.html#getNumThreads()"><code>getNumThreads()</code></a>
            </dd>
        </dl>
    </li>
</ul>
<a name="solve(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>solve</h4>
<pre>public static&nbsp;boolean&nbsp;solve(<a href="../../../org/opencv/core/Mat.html"
                                              title="class in org.opencv.core">Mat</a>&nbsp;src1,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Solves one or more linear systems or least-squares problems.</p>

            <p>The function <code>solve</code> solves a linear system or least-squares
                problem (the latter is possible with SVD or QR methods, or by specifying the
                flag <code>DECOMP_NORMAL</code>):</p>

            <p><em>dst = arg min _X|src1 * X - src2|</em></p>

            <p>If <code>DECOMP_LU</code> or <code>DECOMP_CHOLESKY</code> method is used, the
                function returns 1 if <code>src1</code> (or <em>src1^Tsrc1</em>) is
                non-singular. Otherwise, it returns 0. In the latter case, <code>dst</code>
                is not valid. Other methods find a pseudo-solution in case of a singular
                left-hand side part.</p>

            <p>Note: If you want to find a unity-norm solution of an under-defined singular
                system <em>src1*dst=0</em>, the function <code>solve</code> will not do the
                work. Use "SVD.solveZ" instead.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - input matrix on the left-hand side of the system.</dd>
            <dd><code>src2</code> - input matrix on the right-hand side of the system.</dd>
            <dd><code>dst</code> - output solution.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#solve">org.opencv.core.Core.solve</a>,
                <a href="../../../org/opencv/core/Core.html#invert(org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>invert(org.opencv.core.Mat,
                    org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#eigen(org.opencv.core.Mat, boolean, org.opencv.core.Mat, org.opencv.core.Mat)"><code>eigen(org.opencv.core.Mat,
                    boolean, org.opencv.core.Mat, org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="solve(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>solve</h4>
<pre>public static&nbsp;boolean&nbsp;solve(<a href="../../../org/opencv/core/Mat.html"
                                              title="class in org.opencv.core">Mat</a>&nbsp;src1,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
            int&nbsp;flags)</pre>
        <div class="block"><p>Solves one or more linear systems or least-squares problems.</p>

            <p>The function <code>solve</code> solves a linear system or least-squares
                problem (the latter is possible with SVD or QR methods, or by specifying the
                flag <code>DECOMP_NORMAL</code>):</p>

            <p><em>dst = arg min _X|src1 * X - src2|</em></p>

            <p>If <code>DECOMP_LU</code> or <code>DECOMP_CHOLESKY</code> method is used, the
                function returns 1 if <code>src1</code> (or <em>src1^Tsrc1</em>) is
                non-singular. Otherwise, it returns 0. In the latter case, <code>dst</code>
                is not valid. Other methods find a pseudo-solution in case of a singular
                left-hand side part.</p>

            <p>Note: If you want to find a unity-norm solution of an under-defined singular
                system <em>src1*dst=0</em>, the function <code>solve</code> will not do the
                work. Use "SVD.solveZ" instead.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - input matrix on the left-hand side of the system.</dd>
            <dd><code>src2</code> - input matrix on the right-hand side of the system.</dd>
            <dd><code>dst</code> - output solution.</dd>
            <dd><code>flags</code> - solution (matrix inversion) method.
                <ul>
                    <li> DECOMP_LU Gaussian elimination with optimal pivot element chosen.
                    <li> DECOMP_CHOLESKY Cholesky <em>LL^T</em> factorization; the matrix
                        <code>src1</code> must be symmetrical and positively defined.
                    <li> DECOMP_EIG eigenvalue decomposition; the matrix <code>src1</code> must
                        be symmetrical.
                    <li> DECOMP_SVD singular value decomposition (SVD) method; the system can
                        be over-defined and/or the matrix <code>src1</code> can be singular.
                    <li> DECOMP_QR QR factorization; the system can be over-defined and/or the
                        matrix <code>src1</code> can be singular.
                    <li> DECOMP_NORMAL while all the previous flags are mutually exclusive,
                        this flag can be used together with any of the previous; it means that the
                        normal equations <em>src1^T*src1*dst=src1^Tsrc2</em> are solved instead of
                        the original system <em>src1*dst=src2</em>.
                </ul>
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#solve">org.opencv.core.Core.solve</a>,
                <a href="../../../org/opencv/core/Core.html#invert(org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>invert(org.opencv.core.Mat,
                    org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#eigen(org.opencv.core.Mat, boolean, org.opencv.core.Mat, org.opencv.core.Mat)"><code>eigen(org.opencv.core.Mat,
                    boolean, org.opencv.core.Mat, org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="solveCubic(org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>solveCubic</h4>
<pre>public static&nbsp;int&nbsp;solveCubic(<a href="../../../org/opencv/core/Mat.html"
                                               title="class in org.opencv.core">Mat</a>&nbsp;coeffs,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;roots)</pre>
        <div class="block"><p>Finds the real roots of a cubic equation.</p>

            <p>The function <code>solveCubic</code> finds the real roots of a cubic
                equation:</p>
            <ul>
                <li> if <code>coeffs</code> is a 4-element vector:
            </ul>

            <p><em>coeffs [0] x^3 + coeffs [1] x^2 + coeffs [2] x + coeffs [3] = 0</em></p>

            <ul>
                <li> if <code>coeffs</code> is a 3-element vector:
            </ul>

            <p><em>x^3 + coeffs [0] x^2 + coeffs [1] x + coeffs [2] = 0</em></p>

            <p>The roots are stored in the <code>roots</code> array.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>coeffs</code> - equation coefficients, an array of 3 or 4 elements.</dd>
            <dd><code>roots</code> - output array of real roots that has 1 or 3 elements.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#solvecubic">org.opencv.core.Core.solveCubic</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="solvePoly(org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>solvePoly</h4>
<pre>public static&nbsp;double&nbsp;solvePoly(<a href="../../../org/opencv/core/Mat.html"
                                                 title="class in org.opencv.core">Mat</a>&nbsp;coeffs,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;roots)</pre>
        <div class="block"><p>Finds the real or complex roots of a polynomial equation.</p>

            <p>The function <code>solvePoly</code> finds real and complex roots of a
                polynomial equation:</p>

            <p><em>coeffs [n] x^(n) + coeffs [n-1] x^(n-1) +... + coeffs [1] x + coeffs [0]
                = 0</em></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>coeffs</code> - array of polynomial coefficients.</dd>
            <dd><code>roots</code> - output (complex) array of roots.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#solvepoly">org.opencv.core.Core.solvePoly</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="solvePoly(org.opencv.core.Mat, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>solvePoly</h4>
<pre>public static&nbsp;double&nbsp;solvePoly(<a href="../../../org/opencv/core/Mat.html"
                                                 title="class in org.opencv.core">Mat</a>&nbsp;coeffs,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;roots,
               int&nbsp;maxIters)</pre>
        <div class="block"><p>Finds the real or complex roots of a polynomial equation.</p>

            <p>The function <code>solvePoly</code> finds real and complex roots of a
                polynomial equation:</p>

            <p><em>coeffs [n] x^(n) + coeffs [n-1] x^(n-1) +... + coeffs [1] x + coeffs [0]
                = 0</em></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>coeffs</code> - array of polynomial coefficients.</dd>
            <dd><code>roots</code> - output (complex) array of roots.</dd>
            <dd><code>maxIters</code> - maximum number of iterations the algorithm does.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#solvepoly">org.opencv.core.Core.solvePoly</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="sort(org.opencv.core.Mat, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>sort</h4>
<pre>public static&nbsp;void&nbsp;sort(<a href="../../../org/opencv/core/Mat.html"
                                          title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;flags)</pre>
        <div class="block"><p>Sorts each row or each column of a matrix.</p>

            <p>The function <code>sort</code> sorts each matrix row or each matrix column in
                ascending or descending order. So you should pass two operation flags to get
                desired behaviour. If you want to sort matrix rows or columns
                lexicographically, you can use STL <code>std.sort</code> generic function
                with the proper comparison predicate.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input single-channel array.</dd>
            <dd><code>dst</code> - output array of the same size and type as <code>src</code>.</dd>
            <dd><code>flags</code> - operation flags, a combination of the following values:
                <ul>
                    <li> CV_SORT_EVERY_ROW each matrix row is sorted independently.
                    <li> CV_SORT_EVERY_COLUMN each matrix column is sorted independently; this
                        flag and the previous one are mutually exclusive.
                    <li> CV_SORT_ASCENDING each matrix row is sorted in the ascending order.
                    <li> CV_SORT_DESCENDING each matrix row is sorted in the descending order;
                        this flag and the previous one are also mutually exclusive.
                </ul>
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#sort">org.opencv.core.Core.sort</a>,
                <a href="../../../org/opencv/core/Core.html#randShuffle(org.opencv.core.Mat, double)"><code>randShuffle(org.opencv.core.Mat,
                    double)</code></a>,
                <a href="../../../org/opencv/core/Core.html#sortIdx(org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>sortIdx(org.opencv.core.Mat,
                    org.opencv.core.Mat, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="sortIdx(org.opencv.core.Mat, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>sortIdx</h4>
<pre>public static&nbsp;void&nbsp;sortIdx(<a href="../../../org/opencv/core/Mat.html"
                                             title="class in org.opencv.core">Mat</a>&nbsp;src,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
           int&nbsp;flags)</pre>
        <div class="block"><p>Sorts each row or each column of a matrix.</p>

            <p>The function <code>sortIdx</code> sorts each matrix row or each matrix column
                in the ascending or descending order. So you should pass two operation flags
                to get desired behaviour. Instead of reordering the elements themselves, it
                stores the indices of sorted elements in the output array. For example:
                <code></p>

            <p>// C++ code:</p>

            <p>Mat A = Mat.eye(3,3,CV_32F), B;</p>

            <p>sortIdx(A, B, CV_SORT_EVERY_ROW + CV_SORT_ASCENDING);</p>

            <p>// B will probably contain</p>

            <p>// (because of equal elements in A some permutations are possible):</p>

            <p>// [[1, 2, 0], [0, 2, 1], [0, 1, 2]]</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input single-channel array.</dd>
            <dd><code>dst</code> - output integer array of the same size as <code>src</code>.</dd>
            <dd><code>flags</code> - operation flags that could be a combination of the following
                values:
                <ul>
                    <li> CV_SORT_EVERY_ROW each matrix row is sorted independently.
                    <li> CV_SORT_EVERY_COLUMN each matrix column is sorted independently; this
                        flag and the previous one are mutually exclusive.
                    <li> CV_SORT_ASCENDING each matrix row is sorted in the ascending order.
                    <li> CV_SORT_DESCENDING each matrix row is sorted in the descending order;
                        his flag and the previous one are also mutually exclusive.
                </ul>
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#sortidx">org.opencv.core.Core.sortIdx</a>,
                <a href="../../../org/opencv/core/Core.html#sort(org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>sort(org.opencv.core.Mat,
                    org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#randShuffle(org.opencv.core.Mat, double)"><code>randShuffle(org.opencv.core.Mat,
                    double)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="split(org.opencv.core.Mat, java.util.List)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>split</h4>
<pre>public static&nbsp;void&nbsp;split(<a href="../../../org/opencv/core/Mat.html"
                                           title="class in org.opencv.core">Mat</a>&nbsp;m,
         java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                              title="class in org.opencv.core">Mat</a>&gt;&nbsp;mv)</pre>
        <div class="block"><p>Divides a multi-channel array into several single-channel arrays.</p>

            <p>The functions <code>split</code> split a multi-channel array into separate
                single-channel arrays:</p>

            <p><em>mv [c](I) = src(I)_c</em></p>

            <p>If you need to extract a single channel or do some other sophisticated
                channel permutation, use "mixChannels".</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>m</code> - a m</dd>
            <dd><code>mv</code> - output array or vector of arrays; in the first variant of the
                function the number of arrays must match <code>src.channels()</code>; the
                arrays themselves are reallocated, if needed.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#split">org.opencv.core.Core.split</a>,
                <a href="../../../org/opencv/core/Core.html#merge(java.util.List, org.opencv.core.Mat)"><code>merge(java.util.List
                    <org.opencv.core.Mat>, org.opencv.core.Mat)
                </code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#cvtColor(org.opencv.core.Mat, org.opencv.core.Mat, int, int)"><code>Imgproc.cvtColor(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#mixChannels(java.util.List, java.util.List, org.opencv.core.MatOfInt)"><code>mixChannels(java.util.List
                    <org.opencv.core.Mat>, java.util.List
                        <org.opencv.core.Mat>, org.opencv.core.MatOfInt)
                </code></a></dd>
        </dl>
    </li>
</ul>
<a name="sqrt(org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>sqrt</h4>
<pre>public static&nbsp;void&nbsp;sqrt(<a href="../../../org/opencv/core/Mat.html"
                                          title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Calculates a square root of array elements.</p>

            <p>The functions <code>sqrt</code> calculate a square root of each input array
                element. In case of multi-channel arrays, each channel is processed
                independently. The accuracy is approximately the same as of the built-in
                <code>std.sqrt</code>.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input floating-point array.</dd>
            <dd><code>dst</code> - output array of the same size and type as <code>src</code>.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#sqrt">org.opencv.core.Core.sqrt</a>,
                <a href="../../../org/opencv/core/Core.html#pow(org.opencv.core.Mat, double, org.opencv.core.Mat)"><code>pow(org.opencv.core.Mat,
                    double, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#magnitude(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>magnitude(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="subtract(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>subtract</h4>
<pre>public static&nbsp;void&nbsp;subtract(<a href="../../../org/opencv/core/Mat.html"
                                              title="class in org.opencv.core">Mat</a>&nbsp;src1,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Calculates the per-element difference between two arrays or array and
            a
            scalar.</p>

            <p>The function <code>subtract</code> calculates:</p>
            <ul>
                <li> Difference between two arrays, when both input arrays have the same
                    size and the same number of channels:
            </ul>

            <p><em>dst(I) = saturate(src1(I) - src2(I)) if mask(I) != 0</em></p>

            <ul>
                <li> Difference between an array and a scalar, when <code>src2</code> is
                    constructed from <code>Scalar</code> or has the same number of elements as
                    <code>src1.channels()</code>:
            </ul>

            <p><em>dst(I) = saturate(src1(I) - src2) if mask(I) != 0</em></p>

            <ul>
                <li> Difference between a scalar and an array, when <code>src1</code> is
                    constructed from <code>Scalar</code> or has the same number of elements as
                    <code>src2.channels()</code>:
            </ul>

            <p><em>dst(I) = saturate(src1 - src2(I)) if mask(I) != 0</em></p>

            <ul>
                <li> The reverse difference between a scalar and an array in the case of
                    <code>SubRS</code>:
            </ul>

            <p><em>dst(I) = saturate(src2 - src1(I)) if mask(I) != 0</em></p>

            <p>where <code>I</code> is a multi-dimensional index of array elements. In case
                of multi-channel arrays, each channel is processed independently.
                The first function in the list above can be replaced with matrix expressions:
                <code></p>

            <p>// C++ code:</p>

            <p>dst = src1 - src2;</p>

            <p>dst -= src1; // equivalent to subtract(dst, src1, dst);</p>

            <p>The input arrays and the output array can all have the same or different
                depths. For example, you can subtract to 8-bit unsigned arrays and store the
                difference in a 16-bit signed array. Depth of the output array is determined
                by <code>dtype</code> parameter. In the second and third cases above, as well
                as in the first case, when <code>src1.depth() == src2.depth()</code>,
                <code>dtype</code> can be set to the default <code>-1</code>. In this case
                the output array will have the same depth as the input array, be it
                <code>src1</code>, <code>src2</code> or both.
                </code></p>

            <p>Note: Saturation is not applied when the output array has the depth
                <code>CV_32S</code>. You may even get result of an incorrect sign in the case
                of overflow.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array or a scalar.</dd>
            <dd><code>src2</code> - second input array or a scalar.</dd>
            <dd><code>dst</code> - output array of the same size and the same number of channels as
                the input array.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#subtract">org.opencv.core.Core.subtract</a>,
                <a href="../../../org/opencv/core/Core.html#addWeighted(org.opencv.core.Mat, double, org.opencv.core.Mat, double, double, org.opencv.core.Mat, int)"><code>addWeighted(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, double, double, org.opencv.core.Mat,
                    int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#add(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>add(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#scaleAdd(org.opencv.core.Mat, double, org.opencv.core.Mat, org.opencv.core.Mat)"><code>scaleAdd(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Mat.html#convertTo(org.opencv.core.Mat, int, double, double)"><code>Mat.convertTo(org.opencv.core.Mat,
                    int, double, double)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="subtract(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>subtract</h4>
<pre>public static&nbsp;void&nbsp;subtract(<a href="../../../org/opencv/core/Mat.html"
                                              title="class in org.opencv.core">Mat</a>&nbsp;src1,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
        <div class="block"><p>Calculates the per-element difference between two arrays or array and
            a
            scalar.</p>

            <p>The function <code>subtract</code> calculates:</p>
            <ul>
                <li> Difference between two arrays, when both input arrays have the same
                    size and the same number of channels:
            </ul>

            <p><em>dst(I) = saturate(src1(I) - src2(I)) if mask(I) != 0</em></p>

            <ul>
                <li> Difference between an array and a scalar, when <code>src2</code> is
                    constructed from <code>Scalar</code> or has the same number of elements as
                    <code>src1.channels()</code>:
            </ul>

            <p><em>dst(I) = saturate(src1(I) - src2) if mask(I) != 0</em></p>

            <ul>
                <li> Difference between a scalar and an array, when <code>src1</code> is
                    constructed from <code>Scalar</code> or has the same number of elements as
                    <code>src2.channels()</code>:
            </ul>

            <p><em>dst(I) = saturate(src1 - src2(I)) if mask(I) != 0</em></p>

            <ul>
                <li> The reverse difference between a scalar and an array in the case of
                    <code>SubRS</code>:
            </ul>

            <p><em>dst(I) = saturate(src2 - src1(I)) if mask(I) != 0</em></p>

            <p>where <code>I</code> is a multi-dimensional index of array elements. In case
                of multi-channel arrays, each channel is processed independently.
                The first function in the list above can be replaced with matrix expressions:
                <code></p>

            <p>// C++ code:</p>

            <p>dst = src1 - src2;</p>

            <p>dst -= src1; // equivalent to subtract(dst, src1, dst);</p>

            <p>The input arrays and the output array can all have the same or different
                depths. For example, you can subtract to 8-bit unsigned arrays and store the
                difference in a 16-bit signed array. Depth of the output array is determined
                by <code>dtype</code> parameter. In the second and third cases above, as well
                as in the first case, when <code>src1.depth() == src2.depth()</code>,
                <code>dtype</code> can be set to the default <code>-1</code>. In this case
                the output array will have the same depth as the input array, be it
                <code>src1</code>, <code>src2</code> or both.
                </code></p>

            <p>Note: Saturation is not applied when the output array has the depth
                <code>CV_32S</code>. You may even get result of an incorrect sign in the case
                of overflow.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array or a scalar.</dd>
            <dd><code>src2</code> - second input array or a scalar.</dd>
            <dd><code>dst</code> - output array of the same size and the same number of channels as
                the input array.
            </dd>
            <dd><code>mask</code> - optional operation mask; this is an 8-bit single channel array
                that specifies elements of the output array to be changed.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#subtract">org.opencv.core.Core.subtract</a>,
                <a href="../../../org/opencv/core/Core.html#addWeighted(org.opencv.core.Mat, double, org.opencv.core.Mat, double, double, org.opencv.core.Mat, int)"><code>addWeighted(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, double, double, org.opencv.core.Mat,
                    int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#add(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>add(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#scaleAdd(org.opencv.core.Mat, double, org.opencv.core.Mat, org.opencv.core.Mat)"><code>scaleAdd(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Mat.html#convertTo(org.opencv.core.Mat, int, double, double)"><code>Mat.convertTo(org.opencv.core.Mat,
                    int, double, double)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="subtract(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>subtract</h4>
<pre>public static&nbsp;void&nbsp;subtract(<a href="../../../org/opencv/core/Mat.html"
                                              title="class in org.opencv.core">Mat</a>&nbsp;src1,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
            int&nbsp;dtype)</pre>
        <div class="block"><p>Calculates the per-element difference between two arrays or array and
            a
            scalar.</p>

            <p>The function <code>subtract</code> calculates:</p>
            <ul>
                <li> Difference between two arrays, when both input arrays have the same
                    size and the same number of channels:
            </ul>

            <p><em>dst(I) = saturate(src1(I) - src2(I)) if mask(I) != 0</em></p>

            <ul>
                <li> Difference between an array and a scalar, when <code>src2</code> is
                    constructed from <code>Scalar</code> or has the same number of elements as
                    <code>src1.channels()</code>:
            </ul>

            <p><em>dst(I) = saturate(src1(I) - src2) if mask(I) != 0</em></p>

            <ul>
                <li> Difference between a scalar and an array, when <code>src1</code> is
                    constructed from <code>Scalar</code> or has the same number of elements as
                    <code>src2.channels()</code>:
            </ul>

            <p><em>dst(I) = saturate(src1 - src2(I)) if mask(I) != 0</em></p>

            <ul>
                <li> The reverse difference between a scalar and an array in the case of
                    <code>SubRS</code>:
            </ul>

            <p><em>dst(I) = saturate(src2 - src1(I)) if mask(I) != 0</em></p>

            <p>where <code>I</code> is a multi-dimensional index of array elements. In case
                of multi-channel arrays, each channel is processed independently.
                The first function in the list above can be replaced with matrix expressions:
                <code></p>

            <p>// C++ code:</p>

            <p>dst = src1 - src2;</p>

            <p>dst -= src1; // equivalent to subtract(dst, src1, dst);</p>

            <p>The input arrays and the output array can all have the same or different
                depths. For example, you can subtract to 8-bit unsigned arrays and store the
                difference in a 16-bit signed array. Depth of the output array is determined
                by <code>dtype</code> parameter. In the second and third cases above, as well
                as in the first case, when <code>src1.depth() == src2.depth()</code>,
                <code>dtype</code> can be set to the default <code>-1</code>. In this case
                the output array will have the same depth as the input array, be it
                <code>src1</code>, <code>src2</code> or both.
                </code></p>

            <p>Note: Saturation is not applied when the output array has the depth
                <code>CV_32S</code>. You may even get result of an incorrect sign in the case
                of overflow.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array or a scalar.</dd>
            <dd><code>src2</code> - second input array or a scalar.</dd>
            <dd><code>dst</code> - output array of the same size and the same number of channels as
                the input array.
            </dd>
            <dd><code>mask</code> - optional operation mask; this is an 8-bit single channel array
                that specifies elements of the output array to be changed.
            </dd>
            <dd><code>dtype</code> - optional depth of the output array (see the details below).
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#subtract">org.opencv.core.Core.subtract</a>,
                <a href="../../../org/opencv/core/Core.html#addWeighted(org.opencv.core.Mat, double, org.opencv.core.Mat, double, double, org.opencv.core.Mat, int)"><code>addWeighted(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, double, double, org.opencv.core.Mat,
                    int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#add(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>add(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#scaleAdd(org.opencv.core.Mat, double, org.opencv.core.Mat, org.opencv.core.Mat)"><code>scaleAdd(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Mat.html#convertTo(org.opencv.core.Mat, int, double, double)"><code>Mat.convertTo(org.opencv.core.Mat,
                    int, double, double)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="subtract(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>subtract</h4>
<pre>public static&nbsp;void&nbsp;subtract(<a href="../../../org/opencv/core/Mat.html"
                                              title="class in org.opencv.core">Mat</a>&nbsp;src1,
            <a href="../../../org/opencv/core/Scalar.html"
               title="class in org.opencv.core">Scalar</a>&nbsp;src2,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Calculates the per-element difference between two arrays or array and
            a
            scalar.</p>

            <p>The function <code>subtract</code> calculates:</p>
            <ul>
                <li> Difference between two arrays, when both input arrays have the same
                    size and the same number of channels:
            </ul>

            <p><em>dst(I) = saturate(src1(I) - src2(I)) if mask(I) != 0</em></p>

            <ul>
                <li> Difference between an array and a scalar, when <code>src2</code> is
                    constructed from <code>Scalar</code> or has the same number of elements as
                    <code>src1.channels()</code>:
            </ul>

            <p><em>dst(I) = saturate(src1(I) - src2) if mask(I) != 0</em></p>

            <ul>
                <li> Difference between a scalar and an array, when <code>src1</code> is
                    constructed from <code>Scalar</code> or has the same number of elements as
                    <code>src2.channels()</code>:
            </ul>

            <p><em>dst(I) = saturate(src1 - src2(I)) if mask(I) != 0</em></p>

            <ul>
                <li> The reverse difference between a scalar and an array in the case of
                    <code>SubRS</code>:
            </ul>

            <p><em>dst(I) = saturate(src2 - src1(I)) if mask(I) != 0</em></p>

            <p>where <code>I</code> is a multi-dimensional index of array elements. In case
                of multi-channel arrays, each channel is processed independently.
                The first function in the list above can be replaced with matrix expressions:
                <code></p>

            <p>// C++ code:</p>

            <p>dst = src1 - src2;</p>

            <p>dst -= src1; // equivalent to subtract(dst, src1, dst);</p>

            <p>The input arrays and the output array can all have the same or different
                depths. For example, you can subtract to 8-bit unsigned arrays and store the
                difference in a 16-bit signed array. Depth of the output array is determined
                by <code>dtype</code> parameter. In the second and third cases above, as well
                as in the first case, when <code>src1.depth() == src2.depth()</code>,
                <code>dtype</code> can be set to the default <code>-1</code>. In this case
                the output array will have the same depth as the input array, be it
                <code>src1</code>, <code>src2</code> or both.
                </code></p>

            <p>Note: Saturation is not applied when the output array has the depth
                <code>CV_32S</code>. You may even get result of an incorrect sign in the case
                of overflow.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array or a scalar.</dd>
            <dd><code>src2</code> - second input array or a scalar.</dd>
            <dd><code>dst</code> - output array of the same size and the same number of channels as
                the input array.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#subtract">org.opencv.core.Core.subtract</a>,
                <a href="../../../org/opencv/core/Core.html#addWeighted(org.opencv.core.Mat, double, org.opencv.core.Mat, double, double, org.opencv.core.Mat, int)"><code>addWeighted(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, double, double, org.opencv.core.Mat,
                    int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#add(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>add(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#scaleAdd(org.opencv.core.Mat, double, org.opencv.core.Mat, org.opencv.core.Mat)"><code>scaleAdd(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Mat.html#convertTo(org.opencv.core.Mat, int, double, double)"><code>Mat.convertTo(org.opencv.core.Mat,
                    int, double, double)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="subtract(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>subtract</h4>
<pre>public static&nbsp;void&nbsp;subtract(<a href="../../../org/opencv/core/Mat.html"
                                              title="class in org.opencv.core">Mat</a>&nbsp;src1,
            <a href="../../../org/opencv/core/Scalar.html"
               title="class in org.opencv.core">Scalar</a>&nbsp;src2,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
        <div class="block"><p>Calculates the per-element difference between two arrays or array and
            a
            scalar.</p>

            <p>The function <code>subtract</code> calculates:</p>
            <ul>
                <li> Difference between two arrays, when both input arrays have the same
                    size and the same number of channels:
            </ul>

            <p><em>dst(I) = saturate(src1(I) - src2(I)) if mask(I) != 0</em></p>

            <ul>
                <li> Difference between an array and a scalar, when <code>src2</code> is
                    constructed from <code>Scalar</code> or has the same number of elements as
                    <code>src1.channels()</code>:
            </ul>

            <p><em>dst(I) = saturate(src1(I) - src2) if mask(I) != 0</em></p>

            <ul>
                <li> Difference between a scalar and an array, when <code>src1</code> is
                    constructed from <code>Scalar</code> or has the same number of elements as
                    <code>src2.channels()</code>:
            </ul>

            <p><em>dst(I) = saturate(src1 - src2(I)) if mask(I) != 0</em></p>

            <ul>
                <li> The reverse difference between a scalar and an array in the case of
                    <code>SubRS</code>:
            </ul>

            <p><em>dst(I) = saturate(src2 - src1(I)) if mask(I) != 0</em></p>

            <p>where <code>I</code> is a multi-dimensional index of array elements. In case
                of multi-channel arrays, each channel is processed independently.
                The first function in the list above can be replaced with matrix expressions:
                <code></p>

            <p>// C++ code:</p>

            <p>dst = src1 - src2;</p>

            <p>dst -= src1; // equivalent to subtract(dst, src1, dst);</p>

            <p>The input arrays and the output array can all have the same or different
                depths. For example, you can subtract to 8-bit unsigned arrays and store the
                difference in a 16-bit signed array. Depth of the output array is determined
                by <code>dtype</code> parameter. In the second and third cases above, as well
                as in the first case, when <code>src1.depth() == src2.depth()</code>,
                <code>dtype</code> can be set to the default <code>-1</code>. In this case
                the output array will have the same depth as the input array, be it
                <code>src1</code>, <code>src2</code> or both.
                </code></p>

            <p>Note: Saturation is not applied when the output array has the depth
                <code>CV_32S</code>. You may even get result of an incorrect sign in the case
                of overflow.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array or a scalar.</dd>
            <dd><code>src2</code> - second input array or a scalar.</dd>
            <dd><code>dst</code> - output array of the same size and the same number of channels as
                the input array.
            </dd>
            <dd><code>mask</code> - optional operation mask; this is an 8-bit single channel array
                that specifies elements of the output array to be changed.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#subtract">org.opencv.core.Core.subtract</a>,
                <a href="../../../org/opencv/core/Core.html#addWeighted(org.opencv.core.Mat, double, org.opencv.core.Mat, double, double, org.opencv.core.Mat, int)"><code>addWeighted(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, double, double, org.opencv.core.Mat,
                    int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#add(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>add(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#scaleAdd(org.opencv.core.Mat, double, org.opencv.core.Mat, org.opencv.core.Mat)"><code>scaleAdd(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Mat.html#convertTo(org.opencv.core.Mat, int, double, double)"><code>Mat.convertTo(org.opencv.core.Mat,
                    int, double, double)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="subtract(org.opencv.core.Mat, org.opencv.core.Scalar, org.opencv.core.Mat, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>subtract</h4>
<pre>public static&nbsp;void&nbsp;subtract(<a href="../../../org/opencv/core/Mat.html"
                                              title="class in org.opencv.core">Mat</a>&nbsp;src1,
            <a href="../../../org/opencv/core/Scalar.html"
               title="class in org.opencv.core">Scalar</a>&nbsp;src2,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
            int&nbsp;dtype)</pre>
        <div class="block"><p>Calculates the per-element difference between two arrays or array and
            a
            scalar.</p>

            <p>The function <code>subtract</code> calculates:</p>
            <ul>
                <li> Difference between two arrays, when both input arrays have the same
                    size and the same number of channels:
            </ul>

            <p><em>dst(I) = saturate(src1(I) - src2(I)) if mask(I) != 0</em></p>

            <ul>
                <li> Difference between an array and a scalar, when <code>src2</code> is
                    constructed from <code>Scalar</code> or has the same number of elements as
                    <code>src1.channels()</code>:
            </ul>

            <p><em>dst(I) = saturate(src1(I) - src2) if mask(I) != 0</em></p>

            <ul>
                <li> Difference between a scalar and an array, when <code>src1</code> is
                    constructed from <code>Scalar</code> or has the same number of elements as
                    <code>src2.channels()</code>:
            </ul>

            <p><em>dst(I) = saturate(src1 - src2(I)) if mask(I) != 0</em></p>

            <ul>
                <li> The reverse difference between a scalar and an array in the case of
                    <code>SubRS</code>:
            </ul>

            <p><em>dst(I) = saturate(src2 - src1(I)) if mask(I) != 0</em></p>

            <p>where <code>I</code> is a multi-dimensional index of array elements. In case
                of multi-channel arrays, each channel is processed independently.
                The first function in the list above can be replaced with matrix expressions:
                <code></p>

            <p>// C++ code:</p>

            <p>dst = src1 - src2;</p>

            <p>dst -= src1; // equivalent to subtract(dst, src1, dst);</p>

            <p>The input arrays and the output array can all have the same or different
                depths. For example, you can subtract to 8-bit unsigned arrays and store the
                difference in a 16-bit signed array. Depth of the output array is determined
                by <code>dtype</code> parameter. In the second and third cases above, as well
                as in the first case, when <code>src1.depth() == src2.depth()</code>,
                <code>dtype</code> can be set to the default <code>-1</code>. In this case
                the output array will have the same depth as the input array, be it
                <code>src1</code>, <code>src2</code> or both.
                </code></p>

            <p>Note: Saturation is not applied when the output array has the depth
                <code>CV_32S</code>. You may even get result of an incorrect sign in the case
                of overflow.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - first input array or a scalar.</dd>
            <dd><code>src2</code> - second input array or a scalar.</dd>
            <dd><code>dst</code> - output array of the same size and the same number of channels as
                the input array.
            </dd>
            <dd><code>mask</code> - optional operation mask; this is an 8-bit single channel array
                that specifies elements of the output array to be changed.
            </dd>
            <dd><code>dtype</code> - optional depth of the output array (see the details below).
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#subtract">org.opencv.core.Core.subtract</a>,
                <a href="../../../org/opencv/core/Core.html#addWeighted(org.opencv.core.Mat, double, org.opencv.core.Mat, double, double, org.opencv.core.Mat, int)"><code>addWeighted(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, double, double, org.opencv.core.Mat,
                    int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#add(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>add(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#scaleAdd(org.opencv.core.Mat, double, org.opencv.core.Mat, org.opencv.core.Mat)"><code>scaleAdd(org.opencv.core.Mat,
                    double, org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Mat.html#convertTo(org.opencv.core.Mat, int, double, double)"><code>Mat.convertTo(org.opencv.core.Mat,
                    int, double, double)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="sumElems(org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>sumElems</h4>
        <pre>public static&nbsp;<a href="../../../org/opencv/core/Scalar.html"
                                   title="class in org.opencv.core">Scalar</a>&nbsp;sumElems(<a
                href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src)</pre>
        <div class="block"><p>Calculates the sum of array elements.</p>

            <p>The functions <code>sum</code> calculate and return the sum of array
                elements, independently for each channel.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - a src</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#sum">org.opencv.core.Core.sum</a>,
                <a href="../../../org/opencv/core/Core.html#meanStdDev(org.opencv.core.Mat, org.opencv.core.MatOfDouble, org.opencv.core.MatOfDouble, org.opencv.core.Mat)"><code>meanStdDev(org.opencv.core.Mat,
                    org.opencv.core.MatOfDouble, org.opencv.core.MatOfDouble,
                    org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#reduce(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int)"><code>reduce(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#minMaxLoc(org.opencv.core.Mat, org.opencv.core.Mat)"><code>minMaxLoc(org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#countNonZero(org.opencv.core.Mat)"><code>countNonZero(org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#norm(org.opencv.core.Mat, int, org.opencv.core.Mat)"><code>norm(org.opencv.core.Mat,
                    int, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#mean(org.opencv.core.Mat, org.opencv.core.Mat)"><code>mean(org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="SVBackSubst(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>SVBackSubst</h4>
<pre>public static&nbsp;void&nbsp;SVBackSubst(<a href="../../../org/opencv/core/Mat.html"
                                                 title="class in org.opencv.core">Mat</a>&nbsp;w,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;u,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vt,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rhs,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
    </li>
</ul>
<a name="SVDecomp(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>SVDecomp</h4>
<pre>public static&nbsp;void&nbsp;SVDecomp(<a href="../../../org/opencv/core/Mat.html"
                                              title="class in org.opencv.core">Mat</a>&nbsp;src,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;w,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;u,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vt)</pre>
    </li>
</ul>
<a name="SVDecomp(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>SVDecomp</h4>
<pre>public static&nbsp;void&nbsp;SVDecomp(<a href="../../../org/opencv/core/Mat.html"
                                              title="class in org.opencv.core">Mat</a>&nbsp;src,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;w,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;u,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vt,
            int&nbsp;flags)</pre>
    </li>
</ul>
<a name="trace(org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>trace</h4>
        <pre>public static&nbsp;<a href="../../../org/opencv/core/Scalar.html"
                                   title="class in org.opencv.core">Scalar</a>&nbsp;trace(<a
                href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mtx)</pre>
        <div class="block"><p>Returns the trace of a matrix.</p>

            <p>The function <code>trace</code> returns the sum of the diagonal elements of
                the matrix <code>mtx</code>.</p>

            <p><em>tr(mtx) = sum _i mtx(i,i)</em></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>mtx</code> - a mtx</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#trace">org.opencv.core.Core.trace</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="transform(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>transform</h4>
<pre>public static&nbsp;void&nbsp;transform(<a href="../../../org/opencv/core/Mat.html"
                                               title="class in org.opencv.core">Mat</a>&nbsp;src,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;m)</pre>
        <div class="block"><p>Performs the matrix transformation of every array element.</p>

            <p>The function <code>transform</code> performs the matrix transformation of
                every element of the array <code>src</code> and stores the results in
                <code>dst</code> :</p>

            <p><em>dst(I) = m * src(I)</em></p>

            <p>(when <code>m.cols=src.channels()</code>), or</p>

            <p><em>dst(I) = m * [ src(I); 1]</em></p>

            <p>(when <code>m.cols=src.channels()+1</code>)</p>

            <p>Every element of the <code>N</code> -channel array <code>src</code> is
                interpreted as <code>N</code> -element vector that is transformed using the
                <code>M x N</code> or <code>M x (N+1)</code> matrix <code>m</code> to
                <code>M</code>-element vector - the corresponding element of the output array
                <code>dst</code>.</p>

            <p>The function may be used for geometrical transformation of <code>N</code>
                -dimensional points, arbitrary linear color space transformation (such as
                various kinds of RGB to YUV transforms), shuffling the image channels, and so
                forth.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input array that must have as many channels (1 to 4) as
                <code>m.cols</code> or <code>m.cols-1</code>.
            </dd>
            <dd><code>dst</code> - output array of the same size and depth as <code>src</code>; it
                has as many channels as <code>m.rows</code>.
            </dd>
            <dd><code>m</code> - transformation <code>2x2</code> or <code>2x3</code> floating-point
                matrix.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#transform">org.opencv.core.Core.transform</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#warpAffine(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int, org.opencv.core.Scalar)"><code>Imgproc.warpAffine(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/core/Core.html#perspectiveTransform(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>perspectiveTransform(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#warpPerspective(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int, org.opencv.core.Scalar)"><code>Imgproc.warpPerspective(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#getAffineTransform(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f)"><code>Imgproc.getAffineTransform(org.opencv.core.MatOfPoint2f,
                    org.opencv.core.MatOfPoint2f)</code></a>,
                <a href="../../../org/opencv/video/Video.html#estimateRigidTransform(org.opencv.core.Mat, org.opencv.core.Mat, boolean)"><code>Video.estimateRigidTransform(org.opencv.core.Mat,
                    org.opencv.core.Mat, boolean)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="transpose(org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>transpose</h4>
<pre>public static&nbsp;void&nbsp;transpose(<a href="../../../org/opencv/core/Mat.html"
                                               title="class in org.opencv.core">Mat</a>&nbsp;src,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Transposes a matrix.</p>

            <p>The function "transpose" transposes the matrix <code>src</code> :</p>

            <p><em>dst(i,j) = src(j,i)</em></p>

            <p>Note: No complex conjugation is done in case of a complex matrix. It it
                should be done separately if needed.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input array.</dd>
            <dd><code>dst</code> - output array of the same type as <code>src</code>.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#transpose">org.opencv.core.Core.transpose</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="vconcat(java.util.List, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockListLast">
    <li class="blockList">
        <h4>vconcat</h4>
<pre>public static&nbsp;void&nbsp;vconcat(java.util.List&lt;<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;src,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
    </li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
    <!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a
        name="navbar_bottom_firstrow">
    <!--   -->
</a>
    <ul class="navList" title="Navigation">
        <li><a href="../../../overview-summary.html">Overview</a></li>
        <li><a href="package-summary.html">Package</a></li>
        <li class="navBarCell1Rev">Class</li>
        <li><a href="package-tree.html">Tree</a></li>
        <li><a href="../../../index-all.html">Index</a></li>
        <li><a href="../../../help-doc.html">Help</a></li>
    </ul>
    <div class="aboutLanguage"><em><a href=http://docs.opencv.org>OpenCV 2.4.11
        Documentation</a></em></div>
</div>
<div class="subNav">
    <ul class="navList">
        <li><a href="../../../org/opencv/core/Algorithm.html" title="class in org.opencv.core"><span
                class="strong">PREV CLASS</span></a></li>
        <li><a href="../../../org/opencv/core/Core.MinMaxLocResult.html"
               title="class in org.opencv.core"><span class="strong">NEXT CLASS</span></a></li>
    </ul>
    <ul class="navList">
        <li><a href="../../../index.html?org/opencv/core/Core.html" target="_top">FRAMES</a></li>
        <li><a href="Core.html" target="_top">NO FRAMES</a></li>
    </ul>
    <ul class="navList" id="allclasses_navbar_bottom">
        <li><a href="../../../allclasses-noframe.html">All Classes</a></li>
    </ul>
    <div>
        <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->

        </script>
    </div>
    <div>
        <ul class="subNavList">
            <li>SUMMARY:&nbsp;</li>
            <li><a href="#nested_class_summary">NESTED</a>&nbsp;|&nbsp;</li>
            <li><a href="#field_summary">FIELD</a>&nbsp;|&nbsp;</li>
            <li><a href="#constructor_summary">CONSTR</a>&nbsp;|&nbsp;</li>
            <li><a href="#method_summary">METHOD</a></li>
        </ul>
        <ul class="subNavList">
            <li>DETAIL:&nbsp;</li>
            <li><a href="#field_detail">FIELD</a>&nbsp;|&nbsp;</li>
            <li><a href="#constructor_detail">CONSTR</a>&nbsp;|&nbsp;</li>
            <li><a href="#method_detail">METHOD</a></li>
        </ul>
    </div>
    <a name="skip-navbar_bottom">
        <!--   -->
    </a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
