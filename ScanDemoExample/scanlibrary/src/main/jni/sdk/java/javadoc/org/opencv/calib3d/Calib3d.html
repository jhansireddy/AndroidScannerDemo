<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
    <!-- Generated by javadoc (version 1.6.0_34) on Wed Mar 04 17:44:04 MSK 2015 -->
    <title>Calib3d</title>
    <meta name="date" content="2015-03-04">
    <link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Calib3d";
    }
//-->

</script>
<noscript>
    <div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
    <!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
    <!--   -->
</a>
    <ul class="navList" title="Navigation">
        <li><a href="../../../overview-summary.html">Overview</a></li>
        <li><a href="package-summary.html">Package</a></li>
        <li class="navBarCell1Rev">Class</li>
        <li><a href="package-tree.html">Tree</a></li>
        <li><a href="../../../index-all.html">Index</a></li>
        <li><a href="../../../help-doc.html">Help</a></li>
    </ul>
    <div class="aboutLanguage"><em>OpenCV 2.4.11</em></div>
</div>
<div class="subNav">
    <ul class="navList">
        <li>PREV CLASS</li>
        <li><a href="../../../org/opencv/calib3d/StereoBM.html" title="class in org.opencv.calib3d"><span
                class="strong">NEXT CLASS</span></a></li>
    </ul>
    <ul class="navList">
        <li><a href="../../../index.html?org/opencv/calib3d/Calib3d.html" target="_top">FRAMES</a>
        </li>
        <li><a href="Calib3d.html" target="_top">NO FRAMES</a></li>
    </ul>
    <ul class="navList" id="allclasses_navbar_top">
        <li><a href="../../../allclasses-noframe.html">All Classes</a></li>
    </ul>
    <div>
        <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->

        </script>
    </div>
    <div>
        <ul class="subNavList">
            <li>SUMMARY:&nbsp;</li>
            <li>NESTED&nbsp;|&nbsp;</li>
            <li><a href="#field_summary">FIELD</a>&nbsp;|&nbsp;</li>
            <li><a href="#constructor_summary">CONSTR</a>&nbsp;|&nbsp;</li>
            <li><a href="#method_summary">METHOD</a></li>
        </ul>
        <ul class="subNavList">
            <li>DETAIL:&nbsp;</li>
            <li><a href="#field_detail">FIELD</a>&nbsp;|&nbsp;</li>
            <li><a href="#constructor_detail">CONSTR</a>&nbsp;|&nbsp;</li>
            <li><a href="#method_detail">METHOD</a></li>
        </ul>
    </div>
    <a name="skip-navbar_top">
        <!--   -->
    </a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
    <p class="subTitle">org.opencv.calib3d</p>

    <h2 title="Class Calib3d" class="title">Class Calib3d</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
    <li>java.lang.Object</li>
    <li>
        <ul class="inheritance">
            <li>org.opencv.calib3d.Calib3d</li>
        </ul>
    </li>
</ul>
<div class="description">
    <ul class="blockList">
        <li class="blockList">
            <hr>
            <br>
<pre>public class <strong>Calib3d</strong>
extends java.lang.Object</pre>
        </li>
    </ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
    <li class="blockList"><a name="field_summary">
        <!--   -->
    </a>

        <h3>Field Summary</h3>
        <table class="overviewSummary" border="0" cellpadding="3" cellspacing="0"
               summary="Field Summary table, listing fields, and an explanation">
            <caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
            <tr>
                <th class="colFirst" scope="col">Modifier and Type</th>
                <th class="colLast" scope="col">Field and Description</th>
            </tr>
            <tr class="altColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/calib3d/Calib3d.html#CALIB_CB_ADAPTIVE_THRESH">CALIB_CB_ADAPTIVE_THRESH</a></strong></code>&nbsp;
                </td>
            </tr>
            <tr class="rowColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/calib3d/Calib3d.html#CALIB_CB_ASYMMETRIC_GRID">CALIB_CB_ASYMMETRIC_GRID</a></strong></code>&nbsp;
                </td>
            </tr>
            <tr class="altColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/calib3d/Calib3d.html#CALIB_CB_CLUSTERING">CALIB_CB_CLUSTERING</a></strong></code>&nbsp;
                </td>
            </tr>
            <tr class="rowColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/calib3d/Calib3d.html#CALIB_CB_FAST_CHECK">CALIB_CB_FAST_CHECK</a></strong></code>&nbsp;
                </td>
            </tr>
            <tr class="altColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/calib3d/Calib3d.html#CALIB_CB_FILTER_QUADS">CALIB_CB_FILTER_QUADS</a></strong></code>&nbsp;
                </td>
            </tr>
            <tr class="rowColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/calib3d/Calib3d.html#CALIB_CB_NORMALIZE_IMAGE">CALIB_CB_NORMALIZE_IMAGE</a></strong></code>&nbsp;
                </td>
            </tr>
            <tr class="altColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/calib3d/Calib3d.html#CALIB_CB_SYMMETRIC_GRID">CALIB_CB_SYMMETRIC_GRID</a></strong></code>&nbsp;
                </td>
            </tr>
            <tr class="rowColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/calib3d/Calib3d.html#CALIB_FIX_ASPECT_RATIO">CALIB_FIX_ASPECT_RATIO</a></strong></code>&nbsp;
                </td>
            </tr>
            <tr class="altColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/calib3d/Calib3d.html#CALIB_FIX_FOCAL_LENGTH">CALIB_FIX_FOCAL_LENGTH</a></strong></code>&nbsp;
                </td>
            </tr>
            <tr class="rowColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/calib3d/Calib3d.html#CALIB_FIX_INTRINSIC">CALIB_FIX_INTRINSIC</a></strong></code>&nbsp;
                </td>
            </tr>
            <tr class="altColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/calib3d/Calib3d.html#CALIB_FIX_K1">CALIB_FIX_K1</a></strong></code>&nbsp;
                </td>
            </tr>
            <tr class="rowColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/calib3d/Calib3d.html#CALIB_FIX_K2">CALIB_FIX_K2</a></strong></code>&nbsp;
                </td>
            </tr>
            <tr class="altColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/calib3d/Calib3d.html#CALIB_FIX_K3">CALIB_FIX_K3</a></strong></code>&nbsp;
                </td>
            </tr>
            <tr class="rowColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/calib3d/Calib3d.html#CALIB_FIX_K4">CALIB_FIX_K4</a></strong></code>&nbsp;
                </td>
            </tr>
            <tr class="altColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/calib3d/Calib3d.html#CALIB_FIX_K5">CALIB_FIX_K5</a></strong></code>&nbsp;
                </td>
            </tr>
            <tr class="rowColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/calib3d/Calib3d.html#CALIB_FIX_K6">CALIB_FIX_K6</a></strong></code>&nbsp;
                </td>
            </tr>
            <tr class="altColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/calib3d/Calib3d.html#CALIB_FIX_PRINCIPAL_POINT">CALIB_FIX_PRINCIPAL_POINT</a></strong></code>&nbsp;
                </td>
            </tr>
            <tr class="rowColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/calib3d/Calib3d.html#CALIB_RATIONAL_MODEL">CALIB_RATIONAL_MODEL</a></strong></code>&nbsp;
                </td>
            </tr>
            <tr class="altColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/calib3d/Calib3d.html#CALIB_SAME_FOCAL_LENGTH">CALIB_SAME_FOCAL_LENGTH</a></strong></code>&nbsp;
                </td>
            </tr>
            <tr class="rowColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/calib3d/Calib3d.html#CALIB_USE_INTRINSIC_GUESS">CALIB_USE_INTRINSIC_GUESS</a></strong></code>&nbsp;
                </td>
            </tr>
            <tr class="altColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/calib3d/Calib3d.html#CALIB_ZERO_DISPARITY">CALIB_ZERO_DISPARITY</a></strong></code>&nbsp;
                </td>
            </tr>
            <tr class="rowColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/calib3d/Calib3d.html#CALIB_ZERO_TANGENT_DIST">CALIB_ZERO_TANGENT_DIST</a></strong></code>&nbsp;
                </td>
            </tr>
            <tr class="altColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/calib3d/Calib3d.html#CV_EPNP">CV_EPNP</a></strong></code>&nbsp;
                </td>
            </tr>
            <tr class="rowColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/calib3d/Calib3d.html#CV_ITERATIVE">CV_ITERATIVE</a></strong></code>&nbsp;
                </td>
            </tr>
            <tr class="altColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/calib3d/Calib3d.html#CV_P3P">CV_P3P</a></strong></code>&nbsp;
                </td>
            </tr>
            <tr class="rowColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/calib3d/Calib3d.html#EPNP">EPNP</a></strong></code>&nbsp;
                </td>
            </tr>
            <tr class="altColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/calib3d/Calib3d.html#FM_7POINT">FM_7POINT</a></strong></code>&nbsp;
                </td>
            </tr>
            <tr class="rowColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/calib3d/Calib3d.html#FM_8POINT">FM_8POINT</a></strong></code>&nbsp;
                </td>
            </tr>
            <tr class="altColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/calib3d/Calib3d.html#FM_LMEDS">FM_LMEDS</a></strong></code>&nbsp;
                </td>
            </tr>
            <tr class="rowColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/calib3d/Calib3d.html#FM_RANSAC">FM_RANSAC</a></strong></code>&nbsp;
                </td>
            </tr>
            <tr class="altColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/calib3d/Calib3d.html#ITERATIVE">ITERATIVE</a></strong></code>&nbsp;
                </td>
            </tr>
            <tr class="rowColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/calib3d/Calib3d.html#LMEDS">LMEDS</a></strong></code>&nbsp;
                </td>
            </tr>
            <tr class="altColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/calib3d/Calib3d.html#P3P">P3P</a></strong></code>&nbsp;
                </td>
            </tr>
            <tr class="rowColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/calib3d/Calib3d.html#RANSAC">RANSAC</a></strong></code>&nbsp;
                </td>
            </tr>
        </table>
    </li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
    <li class="blockList"><a name="constructor_summary">
        <!--   -->
    </a>

        <h3>Constructor Summary</h3>
        <table class="overviewSummary" border="0" cellpadding="3" cellspacing="0"
               summary="Constructor Summary table, listing constructors, and an explanation">
            <caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
            <tr>
                <th class="colOne" scope="col">Constructor and Description</th>
            </tr>
            <tr class="altColor">
                <td class="colOne"><code><strong><a
                        href="../../../org/opencv/calib3d/Calib3d.html#Calib3d()">Calib3d</a></strong>()</code>&nbsp;
                </td>
            </tr>
        </table>
    </li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
    <!--   -->
</a>

<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0"
       summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
    <th class="colFirst" scope="col">Modifier and Type</th>
    <th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static double</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#calibrateCamera(java.util.List, java.util.List, org.opencv.core.Size, org.opencv.core.Mat, org.opencv.core.Mat, java.util.List, java.util.List)">calibrateCamera</a></strong>(java.util.List&lt;<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;objectPoints,
        java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                             title="class in org.opencv.core">Mat</a>&gt;&nbsp;imagePoints,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imageSize,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
        java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                             title="class in org.opencv.core">Mat</a>&gt;&nbsp;rvecs,
        java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                             title="class in org.opencv.core">Mat</a>&gt;&nbsp;tvecs)</code>

        <div class="block">Finds the camera intrinsic and extrinsic parameters from several views of
            a
            calibration pattern.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static double</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#calibrateCamera(java.util.List, java.util.List, org.opencv.core.Size, org.opencv.core.Mat, org.opencv.core.Mat, java.util.List, java.util.List, int)">calibrateCamera</a></strong>(java.util.List&lt;<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;objectPoints,
        java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                             title="class in org.opencv.core">Mat</a>&gt;&nbsp;imagePoints,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imageSize,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
        java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                             title="class in org.opencv.core">Mat</a>&gt;&nbsp;rvecs,
        java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                             title="class in org.opencv.core">Mat</a>&gt;&nbsp;tvecs,
        int&nbsp;flags)</code>

        <div class="block">Finds the camera intrinsic and extrinsic parameters from several views of
            a
            calibration pattern.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static double</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#calibrateCamera(java.util.List, java.util.List, org.opencv.core.Size, org.opencv.core.Mat, org.opencv.core.Mat, java.util.List, java.util.List, int, org.opencv.core.TermCriteria)">calibrateCamera</a></strong>(java.util.List&lt;<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;objectPoints,
        java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                             title="class in org.opencv.core">Mat</a>&gt;&nbsp;imagePoints,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imageSize,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
        java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                             title="class in org.opencv.core">Mat</a>&gt;&nbsp;rvecs,
        java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                             title="class in org.opencv.core">Mat</a>&gt;&nbsp;tvecs,
        int&nbsp;flags,
        <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria)</code>

        <div class="block">Finds the camera intrinsic and extrinsic parameters from several views of
            a
            calibration pattern.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#calibrationMatrixValues(org.opencv.core.Mat, org.opencv.core.Size, double, double, double[], double[], double[], org.opencv.core.Point, double[])">calibrationMatrixValues</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imageSize,
        double&nbsp;apertureWidth,
        double&nbsp;apertureHeight,
        double[]&nbsp;fovx,
        double[]&nbsp;fovy,
        double[]&nbsp;focalLength,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;principalPoint,
        double[]&nbsp;aspectRatio)</code>

        <div class="block">Computes useful camera characteristics from the camera matrix.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#composeRT(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">composeRT</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec3,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec3)</code>

        <div class="block">Combines two rotation-and-shift transformations.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#composeRT(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">composeRT</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec3,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec3,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dr1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dt1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dr2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dt2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dt3dr1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dt3dt1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dt3dr2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dt3dt2)</code>

        <div class="block">Combines two rotation-and-shift transformations.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#computeCorrespondEpilines(org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Mat)">computeCorrespondEpilines</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points,
        int&nbsp;whichImage,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;F,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines)</code>

        <div class="block">For points in an image of a stereo pair, computes the corresponding
            epilines
            in the other image.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#convertPointsFromHomogeneous(org.opencv.core.Mat, org.opencv.core.Mat)">convertPointsFromHomogeneous</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Converts points from homogeneous to Euclidean space.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#convertPointsToHomogeneous(org.opencv.core.Mat, org.opencv.core.Mat)">convertPointsToHomogeneous</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Converts points from Euclidean to homogeneous space.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#correctMatches(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">correctMatches</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;F,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;newPoints1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;newPoints2)</code>

        <div class="block">Refines coordinates of corresponding points.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#decomposeProjectionMatrix(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">decomposeProjectionMatrix</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;projMatrix,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rotMatrix,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;transVect)</code>

        <div class="block">Decomposes a projection matrix into a rotation matrix and a camera
            matrix.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#decomposeProjectionMatrix(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">decomposeProjectionMatrix</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;projMatrix,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rotMatrix,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;transVect,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rotMatrixX,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rotMatrixY,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rotMatrixZ,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eulerAngles)</code>

        <div class="block">Decomposes a projection matrix into a rotation matrix and a camera
            matrix.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#drawChessboardCorners(org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.MatOfPoint2f, boolean)">drawChessboardCorners</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;patternSize,
        <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;corners,
        boolean&nbsp;patternWasFound)</code>

        <div class="block">Renders the detected chessboard corners.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#estimateAffine3D(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">estimateAffine3D</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;out,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers)</code>

        <div class="block">Computes an optimal affine transformation between two 3D point sets.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#estimateAffine3D(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, double)">estimateAffine3D</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;out,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers,
        double&nbsp;ransacThreshold,
        double&nbsp;confidence)</code>

        <div class="block">Computes an optimal affine transformation between two 3D point sets.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#filterSpeckles(org.opencv.core.Mat, double, int, double)">filterSpeckles</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
        double&nbsp;newVal,
        int&nbsp;maxSpeckleSize,
        double&nbsp;maxDiff)</code>

        <div class="block">Filters off small noise blobs (speckles) in the disparity map</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#filterSpeckles(org.opencv.core.Mat, double, int, double, org.opencv.core.Mat)">filterSpeckles</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
        double&nbsp;newVal,
        int&nbsp;maxSpeckleSize,
        double&nbsp;maxDiff,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;buf)</code>

        <div class="block">Filters off small noise blobs (speckles) in the disparity map</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static boolean</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#findChessboardCorners(org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.MatOfPoint2f)">findChessboardCorners</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;patternSize,
        <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;corners)</code>

        <div class="block">Finds the positions of internal corners of the chessboard.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static boolean</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#findChessboardCorners(org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.MatOfPoint2f, int)">findChessboardCorners</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;patternSize,
        <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;corners,
        int&nbsp;flags)</code>

        <div class="block">Finds the positions of internal corners of the chessboard.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static boolean</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#findCirclesGridDefault(org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Mat)">findCirclesGridDefault</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;patternSize,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;centers)</code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static boolean</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#findCirclesGridDefault(org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Mat, int)">findCirclesGridDefault</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;patternSize,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;centers,
        int&nbsp;flags)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#findFundamentalMat(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f)">findFundamentalMat</a></strong>(<a
            href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points1,
        <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points2)</code>

        <div class="block">Calculates a fundamental matrix from the corresponding points in two
            images.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#findFundamentalMat(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, int, double, double)">findFundamentalMat</a></strong>(<a
            href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points1,
        <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points2,
        int&nbsp;method,
        double&nbsp;param1,
        double&nbsp;param2)</code>

        <div class="block">Calculates a fundamental matrix from the corresponding points in two
            images.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#findFundamentalMat(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, int, double, double, org.opencv.core.Mat)">findFundamentalMat</a></strong>(<a
            href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points1,
        <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points2,
        int&nbsp;method,
        double&nbsp;param1,
        double&nbsp;param2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>

        <div class="block">Calculates a fundamental matrix from the corresponding points in two
            images.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#findHomography(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f)">findHomography</a></strong>(<a
            href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;srcPoints,
        <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;dstPoints)</code>

        <div class="block">Finds a perspective transformation between two planes.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#findHomography(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, int, double)">findHomography</a></strong>(<a
            href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;srcPoints,
        <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;dstPoints,
        int&nbsp;method,
        double&nbsp;ransacReprojThreshold)</code>

        <div class="block">Finds a perspective transformation between two planes.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#findHomography(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, int, double, org.opencv.core.Mat)">findHomography</a></strong>(<a
            href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;srcPoints,
        <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;dstPoints,
        int&nbsp;method,
        double&nbsp;ransacReprojThreshold,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>

        <div class="block">Finds a perspective transformation between two planes.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#getOptimalNewCameraMatrix(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double)">getOptimalNewCameraMatrix</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imageSize,
        double&nbsp;alpha)</code>

        <div class="block">Returns the new camera matrix based on the free scaling parameter.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#getOptimalNewCameraMatrix(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double, org.opencv.core.Size, org.opencv.core.Rect, boolean)">getOptimalNewCameraMatrix</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imageSize,
        double&nbsp;alpha,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;newImgSize,
        <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;validPixROI,
        boolean&nbsp;centerPrincipalPoint)</code>

        <div class="block">Returns the new camera matrix based on the free scaling parameter.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Rect.html"
                                         title="class in org.opencv.core">Rect</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#getValidDisparityROI(org.opencv.core.Rect, org.opencv.core.Rect, int, int, int)">getValidDisparityROI</a></strong>(<a
            href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;roi1,
        <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;roi2,
        int&nbsp;minDisparity,
        int&nbsp;numberOfDisparities,
        int&nbsp;SADWindowSize)</code>&nbsp;</td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#initCameraMatrix2D(java.util.List, java.util.List, org.opencv.core.Size)">initCameraMatrix2D</a></strong>(java.util.List&lt;<a
            href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&gt;&nbsp;objectPoints,
        java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint2f.html"
                             title="class in org.opencv.core">MatOfPoint2f</a>&gt;&nbsp;imagePoints,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imageSize)</code>

        <div class="block">Finds an initial camera matrix from 3D-2D point correspondences.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#initCameraMatrix2D(java.util.List, java.util.List, org.opencv.core.Size, double)">initCameraMatrix2D</a></strong>(java.util.List&lt;<a
            href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&gt;&nbsp;objectPoints,
        java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint2f.html"
                             title="class in org.opencv.core">MatOfPoint2f</a>&gt;&nbsp;imagePoints,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imageSize,
        double&nbsp;aspectRatio)</code>

        <div class="block">Finds an initial camera matrix from 3D-2D point correspondences.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#matMulDeriv(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">matMulDeriv</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;A,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;B,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dABdA,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dABdB)</code>

        <div class="block">Computes partial derivatives of the matrix product for each multiplied
            matrix.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#projectPoints(org.opencv.core.MatOfPoint3f, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfDouble, org.opencv.core.MatOfPoint2f)">projectPoints</a></strong>(<a
            href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
        <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
        <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints)</code>

        <div class="block">Projects 3D points to an image plane.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#projectPoints(org.opencv.core.MatOfPoint3f, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfDouble, org.opencv.core.MatOfPoint2f, org.opencv.core.Mat, double)">projectPoints</a></strong>(<a
            href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
        <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
        <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;jacobian,
        double&nbsp;aspectRatio)</code>

        <div class="block">Projects 3D points to an image plane.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static float</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#rectify3Collinear(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, java.util.List, java.util.List, org.opencv.core.Size, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, org.opencv.core.Size, org.opencv.core.Rect, org.opencv.core.Rect, int)">rectify3Collinear</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix3,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs3,
        java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                             title="class in org.opencv.core">Mat</a>&gt;&nbsp;imgpt1,
        java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                             title="class in org.opencv.core">Mat</a>&gt;&nbsp;imgpt3,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imageSize,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R12,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;T12,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R13,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;T13,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R3,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;P1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;P2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;P3,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Q,
        double&nbsp;alpha,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;newImgSize,
        <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;roi1,
        <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;roi2,
        int&nbsp;flags)</code>&nbsp;</td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#reprojectImageTo3D(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">reprojectImageTo3D</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;disparity,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;_3dImage,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Q)</code>

        <div class="block">Reprojects a disparity image to 3D space.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#reprojectImageTo3D(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)">reprojectImageTo3D</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;disparity,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;_3dImage,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Q,
        boolean&nbsp;handleMissingValues)</code>

        <div class="block">Reprojects a disparity image to 3D space.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#reprojectImageTo3D(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean, int)">reprojectImageTo3D</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;disparity,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;_3dImage,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Q,
        boolean&nbsp;handleMissingValues,
        int&nbsp;ddepth)</code>

        <div class="block">Reprojects a disparity image to 3D space.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#Rodrigues(org.opencv.core.Mat, org.opencv.core.Mat)">Rodrigues</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Converts a rotation matrix to a rotation vector or vice versa.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#Rodrigues(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">Rodrigues</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;jacobian)</code>

        <div class="block">Converts a rotation matrix to a rotation vector or vice versa.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static double[]</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#RQDecomp3x3(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">RQDecomp3x3</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mtxR,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mtxQ)</code>

        <div class="block">Computes an RQ decomposition of 3x3 matrices.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static double[]</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#RQDecomp3x3(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">RQDecomp3x3</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mtxR,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mtxQ,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Qx,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Qy,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Qz)</code>

        <div class="block">Computes an RQ decomposition of 3x3 matrices.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static boolean</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#solvePnP(org.opencv.core.MatOfPoint3f, org.opencv.core.MatOfPoint2f, org.opencv.core.Mat, org.opencv.core.MatOfDouble, org.opencv.core.Mat, org.opencv.core.Mat)">solvePnP</a></strong>(<a
            href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
        <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
        <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec)</code>

        <div class="block">Finds an object pose from 3D-2D point correspondences.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static boolean</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#solvePnP(org.opencv.core.MatOfPoint3f, org.opencv.core.MatOfPoint2f, org.opencv.core.Mat, org.opencv.core.MatOfDouble, org.opencv.core.Mat, org.opencv.core.Mat, boolean, int)">solvePnP</a></strong>(<a
            href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
        <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
        <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
        boolean&nbsp;useExtrinsicGuess,
        int&nbsp;flags)</code>

        <div class="block">Finds an object pose from 3D-2D point correspondences.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#solvePnPRansac(org.opencv.core.MatOfPoint3f, org.opencv.core.MatOfPoint2f, org.opencv.core.Mat, org.opencv.core.MatOfDouble, org.opencv.core.Mat, org.opencv.core.Mat)">solvePnPRansac</a></strong>(<a
            href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
        <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
        <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec)</code>

        <div class="block">Finds an object pose from 3D-2D point correspondences using the RANSAC
            scheme.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#solvePnPRansac(org.opencv.core.MatOfPoint3f, org.opencv.core.MatOfPoint2f, org.opencv.core.Mat, org.opencv.core.MatOfDouble, org.opencv.core.Mat, org.opencv.core.Mat, boolean, int, float, int, org.opencv.core.Mat, int)">solvePnPRansac</a></strong>(<a
            href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
        <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
        <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
        boolean&nbsp;useExtrinsicGuess,
        int&nbsp;iterationsCount,
        float&nbsp;reprojectionError,
        int&nbsp;minInliersCount,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;inliers,
        int&nbsp;flags)</code>

        <div class="block">Finds an object pose from 3D-2D point correspondences using the RANSAC
            scheme.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static double</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#stereoCalibrate(java.util.List, java.util.List, java.util.List, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">stereoCalibrate</a></strong>(java.util.List&lt;<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;objectPoints,
        java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                             title="class in org.opencv.core">Mat</a>&gt;&nbsp;imagePoints1,
        java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                             title="class in org.opencv.core">Mat</a>&gt;&nbsp;imagePoints2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs2,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imageSize,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;T,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;E,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;F)</code>

        <div class="block">Calibrates the stereo camera.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static double</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#stereoCalibrate(java.util.List, java.util.List, java.util.List, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.TermCriteria, int)">stereoCalibrate</a></strong>(java.util.List&lt;<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;objectPoints,
        java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                             title="class in org.opencv.core">Mat</a>&gt;&nbsp;imagePoints1,
        java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                             title="class in org.opencv.core">Mat</a>&gt;&nbsp;imagePoints2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs2,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imageSize,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;T,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;E,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;F,
        <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria,
        int&nbsp;flags)</code>

        <div class="block">Calibrates the stereo camera.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#stereoRectify(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">stereoRectify</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs2,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imageSize,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;T,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;P1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;P2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Q)</code>

        <div class="block">Computes rectification transforms for each head of a calibrated stereo
            camera.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#stereoRectify(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, double, org.opencv.core.Size, org.opencv.core.Rect, org.opencv.core.Rect)">stereoRectify</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs2,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imageSize,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;T,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;P1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;P2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Q,
        int&nbsp;flags,
        double&nbsp;alpha,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;newImageSize,
        <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;validPixROI1,
        <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;validPixROI2)</code>

        <div class="block">Computes rectification transforms for each head of a calibrated stereo
            camera.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static boolean</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#stereoRectifyUncalibrated(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Mat, org.opencv.core.Mat)">stereoRectifyUncalibrated</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;F,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imgSize,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;H1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;H2)</code>

        <div class="block">Computes a rectification transform for an uncalibrated stereo camera.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static boolean</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#stereoRectifyUncalibrated(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Mat, org.opencv.core.Mat, double)">stereoRectifyUncalibrated</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;F,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imgSize,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;H1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;H2,
        double&nbsp;threshold)</code>

        <div class="block">Computes a rectification transform for an uncalibrated stereo camera.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#triangulatePoints(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">triangulatePoints</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;projMatr1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;projMatr2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;projPoints1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;projPoints2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points4D)</code>

        <div class="block">Reconstructs points by triangulation.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#validateDisparity(org.opencv.core.Mat, org.opencv.core.Mat, int, int)">validateDisparity</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;disparity,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cost,
        int&nbsp;minDisparity,
        int&nbsp;numberOfDisparities)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/calib3d/Calib3d.html#validateDisparity(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int)">validateDisparity</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;disparity,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cost,
        int&nbsp;minDisparity,
        int&nbsp;numberOfDisparities,
        int&nbsp;disp12MaxDisp)</code>&nbsp;</td>
</tr>
</table>
<ul class="blockList">
    <li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
        <!--   -->
    </a>

        <h3>Methods inherited from class&nbsp;java.lang.Object</h3>
        <code>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_detail">
    <!--   -->
</a>

<h3>Field Detail</h3>
<a name="CALIB_CB_ADAPTIVE_THRESH">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CALIB_CB_ADAPTIVE_THRESH</h4>
        <pre>public static final&nbsp;int CALIB_CB_ADAPTIVE_THRESH</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.calib3d.Calib3d.CALIB_CB_ADAPTIVE_THRESH">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CALIB_CB_ASYMMETRIC_GRID">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CALIB_CB_ASYMMETRIC_GRID</h4>
        <pre>public static final&nbsp;int CALIB_CB_ASYMMETRIC_GRID</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.calib3d.Calib3d.CALIB_CB_ASYMMETRIC_GRID">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CALIB_CB_CLUSTERING">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CALIB_CB_CLUSTERING</h4>
        <pre>public static final&nbsp;int CALIB_CB_CLUSTERING</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.calib3d.Calib3d.CALIB_CB_CLUSTERING">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CALIB_CB_FAST_CHECK">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CALIB_CB_FAST_CHECK</h4>
        <pre>public static final&nbsp;int CALIB_CB_FAST_CHECK</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.calib3d.Calib3d.CALIB_CB_FAST_CHECK">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CALIB_CB_FILTER_QUADS">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CALIB_CB_FILTER_QUADS</h4>
        <pre>public static final&nbsp;int CALIB_CB_FILTER_QUADS</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.calib3d.Calib3d.CALIB_CB_FILTER_QUADS">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CALIB_CB_NORMALIZE_IMAGE">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CALIB_CB_NORMALIZE_IMAGE</h4>
        <pre>public static final&nbsp;int CALIB_CB_NORMALIZE_IMAGE</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.calib3d.Calib3d.CALIB_CB_NORMALIZE_IMAGE">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CALIB_CB_SYMMETRIC_GRID">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CALIB_CB_SYMMETRIC_GRID</h4>
        <pre>public static final&nbsp;int CALIB_CB_SYMMETRIC_GRID</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.calib3d.Calib3d.CALIB_CB_SYMMETRIC_GRID">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CALIB_FIX_ASPECT_RATIO">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CALIB_FIX_ASPECT_RATIO</h4>
        <pre>public static final&nbsp;int CALIB_FIX_ASPECT_RATIO</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.calib3d.Calib3d.CALIB_FIX_ASPECT_RATIO">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CALIB_FIX_FOCAL_LENGTH">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CALIB_FIX_FOCAL_LENGTH</h4>
        <pre>public static final&nbsp;int CALIB_FIX_FOCAL_LENGTH</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.calib3d.Calib3d.CALIB_FIX_FOCAL_LENGTH">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CALIB_FIX_INTRINSIC">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CALIB_FIX_INTRINSIC</h4>
        <pre>public static final&nbsp;int CALIB_FIX_INTRINSIC</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.calib3d.Calib3d.CALIB_FIX_INTRINSIC">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CALIB_FIX_K1">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CALIB_FIX_K1</h4>
        <pre>public static final&nbsp;int CALIB_FIX_K1</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.calib3d.Calib3d.CALIB_FIX_K1">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CALIB_FIX_K2">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CALIB_FIX_K2</h4>
        <pre>public static final&nbsp;int CALIB_FIX_K2</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.calib3d.Calib3d.CALIB_FIX_K2">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CALIB_FIX_K3">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CALIB_FIX_K3</h4>
        <pre>public static final&nbsp;int CALIB_FIX_K3</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.calib3d.Calib3d.CALIB_FIX_K3">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CALIB_FIX_K4">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CALIB_FIX_K4</h4>
        <pre>public static final&nbsp;int CALIB_FIX_K4</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.calib3d.Calib3d.CALIB_FIX_K4">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CALIB_FIX_K5">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CALIB_FIX_K5</h4>
        <pre>public static final&nbsp;int CALIB_FIX_K5</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.calib3d.Calib3d.CALIB_FIX_K5">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CALIB_FIX_K6">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CALIB_FIX_K6</h4>
        <pre>public static final&nbsp;int CALIB_FIX_K6</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.calib3d.Calib3d.CALIB_FIX_K6">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CALIB_FIX_PRINCIPAL_POINT">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CALIB_FIX_PRINCIPAL_POINT</h4>
        <pre>public static final&nbsp;int CALIB_FIX_PRINCIPAL_POINT</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.calib3d.Calib3d.CALIB_FIX_PRINCIPAL_POINT">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CALIB_RATIONAL_MODEL">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CALIB_RATIONAL_MODEL</h4>
        <pre>public static final&nbsp;int CALIB_RATIONAL_MODEL</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.calib3d.Calib3d.CALIB_RATIONAL_MODEL">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CALIB_SAME_FOCAL_LENGTH">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CALIB_SAME_FOCAL_LENGTH</h4>
        <pre>public static final&nbsp;int CALIB_SAME_FOCAL_LENGTH</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.calib3d.Calib3d.CALIB_SAME_FOCAL_LENGTH">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CALIB_USE_INTRINSIC_GUESS">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CALIB_USE_INTRINSIC_GUESS</h4>
        <pre>public static final&nbsp;int CALIB_USE_INTRINSIC_GUESS</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.calib3d.Calib3d.CALIB_USE_INTRINSIC_GUESS">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CALIB_ZERO_DISPARITY">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CALIB_ZERO_DISPARITY</h4>
        <pre>public static final&nbsp;int CALIB_ZERO_DISPARITY</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.calib3d.Calib3d.CALIB_ZERO_DISPARITY">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CALIB_ZERO_TANGENT_DIST">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CALIB_ZERO_TANGENT_DIST</h4>
        <pre>public static final&nbsp;int CALIB_ZERO_TANGENT_DIST</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.calib3d.Calib3d.CALIB_ZERO_TANGENT_DIST">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_EPNP">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_EPNP</h4>
        <pre>public static final&nbsp;int CV_EPNP</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.calib3d.Calib3d.CV_EPNP">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_ITERATIVE">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_ITERATIVE</h4>
        <pre>public static final&nbsp;int CV_ITERATIVE</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.calib3d.Calib3d.CV_ITERATIVE">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_P3P">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_P3P</h4>
        <pre>public static final&nbsp;int CV_P3P</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.calib3d.Calib3d.CV_P3P">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="EPNP">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>EPNP</h4>
        <pre>public static final&nbsp;int EPNP</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.calib3d.Calib3d.EPNP">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="FM_7POINT">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>FM_7POINT</h4>
        <pre>public static final&nbsp;int FM_7POINT</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.calib3d.Calib3d.FM_7POINT">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="FM_8POINT">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>FM_8POINT</h4>
        <pre>public static final&nbsp;int FM_8POINT</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.calib3d.Calib3d.FM_8POINT">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="FM_LMEDS">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>FM_LMEDS</h4>
        <pre>public static final&nbsp;int FM_LMEDS</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.calib3d.Calib3d.FM_LMEDS">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="FM_RANSAC">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>FM_RANSAC</h4>
        <pre>public static final&nbsp;int FM_RANSAC</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.calib3d.Calib3d.FM_RANSAC">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="ITERATIVE">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>ITERATIVE</h4>
        <pre>public static final&nbsp;int ITERATIVE</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.calib3d.Calib3d.ITERATIVE">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="LMEDS">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>LMEDS</h4>
        <pre>public static final&nbsp;int LMEDS</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.calib3d.Calib3d.LMEDS">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="P3P">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>P3P</h4>
        <pre>public static final&nbsp;int P3P</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.calib3d.Calib3d.P3P">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="RANSAC">
    <!--   -->
</a>
<ul class="blockListLast">
    <li class="blockList">
        <h4>RANSAC</h4>
        <pre>public static final&nbsp;int RANSAC</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.calib3d.Calib3d.RANSAC">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
    <li class="blockList"><a name="constructor_detail">
        <!--   -->
    </a>

        <h3>Constructor Detail</h3>
        <a name="Calib3d()">
            <!--   -->
        </a>
        <ul class="blockListLast">
            <li class="blockList">
                <h4>Calib3d</h4>
                <pre>public&nbsp;Calib3d()</pre>
            </li>
        </ul>
    </li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
    <!--   -->
</a>

<h3>Method Detail</h3>
<a name="calibrateCamera(java.util.List, java.util.List, org.opencv.core.Size, org.opencv.core.Mat, org.opencv.core.Mat, java.util.List, java.util.List)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>calibrateCamera</h4>
<pre>public static&nbsp;double&nbsp;calibrateCamera(java.util.List&lt;<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;objectPoints,
                     java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                                          title="class in org.opencv.core">Mat</a>&gt;&nbsp;imagePoints,
                     <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imageSize,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                     java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                                          title="class in org.opencv.core">Mat</a>&gt;&nbsp;rvecs,
                     java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                                          title="class in org.opencv.core">Mat</a>&gt;&nbsp;tvecs)</pre>
        <div class="block"><p>Finds the camera intrinsic and extrinsic parameters from several views
            of a
            calibration pattern.</p>

            <p>The function estimates the intrinsic camera parameters and extrinsic
                parameters for each of the views. The algorithm is based on [Zhang2000] and
                [BouguetMCT]. The coordinates of 3D object points and their corresponding 2D
                projections in each view must be specified. That may be achieved by using an
                object with a known geometry and easily detectable feature points.
                Such an object is called a calibration rig or calibration pattern, and OpenCV
                has built-in support for a chessboard as a calibration rig (see
                "findChessboardCorners"). Currently, initialization of intrinsic parameters
                (when <code>CV_CALIB_USE_INTRINSIC_GUESS</code> is not set) is only
                implemented for planar calibration patterns (where Z-coordinates of the
                object points must be all zeros). 3D calibration rigs can also be used as
                long as initial <code>cameraMatrix</code> is provided.</p>

            <p>The algorithm performs the following steps:</p>
            <ul>
                <li> Compute the initial intrinsic parameters (the option only available
                    for planar calibration patterns) or read them from the input parameters. The
                    distortion coefficients are all set to zeros initially unless some of
                    <code>CV_CALIB_FIX_K?</code> are specified.
                <li> Estimate the initial camera pose as if the intrinsic parameters have
                    been already known. This is done using "solvePnP".
                <li> Run the global Levenberg-Marquardt optimization algorithm to minimize
                    the reprojection error, that is, the total sum of squared distances between
                    the observed feature points <code>imagePoints</code> and the projected (using
                    the current estimates for camera parameters and the poses) object points
                    <code>objectPoints</code>. See "projectPoints" for details.
            </ul>

            <p>The function returns the final re-projection error.</p>

            <p>Note:</p>

            <p>If you use a non-square (=non-NxN) grid and "findChessboardCorners" for
                calibration, and <code>calibrateCamera</code> returns bad values (zero
                distortion coefficients, an image center very far from
                <code>(w/2-0.5,h/2-0.5)</code>,
                and/or large differences between <em>f_x</em> and <em>f_y</em> (ratios of
                10:1 or more)), then you have probably used
                <code>patternSize=cvSize(rows,cols)</code>
                instead of using <code>patternSize=cvSize(cols,rows)</code> in
                "findChessboardCorners".</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>objectPoints</code> - In the new interface it is a vector of vectors of
                calibration pattern points in the calibration pattern coordinate space. The
                outer vector contains as many elements as the number of the pattern views. If
                the same calibration pattern is shown in each view and it is fully visible,
                all the vectors will be the same. Although, it is possible to use partially
                occluded patterns, or even different patterns in different views. Then, the
                vectors will be different. The points are 3D, but since they are in a pattern
                coordinate system, then, if the rig is planar, it may make sense to put the
                model to a XY coordinate plane so that Z-coordinate of each input object
                point is 0.

                <p>In the old interface all the vectors of object points from different views
                    are concatenated together.</p></dd>
            <dd><code>imagePoints</code> - In the new interface it is a vector of vectors of the
                projections of calibration pattern points. <code>imagePoints.size()</code>
                and <code>objectPoints.size()</code> and <code>imagePoints[i].size()</code>
                must be equal to <code>objectPoints[i].size()</code> for each <code>i</code>.

                <p>In the old interface all the vectors of object points from different views
                    are concatenated together.</p></dd>
            <dd><code>imageSize</code> - Size of the image used only to initialize the intrinsic
                camera matrix.
            </dd>
            <dd><code>cameraMatrix</code> - Output 3x3 floating-point camera matrix <em>A =
                <p>|f_x 0 c_x|
                    |0 f_y c_y|
                    |0 0 1|
            </em>. If <code>CV_CALIB_USE_INTRINSIC_GUESS</code> and/or <code>CV_CALIB_FIX_ASPECT_RATIO</code>
                are specified, some or all of <code>fx, fy, cx, cy</code> must be initialized
                before calling the function.</p></dd>
            <dd><code>distCoeffs</code> - Output vector of distortion coefficients <em>(k_1, k_2,
                p_1, p_2[, k_3[, k_4, k_5, k_6]])</em> of 4, 5, or 8 elements.
            </dd>
            <dd><code>rvecs</code> - Output vector of rotation vectors (see "Rodrigues") estimated
                for each pattern view. That is, each k-th rotation vector together with the
                corresponding k-th translation vector (see the next output parameter
                description) brings the calibration pattern from the model coordinate space
                (in which object points are specified) to the world coordinate space, that
                is, a real position of the calibration pattern in the k-th pattern view
                (k=0.. *M* -1).
            </dd>
            <dd><code>tvecs</code> - Output vector of translation vectors estimated for each pattern
                view.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#calibratecamera">org.opencv.calib3d.Calib3d.calibrateCamera</a>,
                <a href="../../../org/opencv/calib3d/Calib3d.html#initCameraMatrix2D(java.util.List, java.util.List, org.opencv.core.Size, double)"><code>initCameraMatrix2D(java.util.List
                    <org.opencv.core.MatOfPoint3f>, java.util.List
                        <org.opencv.core.MatOfPoint2f>, org.opencv.core.Size, double)
                </code></a>,
                <a href="../../../org/opencv/calib3d/Calib3d.html#stereoCalibrate(java.util.List, java.util.List, java.util.List, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.TermCriteria, int)"><code>stereoCalibrate(java.util.List
                    <org.opencv.core.Mat>, java.util.List
                        <org.opencv.core.Mat>, java.util.List
                            <org.opencv.core.Mat>, org.opencv.core.Mat, org.opencv.core.Mat,
                                org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size,
                                org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat,
                                org.opencv.core.Mat, org.opencv.core.TermCriteria, int)
                </code></a>,
                <a href="../../../org/opencv/calib3d/Calib3d.html#findChessboardCorners(org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.MatOfPoint2f, int)"><code>findChessboardCorners(org.opencv.core.Mat,
                    org.opencv.core.Size, org.opencv.core.MatOfPoint2f, int)</code></a>,
                <a href="../../../org/opencv/calib3d/Calib3d.html#solvePnP(org.opencv.core.MatOfPoint3f, org.opencv.core.MatOfPoint2f, org.opencv.core.Mat, org.opencv.core.MatOfDouble, org.opencv.core.Mat, org.opencv.core.Mat, boolean, int)"><code>solvePnP(org.opencv.core.MatOfPoint3f,
                    org.opencv.core.MatOfPoint2f, org.opencv.core.Mat, org.opencv.core.MatOfDouble,
                    org.opencv.core.Mat, org.opencv.core.Mat, boolean, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#undistort(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Imgproc.undistort(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="calibrateCamera(java.util.List, java.util.List, org.opencv.core.Size, org.opencv.core.Mat, org.opencv.core.Mat, java.util.List, java.util.List, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>calibrateCamera</h4>
<pre>public static&nbsp;double&nbsp;calibrateCamera(java.util.List&lt;<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;objectPoints,
                     java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                                          title="class in org.opencv.core">Mat</a>&gt;&nbsp;imagePoints,
                     <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imageSize,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                     java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                                          title="class in org.opencv.core">Mat</a>&gt;&nbsp;rvecs,
                     java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                                          title="class in org.opencv.core">Mat</a>&gt;&nbsp;tvecs,
                     int&nbsp;flags)</pre>
        <div class="block"><p>Finds the camera intrinsic and extrinsic parameters from several views
            of a
            calibration pattern.</p>

            <p>The function estimates the intrinsic camera parameters and extrinsic
                parameters for each of the views. The algorithm is based on [Zhang2000] and
                [BouguetMCT]. The coordinates of 3D object points and their corresponding 2D
                projections in each view must be specified. That may be achieved by using an
                object with a known geometry and easily detectable feature points.
                Such an object is called a calibration rig or calibration pattern, and OpenCV
                has built-in support for a chessboard as a calibration rig (see
                "findChessboardCorners"). Currently, initialization of intrinsic parameters
                (when <code>CV_CALIB_USE_INTRINSIC_GUESS</code> is not set) is only
                implemented for planar calibration patterns (where Z-coordinates of the
                object points must be all zeros). 3D calibration rigs can also be used as
                long as initial <code>cameraMatrix</code> is provided.</p>

            <p>The algorithm performs the following steps:</p>
            <ul>
                <li> Compute the initial intrinsic parameters (the option only available
                    for planar calibration patterns) or read them from the input parameters. The
                    distortion coefficients are all set to zeros initially unless some of
                    <code>CV_CALIB_FIX_K?</code> are specified.
                <li> Estimate the initial camera pose as if the intrinsic parameters have
                    been already known. This is done using "solvePnP".
                <li> Run the global Levenberg-Marquardt optimization algorithm to minimize
                    the reprojection error, that is, the total sum of squared distances between
                    the observed feature points <code>imagePoints</code> and the projected (using
                    the current estimates for camera parameters and the poses) object points
                    <code>objectPoints</code>. See "projectPoints" for details.
            </ul>

            <p>The function returns the final re-projection error.</p>

            <p>Note:</p>

            <p>If you use a non-square (=non-NxN) grid and "findChessboardCorners" for
                calibration, and <code>calibrateCamera</code> returns bad values (zero
                distortion coefficients, an image center very far from
                <code>(w/2-0.5,h/2-0.5)</code>,
                and/or large differences between <em>f_x</em> and <em>f_y</em> (ratios of
                10:1 or more)), then you have probably used
                <code>patternSize=cvSize(rows,cols)</code>
                instead of using <code>patternSize=cvSize(cols,rows)</code> in
                "findChessboardCorners".</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>objectPoints</code> - In the new interface it is a vector of vectors of
                calibration pattern points in the calibration pattern coordinate space. The
                outer vector contains as many elements as the number of the pattern views. If
                the same calibration pattern is shown in each view and it is fully visible,
                all the vectors will be the same. Although, it is possible to use partially
                occluded patterns, or even different patterns in different views. Then, the
                vectors will be different. The points are 3D, but since they are in a pattern
                coordinate system, then, if the rig is planar, it may make sense to put the
                model to a XY coordinate plane so that Z-coordinate of each input object
                point is 0.

                <p>In the old interface all the vectors of object points from different views
                    are concatenated together.</p></dd>
            <dd><code>imagePoints</code> - In the new interface it is a vector of vectors of the
                projections of calibration pattern points. <code>imagePoints.size()</code>
                and <code>objectPoints.size()</code> and <code>imagePoints[i].size()</code>
                must be equal to <code>objectPoints[i].size()</code> for each <code>i</code>.

                <p>In the old interface all the vectors of object points from different views
                    are concatenated together.</p></dd>
            <dd><code>imageSize</code> - Size of the image used only to initialize the intrinsic
                camera matrix.
            </dd>
            <dd><code>cameraMatrix</code> - Output 3x3 floating-point camera matrix <em>A =
                <p>|f_x 0 c_x|
                    |0 f_y c_y|
                    |0 0 1|
            </em>. If <code>CV_CALIB_USE_INTRINSIC_GUESS</code> and/or <code>CV_CALIB_FIX_ASPECT_RATIO</code>
                are specified, some or all of <code>fx, fy, cx, cy</code> must be initialized
                before calling the function.</p></dd>
            <dd><code>distCoeffs</code> - Output vector of distortion coefficients <em>(k_1, k_2,
                p_1, p_2[, k_3[, k_4, k_5, k_6]])</em> of 4, 5, or 8 elements.
            </dd>
            <dd><code>rvecs</code> - Output vector of rotation vectors (see "Rodrigues") estimated
                for each pattern view. That is, each k-th rotation vector together with the
                corresponding k-th translation vector (see the next output parameter
                description) brings the calibration pattern from the model coordinate space
                (in which object points are specified) to the world coordinate space, that
                is, a real position of the calibration pattern in the k-th pattern view
                (k=0.. *M* -1).
            </dd>
            <dd><code>tvecs</code> - Output vector of translation vectors estimated for each pattern
                view.
            </dd>
            <dd><code>flags</code> - Different flags that may be zero or a combination of the
                following values:
                <ul>
                    <li> CV_CALIB_USE_INTRINSIC_GUESS <code>cameraMatrix</code> contains valid
                        initial values of <code>fx, fy, cx, cy</code> that are optimized further.
                        Otherwise, <code>(cx, cy)</code> is initially set to the image center
                        (<code>imageSize</code> is used), and focal distances are computed in a
                        least-squares fashion. Note, that if intrinsic parameters are known, there
                        is
                        no need to use this function just to estimate extrinsic parameters. Use
                        "solvePnP" instead.
                    <li> CV_CALIB_FIX_PRINCIPAL_POINT The principal point is not changed during
                        the global optimization. It stays at the center or at a different location
                        specified when <code>CV_CALIB_USE_INTRINSIC_GUESS</code> is set too.
                    <li> CV_CALIB_FIX_ASPECT_RATIO The functions considers only <code>fy</code>
                        as a free parameter. The ratio <code>fx/fy</code> stays the same as in the
                        input <code>cameraMatrix</code>. When
                        <code>CV_CALIB_USE_INTRINSIC_GUESS</code>
                        is not set, the actual input values of <code>fx</code> and <code>fy</code>
                        are ignored, only their ratio is computed and used further.
                    <li> CV_CALIB_ZERO_TANGENT_DIST Tangential distortion coefficients
                        <em>(p_1, p_2)</em> are set to zeros and stay zero.
                    <li> CV_CALIB_FIX_K1,...,CV_CALIB_FIX_K6 The corresponding radial
                        distortion coefficient is not changed during the optimization. If
                        <code>CV_CALIB_USE_INTRINSIC_GUESS</code> is set, the coefficient from the
                        supplied <code>distCoeffs</code> matrix is used. Otherwise, it is set to 0.
                    <li> CV_CALIB_RATIONAL_MODEL Coefficients k4, k5, and k6 are enabled. To
                        provide the backward compatibility, this extra flag should be explicitly
                        specified to make the calibration function use the rational model and return
                        8 coefficients. If the flag is not set, the function computes and returns
                        only 5 distortion coefficients.
                </ul>
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#calibratecamera">org.opencv.calib3d.Calib3d.calibrateCamera</a>,
                <a href="../../../org/opencv/calib3d/Calib3d.html#initCameraMatrix2D(java.util.List, java.util.List, org.opencv.core.Size, double)"><code>initCameraMatrix2D(java.util.List
                    <org.opencv.core.MatOfPoint3f>, java.util.List
                        <org.opencv.core.MatOfPoint2f>, org.opencv.core.Size, double)
                </code></a>,
                <a href="../../../org/opencv/calib3d/Calib3d.html#stereoCalibrate(java.util.List, java.util.List, java.util.List, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.TermCriteria, int)"><code>stereoCalibrate(java.util.List
                    <org.opencv.core.Mat>, java.util.List
                        <org.opencv.core.Mat>, java.util.List
                            <org.opencv.core.Mat>, org.opencv.core.Mat, org.opencv.core.Mat,
                                org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size,
                                org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat,
                                org.opencv.core.Mat, org.opencv.core.TermCriteria, int)
                </code></a>,
                <a href="../../../org/opencv/calib3d/Calib3d.html#findChessboardCorners(org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.MatOfPoint2f, int)"><code>findChessboardCorners(org.opencv.core.Mat,
                    org.opencv.core.Size, org.opencv.core.MatOfPoint2f, int)</code></a>,
                <a href="../../../org/opencv/calib3d/Calib3d.html#solvePnP(org.opencv.core.MatOfPoint3f, org.opencv.core.MatOfPoint2f, org.opencv.core.Mat, org.opencv.core.MatOfDouble, org.opencv.core.Mat, org.opencv.core.Mat, boolean, int)"><code>solvePnP(org.opencv.core.MatOfPoint3f,
                    org.opencv.core.MatOfPoint2f, org.opencv.core.Mat, org.opencv.core.MatOfDouble,
                    org.opencv.core.Mat, org.opencv.core.Mat, boolean, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#undistort(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Imgproc.undistort(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="calibrateCamera(java.util.List, java.util.List, org.opencv.core.Size, org.opencv.core.Mat, org.opencv.core.Mat, java.util.List, java.util.List, int, org.opencv.core.TermCriteria)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>calibrateCamera</h4>
<pre>public static&nbsp;double&nbsp;calibrateCamera(java.util.List&lt;<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;objectPoints,
                     java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                                          title="class in org.opencv.core">Mat</a>&gt;&nbsp;imagePoints,
                     <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imageSize,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                     java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                                          title="class in org.opencv.core">Mat</a>&gt;&nbsp;rvecs,
                     java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                                          title="class in org.opencv.core">Mat</a>&gt;&nbsp;tvecs,
                     int&nbsp;flags,
                     <a href="../../../org/opencv/core/TermCriteria.html"
                        title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria)</pre>
        <div class="block"><p>Finds the camera intrinsic and extrinsic parameters from several views
            of a
            calibration pattern.</p>

            <p>The function estimates the intrinsic camera parameters and extrinsic
                parameters for each of the views. The algorithm is based on [Zhang2000] and
                [BouguetMCT]. The coordinates of 3D object points and their corresponding 2D
                projections in each view must be specified. That may be achieved by using an
                object with a known geometry and easily detectable feature points.
                Such an object is called a calibration rig or calibration pattern, and OpenCV
                has built-in support for a chessboard as a calibration rig (see
                "findChessboardCorners"). Currently, initialization of intrinsic parameters
                (when <code>CV_CALIB_USE_INTRINSIC_GUESS</code> is not set) is only
                implemented for planar calibration patterns (where Z-coordinates of the
                object points must be all zeros). 3D calibration rigs can also be used as
                long as initial <code>cameraMatrix</code> is provided.</p>

            <p>The algorithm performs the following steps:</p>
            <ul>
                <li> Compute the initial intrinsic parameters (the option only available
                    for planar calibration patterns) or read them from the input parameters. The
                    distortion coefficients are all set to zeros initially unless some of
                    <code>CV_CALIB_FIX_K?</code> are specified.
                <li> Estimate the initial camera pose as if the intrinsic parameters have
                    been already known. This is done using "solvePnP".
                <li> Run the global Levenberg-Marquardt optimization algorithm to minimize
                    the reprojection error, that is, the total sum of squared distances between
                    the observed feature points <code>imagePoints</code> and the projected (using
                    the current estimates for camera parameters and the poses) object points
                    <code>objectPoints</code>. See "projectPoints" for details.
            </ul>

            <p>The function returns the final re-projection error.</p>

            <p>Note:</p>

            <p>If you use a non-square (=non-NxN) grid and "findChessboardCorners" for
                calibration, and <code>calibrateCamera</code> returns bad values (zero
                distortion coefficients, an image center very far from
                <code>(w/2-0.5,h/2-0.5)</code>,
                and/or large differences between <em>f_x</em> and <em>f_y</em> (ratios of
                10:1 or more)), then you have probably used
                <code>patternSize=cvSize(rows,cols)</code>
                instead of using <code>patternSize=cvSize(cols,rows)</code> in
                "findChessboardCorners".</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>objectPoints</code> - In the new interface it is a vector of vectors of
                calibration pattern points in the calibration pattern coordinate space. The
                outer vector contains as many elements as the number of the pattern views. If
                the same calibration pattern is shown in each view and it is fully visible,
                all the vectors will be the same. Although, it is possible to use partially
                occluded patterns, or even different patterns in different views. Then, the
                vectors will be different. The points are 3D, but since they are in a pattern
                coordinate system, then, if the rig is planar, it may make sense to put the
                model to a XY coordinate plane so that Z-coordinate of each input object
                point is 0.

                <p>In the old interface all the vectors of object points from different views
                    are concatenated together.</p></dd>
            <dd><code>imagePoints</code> - In the new interface it is a vector of vectors of the
                projections of calibration pattern points. <code>imagePoints.size()</code>
                and <code>objectPoints.size()</code> and <code>imagePoints[i].size()</code>
                must be equal to <code>objectPoints[i].size()</code> for each <code>i</code>.

                <p>In the old interface all the vectors of object points from different views
                    are concatenated together.</p></dd>
            <dd><code>imageSize</code> - Size of the image used only to initialize the intrinsic
                camera matrix.
            </dd>
            <dd><code>cameraMatrix</code> - Output 3x3 floating-point camera matrix <em>A =
                <p>|f_x 0 c_x|
                    |0 f_y c_y|
                    |0 0 1|
            </em>. If <code>CV_CALIB_USE_INTRINSIC_GUESS</code> and/or <code>CV_CALIB_FIX_ASPECT_RATIO</code>
                are specified, some or all of <code>fx, fy, cx, cy</code> must be initialized
                before calling the function.</p></dd>
            <dd><code>distCoeffs</code> - Output vector of distortion coefficients <em>(k_1, k_2,
                p_1, p_2[, k_3[, k_4, k_5, k_6]])</em> of 4, 5, or 8 elements.
            </dd>
            <dd><code>rvecs</code> - Output vector of rotation vectors (see "Rodrigues") estimated
                for each pattern view. That is, each k-th rotation vector together with the
                corresponding k-th translation vector (see the next output parameter
                description) brings the calibration pattern from the model coordinate space
                (in which object points are specified) to the world coordinate space, that
                is, a real position of the calibration pattern in the k-th pattern view
                (k=0.. *M* -1).
            </dd>
            <dd><code>tvecs</code> - Output vector of translation vectors estimated for each pattern
                view.
            </dd>
            <dd><code>flags</code> - Different flags that may be zero or a combination of the
                following values:
                <ul>
                    <li> CV_CALIB_USE_INTRINSIC_GUESS <code>cameraMatrix</code> contains valid
                        initial values of <code>fx, fy, cx, cy</code> that are optimized further.
                        Otherwise, <code>(cx, cy)</code> is initially set to the image center
                        (<code>imageSize</code> is used), and focal distances are computed in a
                        least-squares fashion. Note, that if intrinsic parameters are known, there
                        is
                        no need to use this function just to estimate extrinsic parameters. Use
                        "solvePnP" instead.
                    <li> CV_CALIB_FIX_PRINCIPAL_POINT The principal point is not changed during
                        the global optimization. It stays at the center or at a different location
                        specified when <code>CV_CALIB_USE_INTRINSIC_GUESS</code> is set too.
                    <li> CV_CALIB_FIX_ASPECT_RATIO The functions considers only <code>fy</code>
                        as a free parameter. The ratio <code>fx/fy</code> stays the same as in the
                        input <code>cameraMatrix</code>. When
                        <code>CV_CALIB_USE_INTRINSIC_GUESS</code>
                        is not set, the actual input values of <code>fx</code> and <code>fy</code>
                        are ignored, only their ratio is computed and used further.
                    <li> CV_CALIB_ZERO_TANGENT_DIST Tangential distortion coefficients
                        <em>(p_1, p_2)</em> are set to zeros and stay zero.
                    <li> CV_CALIB_FIX_K1,...,CV_CALIB_FIX_K6 The corresponding radial
                        distortion coefficient is not changed during the optimization. If
                        <code>CV_CALIB_USE_INTRINSIC_GUESS</code> is set, the coefficient from the
                        supplied <code>distCoeffs</code> matrix is used. Otherwise, it is set to 0.
                    <li> CV_CALIB_RATIONAL_MODEL Coefficients k4, k5, and k6 are enabled. To
                        provide the backward compatibility, this extra flag should be explicitly
                        specified to make the calibration function use the rational model and return
                        8 coefficients. If the flag is not set, the function computes and returns
                        only 5 distortion coefficients.
                </ul>
            </dd>
            <dd><code>criteria</code> - Termination criteria for the iterative optimization
                algorithm.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#calibratecamera">org.opencv.calib3d.Calib3d.calibrateCamera</a>,
                <a href="../../../org/opencv/calib3d/Calib3d.html#initCameraMatrix2D(java.util.List, java.util.List, org.opencv.core.Size, double)"><code>initCameraMatrix2D(java.util.List
                    <org.opencv.core.MatOfPoint3f>, java.util.List
                        <org.opencv.core.MatOfPoint2f>, org.opencv.core.Size, double)
                </code></a>,
                <a href="../../../org/opencv/calib3d/Calib3d.html#stereoCalibrate(java.util.List, java.util.List, java.util.List, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.TermCriteria, int)"><code>stereoCalibrate(java.util.List
                    <org.opencv.core.Mat>, java.util.List
                        <org.opencv.core.Mat>, java.util.List
                            <org.opencv.core.Mat>, org.opencv.core.Mat, org.opencv.core.Mat,
                                org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size,
                                org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat,
                                org.opencv.core.Mat, org.opencv.core.TermCriteria, int)
                </code></a>,
                <a href="../../../org/opencv/calib3d/Calib3d.html#findChessboardCorners(org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.MatOfPoint2f, int)"><code>findChessboardCorners(org.opencv.core.Mat,
                    org.opencv.core.Size, org.opencv.core.MatOfPoint2f, int)</code></a>,
                <a href="../../../org/opencv/calib3d/Calib3d.html#solvePnP(org.opencv.core.MatOfPoint3f, org.opencv.core.MatOfPoint2f, org.opencv.core.Mat, org.opencv.core.MatOfDouble, org.opencv.core.Mat, org.opencv.core.Mat, boolean, int)"><code>solvePnP(org.opencv.core.MatOfPoint3f,
                    org.opencv.core.MatOfPoint2f, org.opencv.core.Mat, org.opencv.core.MatOfDouble,
                    org.opencv.core.Mat, org.opencv.core.Mat, boolean, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#undistort(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Imgproc.undistort(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="calibrationMatrixValues(org.opencv.core.Mat, org.opencv.core.Size, double, double, double[], double[], double[], org.opencv.core.Point, double[])">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>calibrationMatrixValues</h4>
<pre>public static&nbsp;void&nbsp;calibrationMatrixValues(<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                           <a href="../../../org/opencv/core/Size.html"
                              title="class in org.opencv.core">Size</a>&nbsp;imageSize,
                           double&nbsp;apertureWidth,
                           double&nbsp;apertureHeight,
                           double[]&nbsp;fovx,
                           double[]&nbsp;fovy,
                           double[]&nbsp;focalLength,
                           <a href="../../../org/opencv/core/Point.html"
                              title="class in org.opencv.core">Point</a>&nbsp;principalPoint,
                           double[]&nbsp;aspectRatio)</pre>
        <div class="block"><p>Computes useful camera characteristics from the camera matrix.</p>

            <p>The function computes various useful camera characteristics from the
                previously estimated camera matrix.</p>

            <p>Note:</p>

            <p>Do keep in mind that the unity measure 'mm' stands for whatever unit of
                measure one chooses for the chessboard pitch (it can thus be any value).</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>cameraMatrix</code> - Input camera matrix that can be estimated by
                "calibrateCamera" or "stereoCalibrate".
            </dd>
            <dd><code>imageSize</code> - Input image size in pixels.</dd>
            <dd><code>apertureWidth</code> - Physical width in mm of the sensor.</dd>
            <dd><code>apertureHeight</code> - Physical height in mm of the sensor.</dd>
            <dd><code>fovx</code> - Output field of view in degrees along the horizontal sensor
                axis.
            </dd>
            <dd><code>fovy</code> - Output field of view in degrees along the vertical sensor axis.
            </dd>
            <dd><code>focalLength</code> - Focal length of the lens in mm.</dd>
            <dd><code>principalPoint</code> - Principal point in mm.</dd>
            <dd><code>aspectRatio</code> - <em>f_y/f_x</em></dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#calibrationmatrixvalues">org.opencv.calib3d.Calib3d.calibrationMatrixValues</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="composeRT(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>composeRT</h4>
<pre>public static&nbsp;void&nbsp;composeRT(<a href="../../../org/opencv/core/Mat.html"
                                               title="class in org.opencv.core">Mat</a>&nbsp;rvec1,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec1,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec2,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec2,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec3,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec3)</pre>
        <div class="block"><p>Combines two rotation-and-shift transformations.</p>

            <p>The functions compute:</p>

            <p><em>rvec3 = rodrigues ^(-1)(rodrigues(rvec2) * rodrigues(rvec1))
                tvec3 = rodrigues(rvec2) * tvec1 + tvec2,</em></p>

            <p>where <em>rodrigues</em> denotes a rotation vector to a rotation matrix
                transformation, and <em>rodrigues^(-1)</em> denotes the inverse
                transformation. See "Rodrigues" for details.</p>

            <p>Also, the functions can compute the derivatives of the output vectors with
                regards to the input vectors (see "matMulDeriv").
                The functions are used inside "stereoCalibrate" but can also be used in your
                own code where Levenberg-Marquardt or another gradient-based solver is used
                to optimize a function that contains a matrix multiplication.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>rvec1</code> - First rotation vector.</dd>
            <dd><code>tvec1</code> - First translation vector.</dd>
            <dd><code>rvec2</code> - Second rotation vector.</dd>
            <dd><code>tvec2</code> - Second translation vector.</dd>
            <dd><code>rvec3</code> - Output rotation vector of the superposition.</dd>
            <dd><code>tvec3</code> - Output translation vector of the superposition.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#composert">org.opencv.calib3d.Calib3d.composeRT</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="composeRT(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>composeRT</h4>
<pre>public static&nbsp;void&nbsp;composeRT(<a href="../../../org/opencv/core/Mat.html"
                                               title="class in org.opencv.core">Mat</a>&nbsp;rvec1,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec1,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec2,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec2,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec3,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec3,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dr1,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dt1,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dr2,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dr3dt2,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dt3dr1,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dt3dt1,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dt3dr2,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dt3dt2)</pre>
        <div class="block"><p>Combines two rotation-and-shift transformations.</p>

            <p>The functions compute:</p>

            <p><em>rvec3 = rodrigues ^(-1)(rodrigues(rvec2) * rodrigues(rvec1))
                tvec3 = rodrigues(rvec2) * tvec1 + tvec2,</em></p>

            <p>where <em>rodrigues</em> denotes a rotation vector to a rotation matrix
                transformation, and <em>rodrigues^(-1)</em> denotes the inverse
                transformation. See "Rodrigues" for details.</p>

            <p>Also, the functions can compute the derivatives of the output vectors with
                regards to the input vectors (see "matMulDeriv").
                The functions are used inside "stereoCalibrate" but can also be used in your
                own code where Levenberg-Marquardt or another gradient-based solver is used
                to optimize a function that contains a matrix multiplication.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>rvec1</code> - First rotation vector.</dd>
            <dd><code>tvec1</code> - First translation vector.</dd>
            <dd><code>rvec2</code> - Second rotation vector.</dd>
            <dd><code>tvec2</code> - Second translation vector.</dd>
            <dd><code>rvec3</code> - Output rotation vector of the superposition.</dd>
            <dd><code>tvec3</code> - Output translation vector of the superposition.</dd>
            <dd><code>dr3dr1</code> - Optional output derivatives of <code>rvec3</code> or
                <code>tvec3</code> with regard to <code>rvec1</code>, <code>rvec2</code>,
                <code>tvec1</code> and <code>tvec2</code>, respectively.
            </dd>
            <dd><code>dr3dt1</code> - Optional output derivatives of <code>rvec3</code> or
                <code>tvec3</code> with regard to <code>rvec1</code>, <code>rvec2</code>,
                <code>tvec1</code> and <code>tvec2</code>, respectively.
            </dd>
            <dd><code>dr3dr2</code> - Optional output derivatives of <code>rvec3</code> or
                <code>tvec3</code> with regard to <code>rvec1</code>, <code>rvec2</code>,
                <code>tvec1</code> and <code>tvec2</code>, respectively.
            </dd>
            <dd><code>dr3dt2</code> - Optional output derivatives of <code>rvec3</code> or
                <code>tvec3</code> with regard to <code>rvec1</code>, <code>rvec2</code>,
                <code>tvec1</code> and <code>tvec2</code>, respectively.
            </dd>
            <dd><code>dt3dr1</code> - Optional output derivatives of <code>rvec3</code> or
                <code>tvec3</code> with regard to <code>rvec1</code>, <code>rvec2</code>,
                <code>tvec1</code> and <code>tvec2</code>, respectively.
            </dd>
            <dd><code>dt3dt1</code> - Optional output derivatives of <code>rvec3</code> or
                <code>tvec3</code> with regard to <code>rvec1</code>, <code>rvec2</code>,
                <code>tvec1</code> and <code>tvec2</code>, respectively.
            </dd>
            <dd><code>dt3dr2</code> - Optional output derivatives of <code>rvec3</code> or
                <code>tvec3</code> with regard to <code>rvec1</code>, <code>rvec2</code>,
                <code>tvec1</code> and <code>tvec2</code>, respectively.
            </dd>
            <dd><code>dt3dt2</code> - Optional output derivatives of <code>rvec3</code> or
                <code>tvec3</code> with regard to <code>rvec1</code>, <code>rvec2</code>,
                <code>tvec1</code> and <code>tvec2</code>, respectively.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#composert">org.opencv.calib3d.Calib3d.composeRT</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="computeCorrespondEpilines(org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>computeCorrespondEpilines</h4>
<pre>public static&nbsp;void&nbsp;computeCorrespondEpilines(<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points,
                             int&nbsp;whichImage,
                             <a href="../../../org/opencv/core/Mat.html"
                                title="class in org.opencv.core">Mat</a>&nbsp;F,
                             <a href="../../../org/opencv/core/Mat.html"
                                title="class in org.opencv.core">Mat</a>&nbsp;lines)</pre>
        <div class="block"><p>For points in an image of a stereo pair, computes the corresponding
            epilines
            in the other image.</p>

            <p>For every point in one of the two images of a stereo pair, the function finds
                the equation of the corresponding epipolar line in the other image.</p>

            <p>From the fundamental matrix definition (see "findFundamentalMat"), line
                <em>l^2_i</em> in the second image for the point <em>p^1_i</em> in the first
                image (when <code>whichImage=1</code>) is computed as:</p>

            <p><em>l^2_i = F p^1_i</em></p>

            <p>And vice versa, when <code>whichImage=2</code>, <em>l^1_i</em> is computed
                from <em>p^2_i</em> as:</p>

            <p><em>l^1_i = F^T p^2_i</em></p>

            <p>Line coefficients are defined up to a scale. They are normalized so that
                <em>a_i^2+b_i^2=1</em>.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>points</code> - Input points. <em>N x 1</em> or <em>1 x N</em> matrix of type
                <code>CV_32FC2</code> or <code>vector
                    <Point2f>
                </code>.
            </dd>
            <dd><code>whichImage</code> - Index of the image (1 or 2) that contains the
                <code>points</code>.
            </dd>
            <dd><code>F</code> - Fundamental matrix that can be estimated using "findFundamentalMat"
                or "stereoRectify".
            </dd>
            <dd><code>lines</code> - Output vector of the epipolar lines corresponding to the points
                in the other image. Each line <em>ax + by + c=0</em> is encoded by 3 numbers
                <em>(a, b, c)</em>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#computecorrespondepilines">org.opencv.calib3d.Calib3d.computeCorrespondEpilines</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="convertPointsFromHomogeneous(org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>convertPointsFromHomogeneous</h4>
<pre>public static&nbsp;void&nbsp;convertPointsFromHomogeneous(<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                <a href="../../../org/opencv/core/Mat.html"
                                   title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Converts points from homogeneous to Euclidean space.</p>

            <p>The function converts points homogeneous to Euclidean space using perspective
                projection. That is, each point <code>(x1, x2,... x(n-1), xn)</code> is
                converted to <code>(x1/xn, x2/xn,..., x(n-1)/xn)</code>. When
                <code>xn=0</code>, the output point coordinates will be <code>(0,0,0,...)</code>.
            </p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Input vector of <code>N</code>-dimensional points.</dd>
            <dd><code>dst</code> - Output vector of <code>N-1</code>-dimensional points.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#convertpointsfromhomogeneous">org.opencv.calib3d.Calib3d.convertPointsFromHomogeneous</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="convertPointsToHomogeneous(org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>convertPointsToHomogeneous</h4>
<pre>public static&nbsp;void&nbsp;convertPointsToHomogeneous(<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                              <a href="../../../org/opencv/core/Mat.html"
                                 title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Converts points from Euclidean to homogeneous space.</p>

            <p>The function converts points from Euclidean to homogeneous space by appending
                1's to the tuple of point coordinates. That is, each point <code>(x1, x2,...,
                    xn)</code> is converted to <code>(x1, x2,..., xn, 1)</code>.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Input vector of <code>N</code>-dimensional points.</dd>
            <dd><code>dst</code> - Output vector of <code>N+1</code>-dimensional points.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#convertpointstohomogeneous">org.opencv.calib3d.Calib3d.convertPointsToHomogeneous</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="correctMatches(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>correctMatches</h4>
<pre>public static&nbsp;void&nbsp;correctMatches(<a href="../../../org/opencv/core/Mat.html"
                                                    title="class in org.opencv.core">Mat</a>&nbsp;F,
                  <a href="../../../org/opencv/core/Mat.html"
                     title="class in org.opencv.core">Mat</a>&nbsp;points1,
                  <a href="../../../org/opencv/core/Mat.html"
                     title="class in org.opencv.core">Mat</a>&nbsp;points2,
                  <a href="../../../org/opencv/core/Mat.html"
                     title="class in org.opencv.core">Mat</a>&nbsp;newPoints1,
                  <a href="../../../org/opencv/core/Mat.html"
                     title="class in org.opencv.core">Mat</a>&nbsp;newPoints2)</pre>
        <div class="block"><p>Refines coordinates of corresponding points.</p>

            <p>The function implements the Optimal Triangulation Method (see Multiple View
                Geometry for details). For each given point correspondence points1[i] <->
                points2[i], and a fundamental matrix F, it computes the corrected
                correspondences newPoints1[i] <-> newPoints2[i] that minimize the geometric
                error <em>d(points1[i], newPoints1[i])^2 + d(points2[i],newPoints2[i])^2</em>
                (where <em>d(a,b)</em> is the geometric distance between points <em>a</em>
                and <em>b</em>) subject to the epipolar constraint <em>newPoints2^T * F *
                    newPoints1 = 0</em>.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>F</code> - 3x3 fundamental matrix.</dd>
            <dd><code>points1</code> - 1xN array containing the first set of points.</dd>
            <dd><code>points2</code> - 1xN array containing the second set of points.</dd>
            <dd><code>newPoints1</code> - The optimized points1.</dd>
            <dd><code>newPoints2</code> - The optimized points2.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#correctmatches">org.opencv.calib3d.Calib3d.correctMatches</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="decomposeProjectionMatrix(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>decomposeProjectionMatrix</h4>
<pre>public static&nbsp;void&nbsp;decomposeProjectionMatrix(<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;projMatrix,
                             <a href="../../../org/opencv/core/Mat.html"
                                title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                             <a href="../../../org/opencv/core/Mat.html"
                                title="class in org.opencv.core">Mat</a>&nbsp;rotMatrix,
                             <a href="../../../org/opencv/core/Mat.html"
                                title="class in org.opencv.core">Mat</a>&nbsp;transVect)</pre>
        <div class="block"><p>Decomposes a projection matrix into a rotation matrix and a camera
            matrix.</p>

            <p>The function computes a decomposition of a projection matrix into a
                calibration and a rotation matrix and the position of a camera.</p>

            <p>It optionally returns three rotation matrices, one for each axis, and three
                Euler angles that could be used in OpenGL. Note, there is always more than
                one sequence of rotations about the three principle axes that results in the
                same orientation of an object, eg. see [Slabaugh]. Returned tree rotation
                matrices and corresponding three Euler angules are only one of the possible
                solutions.</p>

            <p>The function is based on "RQDecomp3x3".</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>projMatrix</code> - 3x4 input projection matrix P.</dd>
            <dd><code>cameraMatrix</code> - Output 3x3 camera matrix K.</dd>
            <dd><code>rotMatrix</code> - Output 3x3 external rotation matrix R.</dd>
            <dd><code>transVect</code> - Output 4x1 translation vector T.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#decomposeprojectionmatrix">org.opencv.calib3d.Calib3d.decomposeProjectionMatrix</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="decomposeProjectionMatrix(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>decomposeProjectionMatrix</h4>
<pre>public static&nbsp;void&nbsp;decomposeProjectionMatrix(<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;projMatrix,
                             <a href="../../../org/opencv/core/Mat.html"
                                title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                             <a href="../../../org/opencv/core/Mat.html"
                                title="class in org.opencv.core">Mat</a>&nbsp;rotMatrix,
                             <a href="../../../org/opencv/core/Mat.html"
                                title="class in org.opencv.core">Mat</a>&nbsp;transVect,
                             <a href="../../../org/opencv/core/Mat.html"
                                title="class in org.opencv.core">Mat</a>&nbsp;rotMatrixX,
                             <a href="../../../org/opencv/core/Mat.html"
                                title="class in org.opencv.core">Mat</a>&nbsp;rotMatrixY,
                             <a href="../../../org/opencv/core/Mat.html"
                                title="class in org.opencv.core">Mat</a>&nbsp;rotMatrixZ,
                             <a href="../../../org/opencv/core/Mat.html"
                                title="class in org.opencv.core">Mat</a>&nbsp;eulerAngles)</pre>
        <div class="block"><p>Decomposes a projection matrix into a rotation matrix and a camera
            matrix.</p>

            <p>The function computes a decomposition of a projection matrix into a
                calibration and a rotation matrix and the position of a camera.</p>

            <p>It optionally returns three rotation matrices, one for each axis, and three
                Euler angles that could be used in OpenGL. Note, there is always more than
                one sequence of rotations about the three principle axes that results in the
                same orientation of an object, eg. see [Slabaugh]. Returned tree rotation
                matrices and corresponding three Euler angules are only one of the possible
                solutions.</p>

            <p>The function is based on "RQDecomp3x3".</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>projMatrix</code> - 3x4 input projection matrix P.</dd>
            <dd><code>cameraMatrix</code> - Output 3x3 camera matrix K.</dd>
            <dd><code>rotMatrix</code> - Output 3x3 external rotation matrix R.</dd>
            <dd><code>transVect</code> - Output 4x1 translation vector T.</dd>
            <dd><code>rotMatrixX</code> - a rotMatrixX</dd>
            <dd><code>rotMatrixY</code> - a rotMatrixY</dd>
            <dd><code>rotMatrixZ</code> - a rotMatrixZ</dd>
            <dd><code>eulerAngles</code> - Optional three-element vector containing three Euler
                angles of rotation in degrees.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#decomposeprojectionmatrix">org.opencv.calib3d.Calib3d.decomposeProjectionMatrix</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="drawChessboardCorners(org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.MatOfPoint2f, boolean)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>drawChessboardCorners</h4>
<pre>public static&nbsp;void&nbsp;drawChessboardCorners(<a href="../../../org/opencv/core/Mat.html"
                                                           title="class in org.opencv.core">Mat</a>&nbsp;image,
                         <a href="../../../org/opencv/core/Size.html"
                            title="class in org.opencv.core">Size</a>&nbsp;patternSize,
                         <a href="../../../org/opencv/core/MatOfPoint2f.html"
                            title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;corners,
                         boolean&nbsp;patternWasFound)</pre>
        <div class="block"><p>Renders the detected chessboard corners.</p>

            <p>The function draws individual chessboard corners detected either as red
                circles if the board was not found, or as colored corners connected with
                lines if the board was found.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>image</code> - Destination image. It must be an 8-bit color image.</dd>
            <dd><code>patternSize</code> - Number of inner corners per a chessboard row and column
                <code>(patternSize = cv.Size(points_per_row,points_per_column))</code>.
            </dd>
            <dd><code>corners</code> - Array of detected corners, the output of <code>findChessboardCorners</code>.
            </dd>
            <dd><code>patternWasFound</code> - Parameter indicating whether the complete board was
                found or not. The return value of "findChessboardCorners" should be passed
                here.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#drawchessboardcorners">org.opencv.calib3d.Calib3d.drawChessboardCorners</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="estimateAffine3D(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>estimateAffine3D</h4>
<pre>public static&nbsp;int&nbsp;estimateAffine3D(<a href="../../../org/opencv/core/Mat.html"
                                                     title="class in org.opencv.core">Mat</a>&nbsp;src,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;dst,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;out,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;inliers)</pre>
        <div class="block"><p>Computes an optimal affine transformation between two 3D point
            sets.</p>

            <p>The function estimates an optimal 3D affine transformation between two 3D
                point sets using the RANSAC algorithm.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - First input 3D point set.</dd>
            <dd><code>dst</code> - Second input 3D point set.</dd>
            <dd><code>out</code> - Output 3D affine transformation matrix <em>3 x 4</em>.</dd>
            <dd><code>inliers</code> - Output vector indicating which points are inliers.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#estimateaffine3d">org.opencv.calib3d.Calib3d.estimateAffine3D</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="estimateAffine3D(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>estimateAffine3D</h4>
<pre>public static&nbsp;int&nbsp;estimateAffine3D(<a href="../../../org/opencv/core/Mat.html"
                                                     title="class in org.opencv.core">Mat</a>&nbsp;src,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;dst,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;out,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;inliers,
                   double&nbsp;ransacThreshold,
                   double&nbsp;confidence)</pre>
        <div class="block"><p>Computes an optimal affine transformation between two 3D point
            sets.</p>

            <p>The function estimates an optimal 3D affine transformation between two 3D
                point sets using the RANSAC algorithm.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - First input 3D point set.</dd>
            <dd><code>dst</code> - Second input 3D point set.</dd>
            <dd><code>out</code> - Output 3D affine transformation matrix <em>3 x 4</em>.</dd>
            <dd><code>inliers</code> - Output vector indicating which points are inliers.</dd>
            <dd><code>ransacThreshold</code> - Maximum reprojection error in the RANSAC algorithm to
                consider a point as an inlier.
            </dd>
            <dd><code>confidence</code> - Confidence level, between 0 and 1, for the estimated
                transformation. Anything between 0.95 and 0.99 is usually good enough. Values
                too close to 1 can slow down the estimation significantly. Values lower than
                0.8-0.9 can result in an incorrectly estimated transformation.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#estimateaffine3d">org.opencv.calib3d.Calib3d.estimateAffine3D</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="filterSpeckles(org.opencv.core.Mat, double, int, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>filterSpeckles</h4>
<pre>public static&nbsp;void&nbsp;filterSpeckles(<a href="../../../org/opencv/core/Mat.html"
                                                    title="class in org.opencv.core">Mat</a>&nbsp;img,
                  double&nbsp;newVal,
                  int&nbsp;maxSpeckleSize,
                  double&nbsp;maxDiff)</pre>
        <div class="block"><p>Filters off small noise blobs (speckles) in the disparity map</p>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>img</code> - The input 16-bit signed disparity image</dd>
            <dd><code>newVal</code> - The disparity value used to paint-off the speckles</dd>
            <dd><code>maxSpeckleSize</code> - The maximum speckle size to consider it a speckle.
                Larger blobs are not affected by the algorithm
            </dd>
            <dd><code>maxDiff</code> - Maximum difference between neighbor disparity pixels to put
                them into the same blob. Note that since StereoBM, StereoSGBM and may be
                other algorithms return a fixed-point disparity map, where disparity values
                are multiplied by 16, this scale factor should be taken into account when
                specifying this parameter value.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#filterspeckles">org.opencv.calib3d.Calib3d.filterSpeckles</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="filterSpeckles(org.opencv.core.Mat, double, int, double, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>filterSpeckles</h4>
<pre>public static&nbsp;void&nbsp;filterSpeckles(<a href="../../../org/opencv/core/Mat.html"
                                                    title="class in org.opencv.core">Mat</a>&nbsp;img,
                  double&nbsp;newVal,
                  int&nbsp;maxSpeckleSize,
                  double&nbsp;maxDiff,
                  <a href="../../../org/opencv/core/Mat.html"
                     title="class in org.opencv.core">Mat</a>&nbsp;buf)</pre>
        <div class="block"><p>Filters off small noise blobs (speckles) in the disparity map</p>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>img</code> - The input 16-bit signed disparity image</dd>
            <dd><code>newVal</code> - The disparity value used to paint-off the speckles</dd>
            <dd><code>maxSpeckleSize</code> - The maximum speckle size to consider it a speckle.
                Larger blobs are not affected by the algorithm
            </dd>
            <dd><code>maxDiff</code> - Maximum difference between neighbor disparity pixels to put
                them into the same blob. Note that since StereoBM, StereoSGBM and may be
                other algorithms return a fixed-point disparity map, where disparity values
                are multiplied by 16, this scale factor should be taken into account when
                specifying this parameter value.
            </dd>
            <dd><code>buf</code> - The optional temporary buffer to avoid memory allocation within
                the function.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#filterspeckles">org.opencv.calib3d.Calib3d.filterSpeckles</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="findChessboardCorners(org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.MatOfPoint2f)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>findChessboardCorners</h4>
<pre>public static&nbsp;boolean&nbsp;findChessboardCorners(<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                            <a href="../../../org/opencv/core/Size.html"
                               title="class in org.opencv.core">Size</a>&nbsp;patternSize,
                            <a href="../../../org/opencv/core/MatOfPoint2f.html"
                               title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;corners)</pre>
        <div class="block"><p>Finds the positions of internal corners of the chessboard.</p>

            <p>The function attempts to determine whether the input image is a view of the
                chessboard pattern and locate the internal chessboard corners. The function
                returns a non-zero value if all of the corners are found and they are placed
                in a certain order (row by row, left to right in every row). Otherwise, if
                the function fails to find all the corners or reorder them, it returns 0. For
                example, a regular chessboard has 8 x 8 squares and 7 x 7 internal corners,
                that is, points where the black squares touch each other.
                The detected coordinates are approximate, and to determine their positions
                more accurately, the function calls "cornerSubPix".
                You also may use the function "cornerSubPix" with different parameters if
                returned coordinates are not accurate enough.
                Sample usage of detecting and drawing chessboard corners: <code></p>

            <p>// C++ code:</p>

            <p>Size patternsize(8,6); //interior number of corners</p>

            <p>Mat gray =....; //source image</p>

            <p>vector
                <Point2f> corners; //this will be filled by the detected corners
            </p>

            <p>//CALIB_CB_FAST_CHECK saves a lot of time on images</p>

            <p>//that do not contain any chessboard corners</p>

            <p>bool patternfound = findChessboardCorners(gray, patternsize, corners,</p>

            <p>CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE</p>

            <p>+ CALIB_CB_FAST_CHECK);</p>

            <p>if(patternfound)</p>

            <p>cornerSubPix(gray, corners, Size(11, 11), Size(-1, -1),</p>

            <p>TermCriteria(CV_TERMCRIT_EPS + CV_TERMCRIT_ITER, 30, 0.1));</p>

            <p>drawChessboardCorners(img, patternsize, Mat(corners), patternfound);</p>

            <p>Note: The function requires white space (like a square-thick border, the
                wider the better) around the board to make the detection more robust in
                various environments. Otherwise, if there is no border and the background is
                dark, the outer black squares cannot be segmented properly and so the square
                grouping and ordering algorithm fails.
                </code></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>image</code> - Source chessboard view. It must be an 8-bit grayscale or color
                image.
            </dd>
            <dd><code>patternSize</code> - Number of inner corners per a chessboard row and column
                <code>(patternSize = cvSize(points_per_row,points_per_colum) =
                    cvSize(columns,rows))</code>.
            </dd>
            <dd><code>corners</code> - Output array of detected corners.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#findchessboardcorners">org.opencv.calib3d.Calib3d.findChessboardCorners</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="findChessboardCorners(org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.MatOfPoint2f, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>findChessboardCorners</h4>
<pre>public static&nbsp;boolean&nbsp;findChessboardCorners(<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                            <a href="../../../org/opencv/core/Size.html"
                               title="class in org.opencv.core">Size</a>&nbsp;patternSize,
                            <a href="../../../org/opencv/core/MatOfPoint2f.html"
                               title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;corners,
                            int&nbsp;flags)</pre>
        <div class="block"><p>Finds the positions of internal corners of the chessboard.</p>

            <p>The function attempts to determine whether the input image is a view of the
                chessboard pattern and locate the internal chessboard corners. The function
                returns a non-zero value if all of the corners are found and they are placed
                in a certain order (row by row, left to right in every row). Otherwise, if
                the function fails to find all the corners or reorder them, it returns 0. For
                example, a regular chessboard has 8 x 8 squares and 7 x 7 internal corners,
                that is, points where the black squares touch each other.
                The detected coordinates are approximate, and to determine their positions
                more accurately, the function calls "cornerSubPix".
                You also may use the function "cornerSubPix" with different parameters if
                returned coordinates are not accurate enough.
                Sample usage of detecting and drawing chessboard corners: <code></p>

            <p>// C++ code:</p>

            <p>Size patternsize(8,6); //interior number of corners</p>

            <p>Mat gray =....; //source image</p>

            <p>vector
                <Point2f> corners; //this will be filled by the detected corners
            </p>

            <p>//CALIB_CB_FAST_CHECK saves a lot of time on images</p>

            <p>//that do not contain any chessboard corners</p>

            <p>bool patternfound = findChessboardCorners(gray, patternsize, corners,</p>

            <p>CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE</p>

            <p>+ CALIB_CB_FAST_CHECK);</p>

            <p>if(patternfound)</p>

            <p>cornerSubPix(gray, corners, Size(11, 11), Size(-1, -1),</p>

            <p>TermCriteria(CV_TERMCRIT_EPS + CV_TERMCRIT_ITER, 30, 0.1));</p>

            <p>drawChessboardCorners(img, patternsize, Mat(corners), patternfound);</p>

            <p>Note: The function requires white space (like a square-thick border, the
                wider the better) around the board to make the detection more robust in
                various environments. Otherwise, if there is no border and the background is
                dark, the outer black squares cannot be segmented properly and so the square
                grouping and ordering algorithm fails.
                </code></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>image</code> - Source chessboard view. It must be an 8-bit grayscale or color
                image.
            </dd>
            <dd><code>patternSize</code> - Number of inner corners per a chessboard row and column
                <code>(patternSize = cvSize(points_per_row,points_per_colum) =
                    cvSize(columns,rows))</code>.
            </dd>
            <dd><code>corners</code> - Output array of detected corners.</dd>
            <dd><code>flags</code> - Various operation flags that can be zero or a combination of
                the
                following values:
                <ul>
                    <li> CV_CALIB_CB_ADAPTIVE_THRESH Use adaptive thresholding to convert the
                        image to black and white, rather than a fixed threshold level (computed from
                        the average image brightness).
                    <li> CV_CALIB_CB_NORMALIZE_IMAGE Normalize the image gamma with
                        "equalizeHist" before applying fixed or adaptive thresholding.
                    <li> CV_CALIB_CB_FILTER_QUADS Use additional criteria (like contour area,
                        perimeter, square-like shape) to filter out false quads extracted at the
                        contour retrieval stage.
                    <li> CALIB_CB_FAST_CHECK Run a fast check on the image that looks for
                        chessboard corners, and shortcut the call if none is found. This can
                        drastically speed up the call in the degenerate condition when no chessboard
                        is observed.
                </ul>
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#findchessboardcorners">org.opencv.calib3d.Calib3d.findChessboardCorners</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="findCirclesGridDefault(org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>findCirclesGridDefault</h4>
<pre>public static&nbsp;boolean&nbsp;findCirclesGridDefault(<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                             <a href="../../../org/opencv/core/Size.html"
                                title="class in org.opencv.core">Size</a>&nbsp;patternSize,
                             <a href="../../../org/opencv/core/Mat.html"
                                title="class in org.opencv.core">Mat</a>&nbsp;centers)</pre>
    </li>
</ul>
<a name="findCirclesGridDefault(org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>findCirclesGridDefault</h4>
<pre>public static&nbsp;boolean&nbsp;findCirclesGridDefault(<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                             <a href="../../../org/opencv/core/Size.html"
                                title="class in org.opencv.core">Size</a>&nbsp;patternSize,
                             <a href="../../../org/opencv/core/Mat.html"
                                title="class in org.opencv.core">Mat</a>&nbsp;centers,
                             int&nbsp;flags)</pre>
    </li>
</ul>
<a name="findFundamentalMat(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>findFundamentalMat</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html"
                           title="class in org.opencv.core">Mat</a>&nbsp;findFundamentalMat(<a
        href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points1,
                     <a href="../../../org/opencv/core/MatOfPoint2f.html"
                        title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points2)</pre>
        <div class="block"><p>Calculates a fundamental matrix from the corresponding points in two
            images.</p>

            <p>The epipolar geometry is described by the following equation:</p>

            <p><em>[p_2; 1]^T F [p_1; 1] = 0</em></p>

            <p>where <em>F</em> is a fundamental matrix, <em>p_1</em> and <em>p_2</em> are
                corresponding points in the first and the second images, respectively.</p>

            <p>The function calculates the fundamental matrix using one of four methods
                listed above and returns the found fundamental matrix. Normally just one
                matrix is found. But in case of the 7-point algorithm, the function may
                return up to 3 solutions (<em>9 x 3</em> matrix that stores all 3 matrices
                sequentially).</p>

            <p>The calculated fundamental matrix may be passed further to
                "computeCorrespondEpilines"
                that finds the epipolar lines corresponding to the specified points. It can
                also be passed to"stereoRectifyUncalibrated" to compute the rectification
                transformation.
                <code></p>

            <p>// C++ code:</p>

            <p>// Example. Estimation of fundamental matrix using the RANSAC algorithm</p>

            <p>int point_count = 100;</p>

            <p>vector
                <Point2f> points1(point_count);
            </p>

            <p>vector
                <Point2f> points2(point_count);
            </p>

            <p>// initialize the points here... * /</p>

            <p>for(int i = 0; i < point_count; i++)</p>


            <p>points1[i] =...;</p>

            <p>points2[i] =...;</p>


            <p>Mat fundamental_matrix =</p>

            <p>findFundamentalMat(points1, points2, FM_RANSAC, 3, 0.99);</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>points1</code> - Array of <code>N</code> points from the first image. The
                point
                coordinates should be floating-point (single or double precision).
            </dd>
            <dd><code>points2</code> - Array of the second image points of the same size and format
                as <code>points1</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#findfundamentalmat">org.opencv.calib3d.Calib3d.findFundamentalMat</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="findFundamentalMat(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, int, double, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>findFundamentalMat</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html"
                           title="class in org.opencv.core">Mat</a>&nbsp;findFundamentalMat(<a
        href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points1,
                     <a href="../../../org/opencv/core/MatOfPoint2f.html"
                        title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points2,
                     int&nbsp;method,
                     double&nbsp;param1,
                     double&nbsp;param2)</pre>
        <div class="block"><p>Calculates a fundamental matrix from the corresponding points in two
            images.</p>

            <p>The epipolar geometry is described by the following equation:</p>

            <p><em>[p_2; 1]^T F [p_1; 1] = 0</em></p>

            <p>where <em>F</em> is a fundamental matrix, <em>p_1</em> and <em>p_2</em> are
                corresponding points in the first and the second images, respectively.</p>

            <p>The function calculates the fundamental matrix using one of four methods
                listed above and returns the found fundamental matrix. Normally just one
                matrix is found. But in case of the 7-point algorithm, the function may
                return up to 3 solutions (<em>9 x 3</em> matrix that stores all 3 matrices
                sequentially).</p>

            <p>The calculated fundamental matrix may be passed further to
                "computeCorrespondEpilines"
                that finds the epipolar lines corresponding to the specified points. It can
                also be passed to"stereoRectifyUncalibrated" to compute the rectification
                transformation.
                <code></p>

            <p>// C++ code:</p>

            <p>// Example. Estimation of fundamental matrix using the RANSAC algorithm</p>

            <p>int point_count = 100;</p>

            <p>vector
                <Point2f> points1(point_count);
            </p>

            <p>vector
                <Point2f> points2(point_count);
            </p>

            <p>// initialize the points here... * /</p>

            <p>for(int i = 0; i < point_count; i++)</p>


            <p>points1[i] =...;</p>

            <p>points2[i] =...;</p>


            <p>Mat fundamental_matrix =</p>

            <p>findFundamentalMat(points1, points2, FM_RANSAC, 3, 0.99);</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>points1</code> - Array of <code>N</code> points from the first image. The
                point
                coordinates should be floating-point (single or double precision).
            </dd>
            <dd><code>points2</code> - Array of the second image points of the same size and format
                as <code>points1</code>.
            </dd>
            <dd><code>method</code> - Method for computing a fundamental matrix.
                <ul>
                    <li> CV_FM_7POINT for a 7-point algorithm. <em>N = 7</em>
                    <li> CV_FM_8POINT for an 8-point algorithm. <em>N >= 8</em>
                    <li> CV_FM_RANSAC for the RANSAC algorithm. <em>N >= 8</em>
                    <li> CV_FM_LMEDS for the LMedS algorithm. <em>N >= 8</em>
                </ul>
            </dd>
            <dd><code>param1</code> - Parameter used for RANSAC. It is the maximum distance from a
                point to an epipolar line in pixels, beyond which the point is considered an
                outlier and is not used for computing the final fundamental matrix. It can be
                set to something like 1-3, depending on the accuracy of the point
                localization, image resolution, and the image noise.
            </dd>
            <dd><code>param2</code> - Parameter used for the RANSAC or LMedS methods only. It
                specifies a desirable level of confidence (probability) that the estimated
                matrix is correct.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#findfundamentalmat">org.opencv.calib3d.Calib3d.findFundamentalMat</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="findFundamentalMat(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, int, double, double, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>findFundamentalMat</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html"
                           title="class in org.opencv.core">Mat</a>&nbsp;findFundamentalMat(<a
        href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points1,
                     <a href="../../../org/opencv/core/MatOfPoint2f.html"
                        title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points2,
                     int&nbsp;method,
                     double&nbsp;param1,
                     double&nbsp;param2,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
        <div class="block"><p>Calculates a fundamental matrix from the corresponding points in two
            images.</p>

            <p>The epipolar geometry is described by the following equation:</p>

            <p><em>[p_2; 1]^T F [p_1; 1] = 0</em></p>

            <p>where <em>F</em> is a fundamental matrix, <em>p_1</em> and <em>p_2</em> are
                corresponding points in the first and the second images, respectively.</p>

            <p>The function calculates the fundamental matrix using one of four methods
                listed above and returns the found fundamental matrix. Normally just one
                matrix is found. But in case of the 7-point algorithm, the function may
                return up to 3 solutions (<em>9 x 3</em> matrix that stores all 3 matrices
                sequentially).</p>

            <p>The calculated fundamental matrix may be passed further to
                "computeCorrespondEpilines"
                that finds the epipolar lines corresponding to the specified points. It can
                also be passed to"stereoRectifyUncalibrated" to compute the rectification
                transformation.
                <code></p>

            <p>// C++ code:</p>

            <p>// Example. Estimation of fundamental matrix using the RANSAC algorithm</p>

            <p>int point_count = 100;</p>

            <p>vector
                <Point2f> points1(point_count);
            </p>

            <p>vector
                <Point2f> points2(point_count);
            </p>

            <p>// initialize the points here... * /</p>

            <p>for(int i = 0; i < point_count; i++)</p>


            <p>points1[i] =...;</p>

            <p>points2[i] =...;</p>


            <p>Mat fundamental_matrix =</p>

            <p>findFundamentalMat(points1, points2, FM_RANSAC, 3, 0.99);</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>points1</code> - Array of <code>N</code> points from the first image. The
                point
                coordinates should be floating-point (single or double precision).
            </dd>
            <dd><code>points2</code> - Array of the second image points of the same size and format
                as <code>points1</code>.
            </dd>
            <dd><code>method</code> - Method for computing a fundamental matrix.
                <ul>
                    <li> CV_FM_7POINT for a 7-point algorithm. <em>N = 7</em>
                    <li> CV_FM_8POINT for an 8-point algorithm. <em>N >= 8</em>
                    <li> CV_FM_RANSAC for the RANSAC algorithm. <em>N >= 8</em>
                    <li> CV_FM_LMEDS for the LMedS algorithm. <em>N >= 8</em>
                </ul>
            </dd>
            <dd><code>param1</code> - Parameter used for RANSAC. It is the maximum distance from a
                point to an epipolar line in pixels, beyond which the point is considered an
                outlier and is not used for computing the final fundamental matrix. It can be
                set to something like 1-3, depending on the accuracy of the point
                localization, image resolution, and the image noise.
            </dd>
            <dd><code>param2</code> - Parameter used for the RANSAC or LMedS methods only. It
                specifies a desirable level of confidence (probability) that the estimated
                matrix is correct.
            </dd>
            <dd><code>mask</code> - a mask</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#findfundamentalmat">org.opencv.calib3d.Calib3d.findFundamentalMat</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="findHomography(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>findHomography</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html"
                           title="class in org.opencv.core">Mat</a>&nbsp;findHomography(<a
        href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;srcPoints,
                 <a href="../../../org/opencv/core/MatOfPoint2f.html"
                    title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;dstPoints)</pre>
        <div class="block"><p>Finds a perspective transformation between two planes.</p>

            <p>The functions find and return the perspective transformation <em>H</em>
                between the source and the destination planes:</p>

            <p><em>s_i [x'_i y'_i 1] ~ H [x_i y_i 1]</em></p>

            <p>so that the back-projection error</p>

            <p><em>sum _i(x'_i- (h_11 x_i + h_12 y_i + h_13)/(h_(31) x_i + h_32 y_i +
                h_33))^2+ (y'_i- (h_21 x_i + h_22 y_i + h_23)/(h_(31) x_i + h_32 y_i +
                h_33))^2</em></p>

            <p>is minimized. If the parameter <code>method</code> is set to the default
                value 0, the function uses all the point pairs to compute an initial
                homography estimate with a simple least-squares scheme.</p>

            <p>However, if not all of the point pairs (<em>srcPoints_i</em>,
                <em>dstPoints_i</em>) fit the rigid perspective transformation (that is,
                there are some outliers), this initial estimate will be poor.
                In this case, you can use one of the two robust methods. Both methods,
                <code>RANSAC</code> and <code>LMeDS</code>, try many different random subsets
                of the corresponding point pairs (of four pairs each), estimate the
                homography matrix using this subset and a simple least-square algorithm, and
                then compute the quality/goodness of the computed homography (which is the
                number of inliers for RANSAC or the median re-projection error for LMeDs).
                The best subset is then used to produce the initial estimate of the
                homography matrix and the mask of inliers/outliers.</p>

            <p>Regardless of the method, robust or not, the computed homography matrix is
                refined further (using inliers only in case of a robust method) with the
                Levenberg-Marquardt method to reduce the re-projection error even more.</p>

            <p>The method <code>RANSAC</code> can handle practically any ratio of outliers
                but it needs a threshold to distinguish inliers from outliers.
                The method <code>LMeDS</code> does not need any threshold but it works
                correctly only when there are more than 50% of inliers. Finally, if there are
                no outliers and the noise is rather small, use the default method
                (<code>method=0</code>).</p>

            <p>The function is used to find initial intrinsic and extrinsic matrices.
                Homography matrix is determined up to a scale. Thus, it is normalized so that
                <em>h_33=1</em>. Note that whenever an H matrix cannot be estimated, an empty
                one will be returned.</p>

            <p>Note:</p>
            <ul>
                <li> A example on calculating a homography for image matching can be found
                    at opencv_source_code/samples/cpp/video_homography.cpp
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>srcPoints</code> - Coordinates of the points in the original plane, a matrix
                of
                the type <code>CV_32FC2</code> or <code>vector
                    <Point2f>
                </code>.
            </dd>
            <dd><code>dstPoints</code> - Coordinates of the points in the target plane, a matrix of
                the type <code>CV_32FC2</code> or a <code>vector
                    <Point2f>
                </code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#findhomography">org.opencv.calib3d.Calib3d.findHomography</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#warpPerspective(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int, org.opencv.core.Scalar)"><code>Imgproc.warpPerspective(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/core/Core.html#perspectiveTransform(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Core.perspectiveTransform(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/video/Video.html#estimateRigidTransform(org.opencv.core.Mat, org.opencv.core.Mat, boolean)"><code>Video.estimateRigidTransform(org.opencv.core.Mat,
                    org.opencv.core.Mat, boolean)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#getAffineTransform(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f)"><code>Imgproc.getAffineTransform(org.opencv.core.MatOfPoint2f,
                    org.opencv.core.MatOfPoint2f)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#getPerspectiveTransform(org.opencv.core.Mat, org.opencv.core.Mat)"><code>Imgproc.getPerspectiveTransform(org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="findHomography(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, int, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>findHomography</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html"
                           title="class in org.opencv.core">Mat</a>&nbsp;findHomography(<a
        href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;srcPoints,
                 <a href="../../../org/opencv/core/MatOfPoint2f.html"
                    title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;dstPoints,
                 int&nbsp;method,
                 double&nbsp;ransacReprojThreshold)</pre>
        <div class="block"><p>Finds a perspective transformation between two planes.</p>

            <p>The functions find and return the perspective transformation <em>H</em>
                between the source and the destination planes:</p>

            <p><em>s_i [x'_i y'_i 1] ~ H [x_i y_i 1]</em></p>

            <p>so that the back-projection error</p>

            <p><em>sum _i(x'_i- (h_11 x_i + h_12 y_i + h_13)/(h_(31) x_i + h_32 y_i +
                h_33))^2+ (y'_i- (h_21 x_i + h_22 y_i + h_23)/(h_(31) x_i + h_32 y_i +
                h_33))^2</em></p>

            <p>is minimized. If the parameter <code>method</code> is set to the default
                value 0, the function uses all the point pairs to compute an initial
                homography estimate with a simple least-squares scheme.</p>

            <p>However, if not all of the point pairs (<em>srcPoints_i</em>,
                <em>dstPoints_i</em>) fit the rigid perspective transformation (that is,
                there are some outliers), this initial estimate will be poor.
                In this case, you can use one of the two robust methods. Both methods,
                <code>RANSAC</code> and <code>LMeDS</code>, try many different random subsets
                of the corresponding point pairs (of four pairs each), estimate the
                homography matrix using this subset and a simple least-square algorithm, and
                then compute the quality/goodness of the computed homography (which is the
                number of inliers for RANSAC or the median re-projection error for LMeDs).
                The best subset is then used to produce the initial estimate of the
                homography matrix and the mask of inliers/outliers.</p>

            <p>Regardless of the method, robust or not, the computed homography matrix is
                refined further (using inliers only in case of a robust method) with the
                Levenberg-Marquardt method to reduce the re-projection error even more.</p>

            <p>The method <code>RANSAC</code> can handle practically any ratio of outliers
                but it needs a threshold to distinguish inliers from outliers.
                The method <code>LMeDS</code> does not need any threshold but it works
                correctly only when there are more than 50% of inliers. Finally, if there are
                no outliers and the noise is rather small, use the default method
                (<code>method=0</code>).</p>

            <p>The function is used to find initial intrinsic and extrinsic matrices.
                Homography matrix is determined up to a scale. Thus, it is normalized so that
                <em>h_33=1</em>. Note that whenever an H matrix cannot be estimated, an empty
                one will be returned.</p>

            <p>Note:</p>
            <ul>
                <li> A example on calculating a homography for image matching can be found
                    at opencv_source_code/samples/cpp/video_homography.cpp
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>srcPoints</code> - Coordinates of the points in the original plane, a matrix
                of
                the type <code>CV_32FC2</code> or <code>vector
                    <Point2f>
                </code>.
            </dd>
            <dd><code>dstPoints</code> - Coordinates of the points in the target plane, a matrix of
                the type <code>CV_32FC2</code> or a <code>vector
                    <Point2f>
                </code>.
            </dd>
            <dd><code>method</code> - Method used to computed a homography matrix. The following
                methods are possible:
                <ul>
                    <li> 0 - a regular method using all the points
                    <li> CV_RANSAC - RANSAC-based robust method
                    <li> CV_LMEDS - Least-Median robust method
                </ul>
            </dd>
            <dd><code>ransacReprojThreshold</code> - Maximum allowed reprojection error to treat a
                point pair as an inlier (used in the RANSAC method only). That is, if

                <p><em>| dstPoints _i - convertPointsHomogeneous(H * srcPoints _i)| &gt
                    ransacReprojThreshold</em></p>

                <p>then the point <em>i</em> is considered an outlier. If <code>srcPoints</code>
                    and <code>dstPoints</code> are measured in pixels, it usually makes sense to
                    set this parameter somewhere in the range of 1 to 10.</p></dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#findhomography">org.opencv.calib3d.Calib3d.findHomography</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#warpPerspective(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int, org.opencv.core.Scalar)"><code>Imgproc.warpPerspective(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/core/Core.html#perspectiveTransform(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Core.perspectiveTransform(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/video/Video.html#estimateRigidTransform(org.opencv.core.Mat, org.opencv.core.Mat, boolean)"><code>Video.estimateRigidTransform(org.opencv.core.Mat,
                    org.opencv.core.Mat, boolean)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#getAffineTransform(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f)"><code>Imgproc.getAffineTransform(org.opencv.core.MatOfPoint2f,
                    org.opencv.core.MatOfPoint2f)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#getPerspectiveTransform(org.opencv.core.Mat, org.opencv.core.Mat)"><code>Imgproc.getPerspectiveTransform(org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="findHomography(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, int, double, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>findHomography</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html"
                           title="class in org.opencv.core">Mat</a>&nbsp;findHomography(<a
        href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;srcPoints,
                 <a href="../../../org/opencv/core/MatOfPoint2f.html"
                    title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;dstPoints,
                 int&nbsp;method,
                 double&nbsp;ransacReprojThreshold,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
        <div class="block"><p>Finds a perspective transformation between two planes.</p>

            <p>The functions find and return the perspective transformation <em>H</em>
                between the source and the destination planes:</p>

            <p><em>s_i [x'_i y'_i 1] ~ H [x_i y_i 1]</em></p>

            <p>so that the back-projection error</p>

            <p><em>sum _i(x'_i- (h_11 x_i + h_12 y_i + h_13)/(h_(31) x_i + h_32 y_i +
                h_33))^2+ (y'_i- (h_21 x_i + h_22 y_i + h_23)/(h_(31) x_i + h_32 y_i +
                h_33))^2</em></p>

            <p>is minimized. If the parameter <code>method</code> is set to the default
                value 0, the function uses all the point pairs to compute an initial
                homography estimate with a simple least-squares scheme.</p>

            <p>However, if not all of the point pairs (<em>srcPoints_i</em>,
                <em>dstPoints_i</em>) fit the rigid perspective transformation (that is,
                there are some outliers), this initial estimate will be poor.
                In this case, you can use one of the two robust methods. Both methods,
                <code>RANSAC</code> and <code>LMeDS</code>, try many different random subsets
                of the corresponding point pairs (of four pairs each), estimate the
                homography matrix using this subset and a simple least-square algorithm, and
                then compute the quality/goodness of the computed homography (which is the
                number of inliers for RANSAC or the median re-projection error for LMeDs).
                The best subset is then used to produce the initial estimate of the
                homography matrix and the mask of inliers/outliers.</p>

            <p>Regardless of the method, robust or not, the computed homography matrix is
                refined further (using inliers only in case of a robust method) with the
                Levenberg-Marquardt method to reduce the re-projection error even more.</p>

            <p>The method <code>RANSAC</code> can handle practically any ratio of outliers
                but it needs a threshold to distinguish inliers from outliers.
                The method <code>LMeDS</code> does not need any threshold but it works
                correctly only when there are more than 50% of inliers. Finally, if there are
                no outliers and the noise is rather small, use the default method
                (<code>method=0</code>).</p>

            <p>The function is used to find initial intrinsic and extrinsic matrices.
                Homography matrix is determined up to a scale. Thus, it is normalized so that
                <em>h_33=1</em>. Note that whenever an H matrix cannot be estimated, an empty
                one will be returned.</p>

            <p>Note:</p>
            <ul>
                <li> A example on calculating a homography for image matching can be found
                    at opencv_source_code/samples/cpp/video_homography.cpp
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>srcPoints</code> - Coordinates of the points in the original plane, a matrix
                of
                the type <code>CV_32FC2</code> or <code>vector
                    <Point2f>
                </code>.
            </dd>
            <dd><code>dstPoints</code> - Coordinates of the points in the target plane, a matrix of
                the type <code>CV_32FC2</code> or a <code>vector
                    <Point2f>
                </code>.
            </dd>
            <dd><code>method</code> - Method used to computed a homography matrix. The following
                methods are possible:
                <ul>
                    <li> 0 - a regular method using all the points
                    <li> CV_RANSAC - RANSAC-based robust method
                    <li> CV_LMEDS - Least-Median robust method
                </ul>
            </dd>
            <dd><code>ransacReprojThreshold</code> - Maximum allowed reprojection error to treat a
                point pair as an inlier (used in the RANSAC method only). That is, if

                <p><em>| dstPoints _i - convertPointsHomogeneous(H * srcPoints _i)| &gt
                    ransacReprojThreshold</em></p>

                <p>then the point <em>i</em> is considered an outlier. If <code>srcPoints</code>
                    and <code>dstPoints</code> are measured in pixels, it usually makes sense to
                    set this parameter somewhere in the range of 1 to 10.</p></dd>
            <dd><code>mask</code> - Optional output mask set by a robust method
                (<code>CV_RANSAC</code>
                or <code>CV_LMEDS</code>). Note that the input mask values are ignored.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#findhomography">org.opencv.calib3d.Calib3d.findHomography</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#warpPerspective(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int, org.opencv.core.Scalar)"><code>Imgproc.warpPerspective(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/core/Core.html#perspectiveTransform(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Core.perspectiveTransform(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/video/Video.html#estimateRigidTransform(org.opencv.core.Mat, org.opencv.core.Mat, boolean)"><code>Video.estimateRigidTransform(org.opencv.core.Mat,
                    org.opencv.core.Mat, boolean)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#getAffineTransform(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f)"><code>Imgproc.getAffineTransform(org.opencv.core.MatOfPoint2f,
                    org.opencv.core.MatOfPoint2f)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#getPerspectiveTransform(org.opencv.core.Mat, org.opencv.core.Mat)"><code>Imgproc.getPerspectiveTransform(org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="getOptimalNewCameraMatrix(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>getOptimalNewCameraMatrix</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html"
                           title="class in org.opencv.core">Mat</a>&nbsp;getOptimalNewCameraMatrix(<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                            <a href="../../../org/opencv/core/Mat.html"
                               title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                            <a href="../../../org/opencv/core/Size.html"
                               title="class in org.opencv.core">Size</a>&nbsp;imageSize,
                            double&nbsp;alpha)</pre>
        <div class="block"><p>Returns the new camera matrix based on the free scaling parameter.</p>

            <p>The function computes and returns the optimal new camera matrix based on the
                free scaling parameter. By varying this parameter, you may retrieve only
                sensible pixels <code>alpha=0</code>, keep all the original image pixels if
                there is valuable information in the corners <code>alpha=1</code>, or get
                something in between. When <code>alpha>0</code>, the undistortion result is
                likely to have some black pixels corresponding to "virtual" pixels outside of
                the captured distorted image. The original camera matrix, distortion
                coefficients, the computed new camera matrix, and <code>newImageSize</code>
                should be passed to "initUndistortRectifyMap" to produce the maps for
                "remap".</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>cameraMatrix</code> - Input camera matrix.</dd>
            <dd><code>distCoeffs</code> - Input vector of distortion coefficients <em>(k_1, k_2,
                p_1,
                p_2[, k_3[, k_4, k_5, k_6]])</em> of 4, 5, or 8 elements. If the vector is
                NULL/empty, the zero distortion coefficients are assumed.
            </dd>
            <dd><code>imageSize</code> - Original image size.</dd>
            <dd><code>alpha</code> - Free scaling parameter between 0 (when all the pixels in the
                undistorted image are valid) and 1 (when all the source image pixels are
                retained in the undistorted image). See "stereoRectify" for details.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#getoptimalnewcameramatrix">org.opencv.calib3d.Calib3d.getOptimalNewCameraMatrix</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="getOptimalNewCameraMatrix(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double, org.opencv.core.Size, org.opencv.core.Rect, boolean)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>getOptimalNewCameraMatrix</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html"
                           title="class in org.opencv.core">Mat</a>&nbsp;getOptimalNewCameraMatrix(<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                            <a href="../../../org/opencv/core/Mat.html"
                               title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                            <a href="../../../org/opencv/core/Size.html"
                               title="class in org.opencv.core">Size</a>&nbsp;imageSize,
                            double&nbsp;alpha,
                            <a href="../../../org/opencv/core/Size.html"
                               title="class in org.opencv.core">Size</a>&nbsp;newImgSize,
                            <a href="../../../org/opencv/core/Rect.html"
                               title="class in org.opencv.core">Rect</a>&nbsp;validPixROI,
                            boolean&nbsp;centerPrincipalPoint)</pre>
        <div class="block"><p>Returns the new camera matrix based on the free scaling parameter.</p>

            <p>The function computes and returns the optimal new camera matrix based on the
                free scaling parameter. By varying this parameter, you may retrieve only
                sensible pixels <code>alpha=0</code>, keep all the original image pixels if
                there is valuable information in the corners <code>alpha=1</code>, or get
                something in between. When <code>alpha>0</code>, the undistortion result is
                likely to have some black pixels corresponding to "virtual" pixels outside of
                the captured distorted image. The original camera matrix, distortion
                coefficients, the computed new camera matrix, and <code>newImageSize</code>
                should be passed to "initUndistortRectifyMap" to produce the maps for
                "remap".</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>cameraMatrix</code> - Input camera matrix.</dd>
            <dd><code>distCoeffs</code> - Input vector of distortion coefficients <em>(k_1, k_2,
                p_1,
                p_2[, k_3[, k_4, k_5, k_6]])</em> of 4, 5, or 8 elements. If the vector is
                NULL/empty, the zero distortion coefficients are assumed.
            </dd>
            <dd><code>imageSize</code> - Original image size.</dd>
            <dd><code>alpha</code> - Free scaling parameter between 0 (when all the pixels in the
                undistorted image are valid) and 1 (when all the source image pixels are
                retained in the undistorted image). See "stereoRectify" for details.
            </dd>
            <dd><code>newImgSize</code> - a newImgSize</dd>
            <dd><code>validPixROI</code> - Optional output rectangle that outlines all-good-pixels
                region in the undistorted image. See <code>roi1, roi2</code> description in
                "stereoRectify".
            </dd>
            <dd><code>centerPrincipalPoint</code> - Optional flag that indicates whether in the new
                camera matrix the principal point should be at the image center or not. By
                default, the principal point is chosen to best fit a subset of the source
                image (determined by <code>alpha</code>) to the corrected image.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#getoptimalnewcameramatrix">org.opencv.calib3d.Calib3d.getOptimalNewCameraMatrix</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="getValidDisparityROI(org.opencv.core.Rect, org.opencv.core.Rect, int, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>getValidDisparityROI</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Rect.html"
                           title="class in org.opencv.core">Rect</a>&nbsp;getValidDisparityROI(<a
        href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;roi1,
                        <a href="../../../org/opencv/core/Rect.html"
                           title="class in org.opencv.core">Rect</a>&nbsp;roi2,
                        int&nbsp;minDisparity,
                        int&nbsp;numberOfDisparities,
                        int&nbsp;SADWindowSize)</pre>
    </li>
</ul>
<a name="initCameraMatrix2D(java.util.List, java.util.List, org.opencv.core.Size)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>initCameraMatrix2D</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html"
                           title="class in org.opencv.core">Mat</a>&nbsp;initCameraMatrix2D(java.util.List&lt;<a
        href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&gt;&nbsp;objectPoints,
                     java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint2f.html"
                                          title="class in org.opencv.core">MatOfPoint2f</a>&gt;&nbsp;imagePoints,
                     <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imageSize)</pre>
        <div class="block"><p>Finds an initial camera matrix from 3D-2D point correspondences.</p>

            <p>The function estimates and returns an initial camera matrix for the camera
                calibration process.
                Currently, the function only supports planar calibration patterns, which are
                patterns where each object point has z-coordinate =0.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>objectPoints</code> - Vector of vectors of the calibration pattern points in
                the calibration pattern coordinate space. In the old interface all the
                per-view vectors are concatenated. See "calibrateCamera" for details.
            </dd>
            <dd><code>imagePoints</code> - Vector of vectors of the projections of the calibration
                pattern points. In the old interface all the per-view vectors are
                concatenated.
            </dd>
            <dd><code>imageSize</code> - Image size in pixels used to initialize the principal
                point.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#initcameramatrix2d">org.opencv.calib3d.Calib3d.initCameraMatrix2D</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="initCameraMatrix2D(java.util.List, java.util.List, org.opencv.core.Size, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>initCameraMatrix2D</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html"
                           title="class in org.opencv.core">Mat</a>&nbsp;initCameraMatrix2D(java.util.List&lt;<a
        href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&gt;&nbsp;objectPoints,
                     java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint2f.html"
                                          title="class in org.opencv.core">MatOfPoint2f</a>&gt;&nbsp;imagePoints,
                     <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imageSize,
                     double&nbsp;aspectRatio)</pre>
        <div class="block"><p>Finds an initial camera matrix from 3D-2D point correspondences.</p>

            <p>The function estimates and returns an initial camera matrix for the camera
                calibration process.
                Currently, the function only supports planar calibration patterns, which are
                patterns where each object point has z-coordinate =0.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>objectPoints</code> - Vector of vectors of the calibration pattern points in
                the calibration pattern coordinate space. In the old interface all the
                per-view vectors are concatenated. See "calibrateCamera" for details.
            </dd>
            <dd><code>imagePoints</code> - Vector of vectors of the projections of the calibration
                pattern points. In the old interface all the per-view vectors are
                concatenated.
            </dd>
            <dd><code>imageSize</code> - Image size in pixels used to initialize the principal
                point.
            </dd>
            <dd><code>aspectRatio</code> - If it is zero or negative, both <em>f_x</em> and
                <em>f_y</em> are estimated independently. Otherwise, <em>f_x = f_y *
                    aspectRatio</em>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#initcameramatrix2d">org.opencv.calib3d.Calib3d.initCameraMatrix2D</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="matMulDeriv(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>matMulDeriv</h4>
<pre>public static&nbsp;void&nbsp;matMulDeriv(<a href="../../../org/opencv/core/Mat.html"
                                                 title="class in org.opencv.core">Mat</a>&nbsp;A,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;B,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dABdA,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dABdB)</pre>
        <div class="block"><p>Computes partial derivatives of the matrix product for each multiplied
            matrix.</p>

            <p>The function computes partial derivatives of the elements of the matrix
                product <em>A*B</em> with regard to the elements of each of the two input
                matrices. The function is used to compute the Jacobian matrices in
                "stereoCalibrate" but can also be used in any other similar optimization
                function.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>A</code> - First multiplied matrix.</dd>
            <dd><code>B</code> - Second multiplied matrix.</dd>
            <dd><code>dABdA</code> - First output derivative matrix <code>d(A*B)/dA</code> of size
                <em>A.rows*B.cols x (A.rows*A.cols)</em>.
            </dd>
            <dd><code>dABdB</code> - Second output derivative matrix <code>d(A*B)/dB</code> of size
                <em>A.rows*B.cols x (B.rows*B.cols)</em>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#matmulderiv">org.opencv.calib3d.Calib3d.matMulDeriv</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="projectPoints(org.opencv.core.MatOfPoint3f, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfDouble, org.opencv.core.MatOfPoint2f)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>projectPoints</h4>
<pre>public static&nbsp;void&nbsp;projectPoints(<a href="../../../org/opencv/core/MatOfPoint3f.html"
                                                   title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                 <a href="../../../org/opencv/core/MatOfDouble.html"
                    title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
                 <a href="../../../org/opencv/core/MatOfPoint2f.html"
                    title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints)</pre>
        <div class="block"><p>Projects 3D points to an image plane.</p>

            <p>The function computes projections of 3D points to the image plane given
                intrinsic and extrinsic camera parameters. Optionally, the function computes
                Jacobians - matrices of partial derivatives of image points coordinates (as
                functions of all the input parameters) with respect to the particular
                parameters, intrinsic and/or extrinsic. The Jacobians are used during the
                global optimization in "calibrateCamera", "solvePnP", and "stereoCalibrate".
                The function itself can also be used to compute a re-projection error given
                the current intrinsic and extrinsic parameters.</p>

            <p>Note: By setting <code>rvec=tvec=(0,0,0)</code> or by setting
                <code>cameraMatrix</code> to a 3x3 identity matrix, or by passing zero
                distortion coefficients, you can get various useful partial cases of the
                function. This means that you can compute the distorted coordinates for a
                sparse set of points or apply a perspective transformation (and also compute
                the derivatives) in the ideal zero-distortion setup.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>objectPoints</code> - Array of object points, 3xN/Nx3 1-channel or 1xN/Nx1
                3-channel (or <code>vector
                    <Point3f>
                </code>), where N is the number of points
                in the view.
            </dd>
            <dd><code>rvec</code> - Rotation vector. See "Rodrigues" for details.</dd>
            <dd><code>tvec</code> - Translation vector.</dd>
            <dd><code>cameraMatrix</code> - Camera matrix <em>A =
                <p>|f_x 0 c_x|
                    |0 f_y c_y|
                    |0 0 _1|
            </em>.</p></dd>
            <dd><code>distCoeffs</code> - Input vector of distortion coefficients <em>(k_1, k_2,
                p_1,
                p_2[, k_3[, k_4, k_5, k_6]])</em> of 4, 5, or 8 elements. If the vector is
                NULL/empty, the zero distortion coefficients are assumed.
            </dd>
            <dd><code>imagePoints</code> - Output array of image points, 2xN/Nx2 1-channel or
                1xN/Nx1
                2-channel, or <code>vector
                    <Point2f>
                </code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#projectpoints">org.opencv.calib3d.Calib3d.projectPoints</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="projectPoints(org.opencv.core.MatOfPoint3f, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfDouble, org.opencv.core.MatOfPoint2f, org.opencv.core.Mat, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>projectPoints</h4>
<pre>public static&nbsp;void&nbsp;projectPoints(<a href="../../../org/opencv/core/MatOfPoint3f.html"
                                                   title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                 <a href="../../../org/opencv/core/MatOfDouble.html"
                    title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
                 <a href="../../../org/opencv/core/MatOfPoint2f.html"
                    title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;jacobian,
                 double&nbsp;aspectRatio)</pre>
        <div class="block"><p>Projects 3D points to an image plane.</p>

            <p>The function computes projections of 3D points to the image plane given
                intrinsic and extrinsic camera parameters. Optionally, the function computes
                Jacobians - matrices of partial derivatives of image points coordinates (as
                functions of all the input parameters) with respect to the particular
                parameters, intrinsic and/or extrinsic. The Jacobians are used during the
                global optimization in "calibrateCamera", "solvePnP", and "stereoCalibrate".
                The function itself can also be used to compute a re-projection error given
                the current intrinsic and extrinsic parameters.</p>

            <p>Note: By setting <code>rvec=tvec=(0,0,0)</code> or by setting
                <code>cameraMatrix</code> to a 3x3 identity matrix, or by passing zero
                distortion coefficients, you can get various useful partial cases of the
                function. This means that you can compute the distorted coordinates for a
                sparse set of points or apply a perspective transformation (and also compute
                the derivatives) in the ideal zero-distortion setup.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>objectPoints</code> - Array of object points, 3xN/Nx3 1-channel or 1xN/Nx1
                3-channel (or <code>vector
                    <Point3f>
                </code>), where N is the number of points
                in the view.
            </dd>
            <dd><code>rvec</code> - Rotation vector. See "Rodrigues" for details.</dd>
            <dd><code>tvec</code> - Translation vector.</dd>
            <dd><code>cameraMatrix</code> - Camera matrix <em>A =
                <p>|f_x 0 c_x|
                    |0 f_y c_y|
                    |0 0 _1|
            </em>.</p></dd>
            <dd><code>distCoeffs</code> - Input vector of distortion coefficients <em>(k_1, k_2,
                p_1,
                p_2[, k_3[, k_4, k_5, k_6]])</em> of 4, 5, or 8 elements. If the vector is
                NULL/empty, the zero distortion coefficients are assumed.
            </dd>
            <dd><code>imagePoints</code> - Output array of image points, 2xN/Nx2 1-channel or
                1xN/Nx1
                2-channel, or <code>vector
                    <Point2f>
                </code>.
            </dd>
            <dd><code>jacobian</code> - Optional output 2Nx(10+
                <numDistCoeffs>) jacobian matrix of
                    derivatives of image points with respect to components of the rotation
                    vector, translation vector, focal lengths, coordinates of the principal point
                    and the distortion coefficients. In the old interface different components of
                    the jacobian are returned via different output parameters.
            </dd>
            <dd><code>aspectRatio</code> - Optional "fixed aspect ratio" parameter. If the parameter
                is not 0, the function assumes that the aspect ratio (*fx/fy*) is fixed and
                correspondingly adjusts the jacobian matrix.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#projectpoints">org.opencv.calib3d.Calib3d.projectPoints</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="rectify3Collinear(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, java.util.List, java.util.List, org.opencv.core.Size, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, org.opencv.core.Size, org.opencv.core.Rect, org.opencv.core.Rect, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>rectify3Collinear</h4>
<pre>public static&nbsp;float&nbsp;rectify3Collinear(<a href="../../../org/opencv/core/Mat.html"
                                                        title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix1,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs1,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix2,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs2,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix3,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs3,
                      java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                                           title="class in org.opencv.core">Mat</a>&gt;&nbsp;imgpt1,
                      java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                                           title="class in org.opencv.core">Mat</a>&gt;&nbsp;imgpt3,
                      <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imageSize,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R12,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;T12,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R13,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;T13,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R1,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R2,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R3,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;P1,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;P2,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;P3,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Q,
                      double&nbsp;alpha,
                      <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;newImgSize,
                      <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;roi1,
                      <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;roi2,
                      int&nbsp;flags)</pre>
    </li>
</ul>
<a name="reprojectImageTo3D(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>reprojectImageTo3D</h4>
<pre>public static&nbsp;void&nbsp;reprojectImageTo3D(<a href="../../../org/opencv/core/Mat.html"
                                                        title="class in org.opencv.core">Mat</a>&nbsp;disparity,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;_3dImage,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Q)</pre>
        <div class="block"><p>Reprojects a disparity image to 3D space.</p>

            <p>The function transforms a single-channel disparity map to a 3-channel image
                representing a 3D surface. That is, for each pixel <code>(x,y)</code> andthe
                corresponding disparity <code>d=disparity(x,y)</code>, it computes:</p>

            <p><em>[X Y Z W]^T = Q *[x y disparity(x,y) 1]^T
                _3dImage(x,y) = (X/W, Y/W, Z/W) </em></p>

            <p>The matrix <code>Q</code> can be an arbitrary <em>4 x 4</em> matrix (for
                example, the one computed by "stereoRectify"). To reproject a sparse set of
                points {(x,y,d),...} to 3D space, use "perspectiveTransform".</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>disparity</code> - Input single-channel 8-bit unsigned, 16-bit signed, 32-bit
                signed or 32-bit floating-point disparity image.
            </dd>
            <dd><code>_3dImage</code> - Output 3-channel floating-point image of the same size as
                <code>disparity</code>. Each element of <code>_3dImage(x,y)</code> contains
                3D coordinates of the point <code>(x,y)</code> computed from the disparity
                map.
            </dd>
            <dd><code>Q</code> - <em>4 x 4</em> perspective transformation matrix that can be
                obtained with "stereoRectify".
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#reprojectimageto3d">org.opencv.calib3d.Calib3d.reprojectImageTo3D</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="reprojectImageTo3D(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>reprojectImageTo3D</h4>
<pre>public static&nbsp;void&nbsp;reprojectImageTo3D(<a href="../../../org/opencv/core/Mat.html"
                                                        title="class in org.opencv.core">Mat</a>&nbsp;disparity,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;_3dImage,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Q,
                      boolean&nbsp;handleMissingValues)</pre>
        <div class="block"><p>Reprojects a disparity image to 3D space.</p>

            <p>The function transforms a single-channel disparity map to a 3-channel image
                representing a 3D surface. That is, for each pixel <code>(x,y)</code> andthe
                corresponding disparity <code>d=disparity(x,y)</code>, it computes:</p>

            <p><em>[X Y Z W]^T = Q *[x y disparity(x,y) 1]^T
                _3dImage(x,y) = (X/W, Y/W, Z/W) </em></p>

            <p>The matrix <code>Q</code> can be an arbitrary <em>4 x 4</em> matrix (for
                example, the one computed by "stereoRectify"). To reproject a sparse set of
                points {(x,y,d),...} to 3D space, use "perspectiveTransform".</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>disparity</code> - Input single-channel 8-bit unsigned, 16-bit signed, 32-bit
                signed or 32-bit floating-point disparity image.
            </dd>
            <dd><code>_3dImage</code> - Output 3-channel floating-point image of the same size as
                <code>disparity</code>. Each element of <code>_3dImage(x,y)</code> contains
                3D coordinates of the point <code>(x,y)</code> computed from the disparity
                map.
            </dd>
            <dd><code>Q</code> - <em>4 x 4</em> perspective transformation matrix that can be
                obtained with "stereoRectify".
            </dd>
            <dd><code>handleMissingValues</code> - Indicates, whether the function should handle
                missing values (i.e. points where the disparity was not computed). If
                <code>handleMissingValues=true</code>, then pixels with the minimal disparity
                that corresponds to the outliers (see :ocv:funcx:"StereoBM.operator()") are
                transformed to 3D points with a very large Z value (currently set to 10000).
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#reprojectimageto3d">org.opencv.calib3d.Calib3d.reprojectImageTo3D</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="reprojectImageTo3D(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>reprojectImageTo3D</h4>
<pre>public static&nbsp;void&nbsp;reprojectImageTo3D(<a href="../../../org/opencv/core/Mat.html"
                                                        title="class in org.opencv.core">Mat</a>&nbsp;disparity,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;_3dImage,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;Q,
                      boolean&nbsp;handleMissingValues,
                      int&nbsp;ddepth)</pre>
        <div class="block"><p>Reprojects a disparity image to 3D space.</p>

            <p>The function transforms a single-channel disparity map to a 3-channel image
                representing a 3D surface. That is, for each pixel <code>(x,y)</code> andthe
                corresponding disparity <code>d=disparity(x,y)</code>, it computes:</p>

            <p><em>[X Y Z W]^T = Q *[x y disparity(x,y) 1]^T
                _3dImage(x,y) = (X/W, Y/W, Z/W) </em></p>

            <p>The matrix <code>Q</code> can be an arbitrary <em>4 x 4</em> matrix (for
                example, the one computed by "stereoRectify"). To reproject a sparse set of
                points {(x,y,d),...} to 3D space, use "perspectiveTransform".</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>disparity</code> - Input single-channel 8-bit unsigned, 16-bit signed, 32-bit
                signed or 32-bit floating-point disparity image.
            </dd>
            <dd><code>_3dImage</code> - Output 3-channel floating-point image of the same size as
                <code>disparity</code>. Each element of <code>_3dImage(x,y)</code> contains
                3D coordinates of the point <code>(x,y)</code> computed from the disparity
                map.
            </dd>
            <dd><code>Q</code> - <em>4 x 4</em> perspective transformation matrix that can be
                obtained with "stereoRectify".
            </dd>
            <dd><code>handleMissingValues</code> - Indicates, whether the function should handle
                missing values (i.e. points where the disparity was not computed). If
                <code>handleMissingValues=true</code>, then pixels with the minimal disparity
                that corresponds to the outliers (see :ocv:funcx:"StereoBM.operator()") are
                transformed to 3D points with a very large Z value (currently set to 10000).
            </dd>
            <dd><code>ddepth</code> - The optional output array depth. If it is <code>-1</code>, the
                output image will have <code>CV_32F</code> depth. <code>ddepth</code> can
                also be set to <code>CV_16S</code>, <code>CV_32S</code> or <code>CV_32F</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#reprojectimageto3d">org.opencv.calib3d.Calib3d.reprojectImageTo3D</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="Rodrigues(org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>Rodrigues</h4>
<pre>public static&nbsp;void&nbsp;Rodrigues(<a href="../../../org/opencv/core/Mat.html"
                                               title="class in org.opencv.core">Mat</a>&nbsp;src,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Converts a rotation matrix to a rotation vector or vice versa.</p>

            <p><em>theta <- norm(r)
                r <- r/ theta
                R = cos(theta) I + (1- cos(theta)) r r^T + sin(theta)
                |0 -r_z r_y|
                |r_z 0 -r_x|
                |-r_y r_x 0|
            </em></p>

            <p>Inverse transformation can be also done easily, since</p>

            <p><em>sin(theta)
                |0 -r_z r_y|
                |r_z 0 -r_x|
                |-r_y r_x 0|
                = (R - R^T)/2</em></p>

            <p>A rotation vector is a convenient and most compact representation of a
                rotation matrix (since any rotation matrix has just 3 degrees of freedom).
                The representation is used in the global 3D geometry optimization procedures
                like "calibrateCamera", "stereoCalibrate", or "solvePnP".</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Input rotation vector (3x1 or 1x3) or rotation matrix (3x3).</dd>
            <dd><code>dst</code> - Output rotation matrix (3x3) or rotation vector (3x1 or 1x3),
                respectively.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#rodrigues">org.opencv.calib3d.Calib3d.Rodrigues</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="Rodrigues(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>Rodrigues</h4>
<pre>public static&nbsp;void&nbsp;Rodrigues(<a href="../../../org/opencv/core/Mat.html"
                                               title="class in org.opencv.core">Mat</a>&nbsp;src,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;jacobian)</pre>
        <div class="block"><p>Converts a rotation matrix to a rotation vector or vice versa.</p>

            <p><em>theta <- norm(r)
                r <- r/ theta
                R = cos(theta) I + (1- cos(theta)) r r^T + sin(theta)
                |0 -r_z r_y|
                |r_z 0 -r_x|
                |-r_y r_x 0|
            </em></p>

            <p>Inverse transformation can be also done easily, since</p>

            <p><em>sin(theta)
                |0 -r_z r_y|
                |r_z 0 -r_x|
                |-r_y r_x 0|
                = (R - R^T)/2</em></p>

            <p>A rotation vector is a convenient and most compact representation of a
                rotation matrix (since any rotation matrix has just 3 degrees of freedom).
                The representation is used in the global 3D geometry optimization procedures
                like "calibrateCamera", "stereoCalibrate", or "solvePnP".</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Input rotation vector (3x1 or 1x3) or rotation matrix (3x3).</dd>
            <dd><code>dst</code> - Output rotation matrix (3x3) or rotation vector (3x1 or 1x3),
                respectively.
            </dd>
            <dd><code>jacobian</code> - Optional output Jacobian matrix, 3x9 or 9x3, which is a
                matrix of partial derivatives of the output array components with respect to
                the input array components.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#rodrigues">org.opencv.calib3d.Calib3d.Rodrigues</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="RQDecomp3x3(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>RQDecomp3x3</h4>
<pre>public static&nbsp;double[]&nbsp;RQDecomp3x3(<a href="../../../org/opencv/core/Mat.html"
                                                     title="class in org.opencv.core">Mat</a>&nbsp;src,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;mtxR,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;mtxQ)</pre>
        <div class="block"><p>Computes an RQ decomposition of 3x3 matrices.</p>

            <p>The function computes a RQ decomposition using the given rotations. This
                function is used in "decomposeProjectionMatrix" to decompose the left 3x3
                submatrix of a projection matrix into a camera and a rotation matrix.</p>

            <p>It optionally returns three rotation matrices, one for each axis, and the
                three Euler angles in degrees (as the return value) that could be used in
                OpenGL. Note, there is always more than one sequence of rotations about the
                three principle axes that results in the same orientation of an object, eg.
                see [Slabaugh]. Returned tree rotation matrices and corresponding three Euler
                angules are only one of the possible solutions.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - 3x3 input matrix.</dd>
            <dd><code>mtxR</code> - Output 3x3 upper-triangular matrix.</dd>
            <dd><code>mtxQ</code> - Output 3x3 orthogonal matrix.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#rqdecomp3x3">org.opencv.calib3d.Calib3d.RQDecomp3x3</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="RQDecomp3x3(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>RQDecomp3x3</h4>
<pre>public static&nbsp;double[]&nbsp;RQDecomp3x3(<a href="../../../org/opencv/core/Mat.html"
                                                     title="class in org.opencv.core">Mat</a>&nbsp;src,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;mtxR,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;mtxQ,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;Qx,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;Qy,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;Qz)</pre>
        <div class="block"><p>Computes an RQ decomposition of 3x3 matrices.</p>

            <p>The function computes a RQ decomposition using the given rotations. This
                function is used in "decomposeProjectionMatrix" to decompose the left 3x3
                submatrix of a projection matrix into a camera and a rotation matrix.</p>

            <p>It optionally returns three rotation matrices, one for each axis, and the
                three Euler angles in degrees (as the return value) that could be used in
                OpenGL. Note, there is always more than one sequence of rotations about the
                three principle axes that results in the same orientation of an object, eg.
                see [Slabaugh]. Returned tree rotation matrices and corresponding three Euler
                angules are only one of the possible solutions.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - 3x3 input matrix.</dd>
            <dd><code>mtxR</code> - Output 3x3 upper-triangular matrix.</dd>
            <dd><code>mtxQ</code> - Output 3x3 orthogonal matrix.</dd>
            <dd><code>Qx</code> - Optional output 3x3 rotation matrix around x-axis.</dd>
            <dd><code>Qy</code> - Optional output 3x3 rotation matrix around y-axis.</dd>
            <dd><code>Qz</code> - Optional output 3x3 rotation matrix around z-axis.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#rqdecomp3x3">org.opencv.calib3d.Calib3d.RQDecomp3x3</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="solvePnP(org.opencv.core.MatOfPoint3f, org.opencv.core.MatOfPoint2f, org.opencv.core.Mat, org.opencv.core.MatOfDouble, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>solvePnP</h4>
<pre>public static&nbsp;boolean&nbsp;solvePnP(<a href="../../../org/opencv/core/MatOfPoint3f.html"
                                                 title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
               <a href="../../../org/opencv/core/MatOfPoint2f.html"
                  title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
               <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec)</pre>
        <div class="block"><p>Finds an object pose from 3D-2D point correspondences.</p>

            <p>The function estimates the object pose given a set of object points, their
                corresponding image projections, as well as the camera matrix and the
                distortion coefficients.</p>

            <p>Note:</p>
            <ul>
                <li> An example of how to use solvePNP for planar augmented reality can be
                    found at opencv_source_code/samples/python2/plane_ar.py
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>objectPoints</code> - Array of object points in the object coordinate space,
                3xN/Nx3 1-channel or 1xN/Nx1 3-channel, where N is the number of points.
                <code>vector
                    <Point3f>
                </code> can be also passed here.
            </dd>
            <dd><code>imagePoints</code> - Array of corresponding image points, 2xN/Nx2 1-channel or
                1xN/Nx1 2-channel, where N is the number of points. <code>vector
                    <Point2f>
                </code>
                can be also passed here.
            </dd>
            <dd><code>cameraMatrix</code> - Input camera matrix <em>A =
                <p>|fx 0 cx|
                    |0 fy cy|
                    |0 0 1|
            </em>.</p></dd>
            <dd><code>distCoeffs</code> - Input vector of distortion coefficients <em>(k_1, k_2,
                p_1,
                p_2[, k_3[, k_4, k_5, k_6]])</em> of 4, 5, or 8 elements. If the vector is
                NULL/empty, the zero distortion coefficients are assumed.
            </dd>
            <dd><code>rvec</code> - Output rotation vector (see "Rodrigues") that, together with
                <code>tvec</code>, brings points from the model coordinate system to the
                camera coordinate system.
            </dd>
            <dd><code>tvec</code> - Output translation vector.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#solvepnp">org.opencv.calib3d.Calib3d.solvePnP</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="solvePnP(org.opencv.core.MatOfPoint3f, org.opencv.core.MatOfPoint2f, org.opencv.core.Mat, org.opencv.core.MatOfDouble, org.opencv.core.Mat, org.opencv.core.Mat, boolean, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>solvePnP</h4>
<pre>public static&nbsp;boolean&nbsp;solvePnP(<a href="../../../org/opencv/core/MatOfPoint3f.html"
                                                 title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
               <a href="../../../org/opencv/core/MatOfPoint2f.html"
                  title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
               <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rvec,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tvec,
               boolean&nbsp;useExtrinsicGuess,
               int&nbsp;flags)</pre>
        <div class="block"><p>Finds an object pose from 3D-2D point correspondences.</p>

            <p>The function estimates the object pose given a set of object points, their
                corresponding image projections, as well as the camera matrix and the
                distortion coefficients.</p>

            <p>Note:</p>
            <ul>
                <li> An example of how to use solvePNP for planar augmented reality can be
                    found at opencv_source_code/samples/python2/plane_ar.py
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>objectPoints</code> - Array of object points in the object coordinate space,
                3xN/Nx3 1-channel or 1xN/Nx1 3-channel, where N is the number of points.
                <code>vector
                    <Point3f>
                </code> can be also passed here.
            </dd>
            <dd><code>imagePoints</code> - Array of corresponding image points, 2xN/Nx2 1-channel or
                1xN/Nx1 2-channel, where N is the number of points. <code>vector
                    <Point2f>
                </code>
                can be also passed here.
            </dd>
            <dd><code>cameraMatrix</code> - Input camera matrix <em>A =
                <p>|fx 0 cx|
                    |0 fy cy|
                    |0 0 1|
            </em>.</p></dd>
            <dd><code>distCoeffs</code> - Input vector of distortion coefficients <em>(k_1, k_2,
                p_1,
                p_2[, k_3[, k_4, k_5, k_6]])</em> of 4, 5, or 8 elements. If the vector is
                NULL/empty, the zero distortion coefficients are assumed.
            </dd>
            <dd><code>rvec</code> - Output rotation vector (see "Rodrigues") that, together with
                <code>tvec</code>, brings points from the model coordinate system to the
                camera coordinate system.
            </dd>
            <dd><code>tvec</code> - Output translation vector.</dd>
            <dd><code>useExtrinsicGuess</code> - If true (1), the function uses the provided
                <code>rvec</code> and <code>tvec</code> values as initial approximations of
                the rotation and translation vectors, respectively, and further optimizes
                them.
            </dd>
            <dd><code>flags</code> - Method for solving a PnP problem:
                <ul>
                    <li> CV_ITERATIVE Iterative method is based on Levenberg-Marquardt
                        optimization. In this case the function finds such a pose that minimizes
                        reprojection error, that is the sum of squared distances between the
                        observed
                        projections <code>imagePoints</code> and the projected (using
                        "projectPoints") <code>objectPoints</code>.
                    <li> CV_P3P Method is based on the paper of X.S. Gao, X.-R. Hou, J. Tang,
                        H.-F. Chang "Complete Solution Classification for the
                        Perspective-Three-Point
                        Problem". In this case the function requires exactly four object and image
                        points.
                    <li> CV_EPNP Method has been introduced by F.Moreno-Noguer, V.Lepetit and
                        P.Fua in the paper "EPnP: Efficient Perspective-n-Point Camera Pose
                        Estimation".
                </ul>
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#solvepnp">org.opencv.calib3d.Calib3d.solvePnP</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="solvePnPRansac(org.opencv.core.MatOfPoint3f, org.opencv.core.MatOfPoint2f, org.opencv.core.Mat, org.opencv.core.MatOfDouble, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>solvePnPRansac</h4>
<pre>public static&nbsp;void&nbsp;solvePnPRansac(<a
        href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
                  <a href="../../../org/opencv/core/MatOfPoint2f.html"
                     title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
                  <a href="../../../org/opencv/core/Mat.html"
                     title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                  <a href="../../../org/opencv/core/MatOfDouble.html"
                     title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
                  <a href="../../../org/opencv/core/Mat.html"
                     title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                  <a href="../../../org/opencv/core/Mat.html"
                     title="class in org.opencv.core">Mat</a>&nbsp;tvec)</pre>
        <div class="block"><p>Finds an object pose from 3D-2D point correspondences using the RANSAC
            scheme.</p>

            <p>The function estimates an object pose given a set of object points, their
                corresponding image projections, as well as the camera matrix and the
                distortion coefficients. This function finds such a pose that minimizes
                reprojection error, that is, the sum of squared distances between the
                observed projections <code>imagePoints</code> and the projected (using
                "projectPoints") <code>objectPoints</code>. The use of RANSAC makes the
                function resistant to outliers. The function is parallelized with the TBB
                library.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>objectPoints</code> - Array of object points in the object coordinate space,
                3xN/Nx3 1-channel or 1xN/Nx1 3-channel, where N is the number of points.
                <code>vector
                    <Point3f>
                </code> can be also passed here.
            </dd>
            <dd><code>imagePoints</code> - Array of corresponding image points, 2xN/Nx2 1-channel or
                1xN/Nx1 2-channel, where N is the number of points. <code>vector
                    <Point2f>
                </code>
                can be also passed here.
            </dd>
            <dd><code>cameraMatrix</code> - Input camera matrix <em>A =
                <p>|fx 0 cx|
                    |0 fy cy|
                    |0 0 1|
            </em>.</p></dd>
            <dd><code>distCoeffs</code> - Input vector of distortion coefficients <em>(k_1, k_2,
                p_1,
                p_2[, k_3[, k_4, k_5, k_6]])</em> of 4, 5, or 8 elements. If the vector is
                NULL/empty, the zero distortion coefficients are assumed.
            </dd>
            <dd><code>rvec</code> - Output rotation vector (see "Rodrigues") that, together with
                <code>tvec</code>, brings points from the model coordinate system to the
                camera coordinate system.
            </dd>
            <dd><code>tvec</code> - Output translation vector.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#solvepnpransac">org.opencv.calib3d.Calib3d.solvePnPRansac</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="solvePnPRansac(org.opencv.core.MatOfPoint3f, org.opencv.core.MatOfPoint2f, org.opencv.core.Mat, org.opencv.core.MatOfDouble, org.opencv.core.Mat, org.opencv.core.Mat, boolean, int, float, int, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>solvePnPRansac</h4>
<pre>public static&nbsp;void&nbsp;solvePnPRansac(<a
        href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>&nbsp;objectPoints,
                  <a href="../../../org/opencv/core/MatOfPoint2f.html"
                     title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;imagePoints,
                  <a href="../../../org/opencv/core/Mat.html"
                     title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                  <a href="../../../org/opencv/core/MatOfDouble.html"
                     title="class in org.opencv.core">MatOfDouble</a>&nbsp;distCoeffs,
                  <a href="../../../org/opencv/core/Mat.html"
                     title="class in org.opencv.core">Mat</a>&nbsp;rvec,
                  <a href="../../../org/opencv/core/Mat.html"
                     title="class in org.opencv.core">Mat</a>&nbsp;tvec,
                  boolean&nbsp;useExtrinsicGuess,
                  int&nbsp;iterationsCount,
                  float&nbsp;reprojectionError,
                  int&nbsp;minInliersCount,
                  <a href="../../../org/opencv/core/Mat.html"
                     title="class in org.opencv.core">Mat</a>&nbsp;inliers,
                  int&nbsp;flags)</pre>
        <div class="block"><p>Finds an object pose from 3D-2D point correspondences using the RANSAC
            scheme.</p>

            <p>The function estimates an object pose given a set of object points, their
                corresponding image projections, as well as the camera matrix and the
                distortion coefficients. This function finds such a pose that minimizes
                reprojection error, that is, the sum of squared distances between the
                observed projections <code>imagePoints</code> and the projected (using
                "projectPoints") <code>objectPoints</code>. The use of RANSAC makes the
                function resistant to outliers. The function is parallelized with the TBB
                library.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>objectPoints</code> - Array of object points in the object coordinate space,
                3xN/Nx3 1-channel or 1xN/Nx1 3-channel, where N is the number of points.
                <code>vector
                    <Point3f>
                </code> can be also passed here.
            </dd>
            <dd><code>imagePoints</code> - Array of corresponding image points, 2xN/Nx2 1-channel or
                1xN/Nx1 2-channel, where N is the number of points. <code>vector
                    <Point2f>
                </code>
                can be also passed here.
            </dd>
            <dd><code>cameraMatrix</code> - Input camera matrix <em>A =
                <p>|fx 0 cx|
                    |0 fy cy|
                    |0 0 1|
            </em>.</p></dd>
            <dd><code>distCoeffs</code> - Input vector of distortion coefficients <em>(k_1, k_2,
                p_1,
                p_2[, k_3[, k_4, k_5, k_6]])</em> of 4, 5, or 8 elements. If the vector is
                NULL/empty, the zero distortion coefficients are assumed.
            </dd>
            <dd><code>rvec</code> - Output rotation vector (see "Rodrigues") that, together with
                <code>tvec</code>, brings points from the model coordinate system to the
                camera coordinate system.
            </dd>
            <dd><code>tvec</code> - Output translation vector.</dd>
            <dd><code>useExtrinsicGuess</code> - If true (1), the function uses the provided
                <code>rvec</code> and <code>tvec</code> values as initial approximations of
                the rotation and translation vectors, respectively, and further optimizes
                them.
            </dd>
            <dd><code>iterationsCount</code> - Number of iterations.</dd>
            <dd><code>reprojectionError</code> - Inlier threshold value used by the RANSAC
                procedure.
                The parameter value is the maximum allowed distance between the observed and
                computed point projections to consider it an inlier.
            </dd>
            <dd><code>minInliersCount</code> - Number of inliers. If the algorithm at some stage
                finds more inliers than <code>minInliersCount</code>, it finishes.
            </dd>
            <dd><code>inliers</code> - Output vector that contains indices of inliers in
                <code>objectPoints</code> and <code>imagePoints</code>.
            </dd>
            <dd><code>flags</code> - Method for solving a PnP problem (see "solvePnP").</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#solvepnpransac">org.opencv.calib3d.Calib3d.solvePnPRansac</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="stereoCalibrate(java.util.List, java.util.List, java.util.List, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>stereoCalibrate</h4>
<pre>public static&nbsp;double&nbsp;stereoCalibrate(java.util.List&lt;<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;objectPoints,
                     java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                                          title="class in org.opencv.core">Mat</a>&gt;&nbsp;imagePoints1,
                     java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                                          title="class in org.opencv.core">Mat</a>&gt;&nbsp;imagePoints2,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix1,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs1,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix2,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs2,
                     <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imageSize,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;T,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;E,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;F)</pre>
        <div class="block"><p>Calibrates the stereo camera.</p>

            <p>The function estimates transformation between two cameras making a stereo
                pair. If you have a stereo camera where the relative position and orientation
                of two cameras is fixed, and if you computed poses of an object relative to
                the first camera and to the second camera, (R1, T1) and (R2, T2),
                respectively (this can be done with "solvePnP"), then those poses definitely
                relate to each other. This means that, given (<em>R_1</em>,<em>T_1</em>), it
                should be possible to compute (<em>R_2</em>,<em>T_2</em>). You only need to
                know the position and orientation of the second camera relative to the first
                camera. This is what the described function does. It computes
                (<em>R</em>,<em>T</em>) so that:</p>

            <p><em>R_2=R*R_1&ltBR&gtT_2=R*T_1 + T,</em></p>

            <p>Optionally, it computes the essential matrix E:</p>

            <p><em>E=
                |0 -T_2 T_1|
                |T_2 0 -T_0|
                |-T_1 T_0 0|</p>
            <ul>
                <li>R</em>
            </ul>

            <p>where <em>T_i</em> are components of the translation vector <em>T</em> :
                <em>T=[T_0, T_1, T_2]^T</em>. And the function can also compute the
                fundamental matrix F:</p>

            <p><em>F = cameraMatrix2^(-T) E cameraMatrix1^(-1)</em></p>

            <p>Besides the stereo-related information, the function can also perform a full
                calibration of each of two cameras. However, due to the high dimensionality
                of the parameter space and noise in the input data, the function can diverge
                from the correct solution. If the intrinsic parameters can be estimated with
                high accuracy for each of the cameras individually (for example, using
                "calibrateCamera"), you are recommended to do so and then pass
                <code>CV_CALIB_FIX_INTRINSIC</code> flag to the function along with the
                computed intrinsic parameters. Otherwise, if all the parameters are estimated
                at once, it makes sense to restrict some parameters, for example, pass
                <code>CV_CALIB_SAME_FOCAL_LENGTH</code> and <code>CV_CALIB_ZERO_TANGENT_DIST</code>
                flags, which is usually a reasonable assumption.</p>

            <p>Similarly to "calibrateCamera", the function minimizes the total
                re-projection error for all the points in all the available views from both
                cameras. The function returns the final value of the re-projection error.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>objectPoints</code> - Vector of vectors of the calibration pattern points.
            </dd>
            <dd><code>imagePoints1</code> - Vector of vectors of the projections of the calibration
                pattern points, observed by the first camera.
            </dd>
            <dd><code>imagePoints2</code> - Vector of vectors of the projections of the calibration
                pattern points, observed by the second camera.
            </dd>
            <dd><code>cameraMatrix1</code> - Input/output first camera matrix: <em>
                <p>|f_x^j 0 c_x^j|
                    |0 f_y^j c_y^j|
                    |0 0 1|
            </em>, <em>j = 0, 1</em>. If any of <code>CV_CALIB_USE_INTRINSIC_GUESS</code>,
                <code>CV_CALIB_FIX_ASPECT_RATIO</code>, <code>CV_CALIB_FIX_INTRINSIC</code>,
                or <code>CV_CALIB_FIX_FOCAL_LENGTH</code> are specified, some or all of the
                matrix components must be initialized. See the flags description for details.</p>
            </dd>
            <dd><code>distCoeffs1</code> - Input/output vector of distortion coefficients <em>(k_1,
                k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]])</em> of 4, 5, or 8 elements. The
                output vector length depends on the flags.
            </dd>
            <dd><code>cameraMatrix2</code> - Input/output second camera matrix. The parameter is
                similar to <code>cameraMatrix1</code>.
            </dd>
            <dd><code>distCoeffs2</code> - Input/output lens distortion coefficients for the second
                camera. The parameter is similar to <code>distCoeffs1</code>.
            </dd>
            <dd><code>imageSize</code> - Size of the image used only to initialize intrinsic camera
                matrix.
            </dd>
            <dd><code>R</code> - Output rotation matrix between the 1st and the 2nd camera
                coordinate
                systems.
            </dd>
            <dd><code>T</code> - Output translation vector between the coordinate systems of the
                cameras.
            </dd>
            <dd><code>E</code> - Output essential matrix.</dd>
            <dd><code>F</code> - Output fundamental matrix.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#stereocalibrate">org.opencv.calib3d.Calib3d.stereoCalibrate</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="stereoCalibrate(java.util.List, java.util.List, java.util.List, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.TermCriteria, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>stereoCalibrate</h4>
<pre>public static&nbsp;double&nbsp;stereoCalibrate(java.util.List&lt;<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;objectPoints,
                     java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                                          title="class in org.opencv.core">Mat</a>&gt;&nbsp;imagePoints1,
                     java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                                          title="class in org.opencv.core">Mat</a>&gt;&nbsp;imagePoints2,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix1,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs1,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix2,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs2,
                     <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imageSize,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;T,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;E,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;F,
                     <a href="../../../org/opencv/core/TermCriteria.html"
                        title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria,
                     int&nbsp;flags)</pre>
        <div class="block"><p>Calibrates the stereo camera.</p>

            <p>The function estimates transformation between two cameras making a stereo
                pair. If you have a stereo camera where the relative position and orientation
                of two cameras is fixed, and if you computed poses of an object relative to
                the first camera and to the second camera, (R1, T1) and (R2, T2),
                respectively (this can be done with "solvePnP"), then those poses definitely
                relate to each other. This means that, given (<em>R_1</em>,<em>T_1</em>), it
                should be possible to compute (<em>R_2</em>,<em>T_2</em>). You only need to
                know the position and orientation of the second camera relative to the first
                camera. This is what the described function does. It computes
                (<em>R</em>,<em>T</em>) so that:</p>

            <p><em>R_2=R*R_1&ltBR&gtT_2=R*T_1 + T,</em></p>

            <p>Optionally, it computes the essential matrix E:</p>

            <p><em>E=
                |0 -T_2 T_1|
                |T_2 0 -T_0|
                |-T_1 T_0 0|</p>
            <ul>
                <li>R</em>
            </ul>

            <p>where <em>T_i</em> are components of the translation vector <em>T</em> :
                <em>T=[T_0, T_1, T_2]^T</em>. And the function can also compute the
                fundamental matrix F:</p>

            <p><em>F = cameraMatrix2^(-T) E cameraMatrix1^(-1)</em></p>

            <p>Besides the stereo-related information, the function can also perform a full
                calibration of each of two cameras. However, due to the high dimensionality
                of the parameter space and noise in the input data, the function can diverge
                from the correct solution. If the intrinsic parameters can be estimated with
                high accuracy for each of the cameras individually (for example, using
                "calibrateCamera"), you are recommended to do so and then pass
                <code>CV_CALIB_FIX_INTRINSIC</code> flag to the function along with the
                computed intrinsic parameters. Otherwise, if all the parameters are estimated
                at once, it makes sense to restrict some parameters, for example, pass
                <code>CV_CALIB_SAME_FOCAL_LENGTH</code> and <code>CV_CALIB_ZERO_TANGENT_DIST</code>
                flags, which is usually a reasonable assumption.</p>

            <p>Similarly to "calibrateCamera", the function minimizes the total
                re-projection error for all the points in all the available views from both
                cameras. The function returns the final value of the re-projection error.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>objectPoints</code> - Vector of vectors of the calibration pattern points.
            </dd>
            <dd><code>imagePoints1</code> - Vector of vectors of the projections of the calibration
                pattern points, observed by the first camera.
            </dd>
            <dd><code>imagePoints2</code> - Vector of vectors of the projections of the calibration
                pattern points, observed by the second camera.
            </dd>
            <dd><code>cameraMatrix1</code> - Input/output first camera matrix: <em>
                <p>|f_x^j 0 c_x^j|
                    |0 f_y^j c_y^j|
                    |0 0 1|
            </em>, <em>j = 0, 1</em>. If any of <code>CV_CALIB_USE_INTRINSIC_GUESS</code>,
                <code>CV_CALIB_FIX_ASPECT_RATIO</code>, <code>CV_CALIB_FIX_INTRINSIC</code>,
                or <code>CV_CALIB_FIX_FOCAL_LENGTH</code> are specified, some or all of the
                matrix components must be initialized. See the flags description for details.</p>
            </dd>
            <dd><code>distCoeffs1</code> - Input/output vector of distortion coefficients <em>(k_1,
                k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]])</em> of 4, 5, or 8 elements. The
                output vector length depends on the flags.
            </dd>
            <dd><code>cameraMatrix2</code> - Input/output second camera matrix. The parameter is
                similar to <code>cameraMatrix1</code>.
            </dd>
            <dd><code>distCoeffs2</code> - Input/output lens distortion coefficients for the second
                camera. The parameter is similar to <code>distCoeffs1</code>.
            </dd>
            <dd><code>imageSize</code> - Size of the image used only to initialize intrinsic camera
                matrix.
            </dd>
            <dd><code>R</code> - Output rotation matrix between the 1st and the 2nd camera
                coordinate
                systems.
            </dd>
            <dd><code>T</code> - Output translation vector between the coordinate systems of the
                cameras.
            </dd>
            <dd><code>E</code> - Output essential matrix.</dd>
            <dd><code>F</code> - Output fundamental matrix.</dd>
            <dd><code>criteria</code> - a criteria</dd>
            <dd><code>flags</code> - Different flags that may be zero or a combination of the
                following values:
                <ul>
                    <li> CV_CALIB_FIX_INTRINSIC Fix <code>cameraMatrix?</code> and
                        <code>distCoeffs?</code> so that only <code>R, T, E</code>, and
                        <code>F</code> matrices are estimated.
                    <li> CV_CALIB_USE_INTRINSIC_GUESS Optimize some or all of the intrinsic
                        parameters according to the specified flags. Initial values are provided by
                        the user.
                    <li> CV_CALIB_FIX_PRINCIPAL_POINT Fix the principal points during the
                        optimization.
                    <li> CV_CALIB_FIX_FOCAL_LENGTH Fix <em>f^j_x</em> and <em>f^j_y</em>.
                    <li> CV_CALIB_FIX_ASPECT_RATIO Optimize <em>f^j_y</em>. Fix the ratio
                        <em>f^j_x/f^j_y</em>.
                    <li> CV_CALIB_SAME_FOCAL_LENGTH Enforce <em>f^0_x=f^1_x</em> and
                        <em>f^0_y=f^1_y</em>.
                    <li> CV_CALIB_ZERO_TANGENT_DIST Set tangential distortion coefficients for
                        each camera to zeros and fix there.
                    <li> CV_CALIB_FIX_K1,...,CV_CALIB_FIX_K6 Do not change the corresponding
                        radial distortion coefficient during the optimization. If <code>CV_CALIB_USE_INTRINSIC_GUESS</code>
                        is set, the coefficient from the supplied <code>distCoeffs</code> matrix is
                        used. Otherwise, it is set to 0.
                    <li> CV_CALIB_RATIONAL_MODEL Enable coefficients k4, k5, and k6. To provide
                        the backward compatibility, this extra flag should be explicitly specified
                        to
                        make the calibration function use the rational model and return 8
                        coefficients. If the flag is not set, the function computes and returns only
                        5 distortion coefficients.
                </ul>
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#stereocalibrate">org.opencv.calib3d.Calib3d.stereoCalibrate</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="stereoRectify(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>stereoRectify</h4>
<pre>public static&nbsp;void&nbsp;stereoRectify(<a href="../../../org/opencv/core/Mat.html"
                                                   title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix1,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs1,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix2,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs2,
                 <a href="../../../org/opencv/core/Size.html"
                    title="class in org.opencv.core">Size</a>&nbsp;imageSize,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;R,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;T,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;R1,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;R2,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;P1,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;P2,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;Q)</pre>
        <div class="block"><p>Computes rectification transforms for each head of a calibrated stereo
            camera.</p>

            <p>The function computes the rotation matrices for each camera that (virtually)
                make both camera image planes the same plane. Consequently, this makes all
                the epipolar lines parallel and thus simplifies the dense stereo
                correspondence problem. The function takes the matrices computed by
                "stereoCalibrate" as input. As output, it provides two rotation matrices and
                also two projection matrices in the new coordinates. The function
                distinguishes the following two cases:</p>
            <ul>
                <li> Horizontal stereo: the first and the second camera views are shifted
                    relative to each other mainly along the x axis (with possible small vertical
                    shift). In the rectified images, the corresponding epipolar lines in the left
                    and right cameras are horizontal and have the same y-coordinate. P1 and P2
                    look like:
            </ul>

            <p><em>P1 = f 0 cx_1 0
                0 f cy 0
                0 0 1 0 </em></p>


            <p><em>P2 = f 0 cx_2 T_x*f
                0 f cy 0
                0 0 1 0,</em></p>

            <p>where <em>T_x</em> is a horizontal shift between the cameras and
                <em>cx_1=cx_2</em> if <code>CV_CALIB_ZERO_DISPARITY</code> is set.</p>
            <ul>
                <li> Vertical stereo: the first and the second camera views are shifted
                    relative to each other mainly in vertical direction (and probably a bit in
                    the horizontal direction too). The epipolar lines in the rectified images are
                    vertical and have the same x-coordinate. P1 and P2 look like:
            </ul>

            <p><em>P1 = f 0 cx 0
                0 f cy_1 0
                0 0 1 0 </em></p>


            <p><em>P2 = f 0 cx 0
                0 f cy_2 T_y*f
                0 0 1 0,</em></p>

            <p>where <em>T_y</em> is a vertical shift between the cameras and
                <em>cy_1=cy_2</em> if <code>CALIB_ZERO_DISPARITY</code> is set.</p>

            <p>As you can see, the first three columns of <code>P1</code> and
                <code>P2</code> will effectively be the new "rectified" camera matrices.
                The matrices, together with <code>R1</code> and <code>R2</code>, can then be
                passed to "initUndistortRectifyMap" to initialize the rectification map for
                each camera.</p>

            <p>See below the screenshot from the <code>stereo_calib.cpp</code> sample. Some
                red horizontal lines pass through the corresponding image regions. This means
                that the images are well rectified, which is what most stereo correspondence
                algorithms rely on. The green rectangles are <code>roi1</code> and
                <code>roi2</code>. You see that their interiors are all valid pixels.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>cameraMatrix1</code> - First camera matrix.</dd>
            <dd><code>distCoeffs1</code> - First camera distortion parameters.</dd>
            <dd><code>cameraMatrix2</code> - Second camera matrix.</dd>
            <dd><code>distCoeffs2</code> - Second camera distortion parameters.</dd>
            <dd><code>imageSize</code> - Size of the image used for stereo calibration.</dd>
            <dd><code>R</code> - Rotation matrix between the coordinate systems of the first and the
                second cameras.
            </dd>
            <dd><code>T</code> - Translation vector between coordinate systems of the cameras.</dd>
            <dd><code>R1</code> - Output 3x3 rectification transform (rotation matrix) for the first
                camera.
            </dd>
            <dd><code>R2</code> - Output 3x3 rectification transform (rotation matrix) for the
                second
                camera.
            </dd>
            <dd><code>P1</code> - Output 3x4 projection matrix in the new (rectified) coordinate
                systems for the first camera.
            </dd>
            <dd><code>P2</code> - Output 3x4 projection matrix in the new (rectified) coordinate
                systems for the second camera.
            </dd>
            <dd><code>Q</code> - Output <em>4 x 4</em> disparity-to-depth mapping matrix (see
                "reprojectImageTo3D").
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#stereorectify">org.opencv.calib3d.Calib3d.stereoRectify</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="stereoRectify(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, double, org.opencv.core.Size, org.opencv.core.Rect, org.opencv.core.Rect)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>stereoRectify</h4>
<pre>public static&nbsp;void&nbsp;stereoRectify(<a href="../../../org/opencv/core/Mat.html"
                                                   title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix1,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs1,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix2,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs2,
                 <a href="../../../org/opencv/core/Size.html"
                    title="class in org.opencv.core">Size</a>&nbsp;imageSize,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;R,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;T,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;R1,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;R2,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;P1,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;P2,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;Q,
                 int&nbsp;flags,
                 double&nbsp;alpha,
                 <a href="../../../org/opencv/core/Size.html"
                    title="class in org.opencv.core">Size</a>&nbsp;newImageSize,
                 <a href="../../../org/opencv/core/Rect.html"
                    title="class in org.opencv.core">Rect</a>&nbsp;validPixROI1,
                 <a href="../../../org/opencv/core/Rect.html"
                    title="class in org.opencv.core">Rect</a>&nbsp;validPixROI2)</pre>
        <div class="block"><p>Computes rectification transforms for each head of a calibrated stereo
            camera.</p>

            <p>The function computes the rotation matrices for each camera that (virtually)
                make both camera image planes the same plane. Consequently, this makes all
                the epipolar lines parallel and thus simplifies the dense stereo
                correspondence problem. The function takes the matrices computed by
                "stereoCalibrate" as input. As output, it provides two rotation matrices and
                also two projection matrices in the new coordinates. The function
                distinguishes the following two cases:</p>
            <ul>
                <li> Horizontal stereo: the first and the second camera views are shifted
                    relative to each other mainly along the x axis (with possible small vertical
                    shift). In the rectified images, the corresponding epipolar lines in the left
                    and right cameras are horizontal and have the same y-coordinate. P1 and P2
                    look like:
            </ul>

            <p><em>P1 = f 0 cx_1 0
                0 f cy 0
                0 0 1 0 </em></p>


            <p><em>P2 = f 0 cx_2 T_x*f
                0 f cy 0
                0 0 1 0,</em></p>

            <p>where <em>T_x</em> is a horizontal shift between the cameras and
                <em>cx_1=cx_2</em> if <code>CV_CALIB_ZERO_DISPARITY</code> is set.</p>
            <ul>
                <li> Vertical stereo: the first and the second camera views are shifted
                    relative to each other mainly in vertical direction (and probably a bit in
                    the horizontal direction too). The epipolar lines in the rectified images are
                    vertical and have the same x-coordinate. P1 and P2 look like:
            </ul>

            <p><em>P1 = f 0 cx 0
                0 f cy_1 0
                0 0 1 0 </em></p>


            <p><em>P2 = f 0 cx 0
                0 f cy_2 T_y*f
                0 0 1 0,</em></p>

            <p>where <em>T_y</em> is a vertical shift between the cameras and
                <em>cy_1=cy_2</em> if <code>CALIB_ZERO_DISPARITY</code> is set.</p>

            <p>As you can see, the first three columns of <code>P1</code> and
                <code>P2</code> will effectively be the new "rectified" camera matrices.
                The matrices, together with <code>R1</code> and <code>R2</code>, can then be
                passed to "initUndistortRectifyMap" to initialize the rectification map for
                each camera.</p>

            <p>See below the screenshot from the <code>stereo_calib.cpp</code> sample. Some
                red horizontal lines pass through the corresponding image regions. This means
                that the images are well rectified, which is what most stereo correspondence
                algorithms rely on. The green rectangles are <code>roi1</code> and
                <code>roi2</code>. You see that their interiors are all valid pixels.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>cameraMatrix1</code> - First camera matrix.</dd>
            <dd><code>distCoeffs1</code> - First camera distortion parameters.</dd>
            <dd><code>cameraMatrix2</code> - Second camera matrix.</dd>
            <dd><code>distCoeffs2</code> - Second camera distortion parameters.</dd>
            <dd><code>imageSize</code> - Size of the image used for stereo calibration.</dd>
            <dd><code>R</code> - Rotation matrix between the coordinate systems of the first and the
                second cameras.
            </dd>
            <dd><code>T</code> - Translation vector between coordinate systems of the cameras.</dd>
            <dd><code>R1</code> - Output 3x3 rectification transform (rotation matrix) for the first
                camera.
            </dd>
            <dd><code>R2</code> - Output 3x3 rectification transform (rotation matrix) for the
                second
                camera.
            </dd>
            <dd><code>P1</code> - Output 3x4 projection matrix in the new (rectified) coordinate
                systems for the first camera.
            </dd>
            <dd><code>P2</code> - Output 3x4 projection matrix in the new (rectified) coordinate
                systems for the second camera.
            </dd>
            <dd><code>Q</code> - Output <em>4 x 4</em> disparity-to-depth mapping matrix (see
                "reprojectImageTo3D").
            </dd>
            <dd><code>flags</code> - Operation flags that may be zero or <code>CV_CALIB_ZERO_DISPARITY</code>.
                If the flag is set, the function makes the principal points of each camera
                have the same pixel coordinates in the rectified views. And if the flag is
                not set, the function may still shift the images in the horizontal or
                vertical direction (depending on the orientation of epipolar lines) to
                maximize the useful image area.
            </dd>
            <dd><code>alpha</code> - Free scaling parameter. If it is -1 or absent, the function
                performs the default scaling. Otherwise, the parameter should be between 0
                and 1. <code>alpha=0</code> means that the rectified images are zoomed and
                shifted so that only valid pixels are visible (no black areas after
                rectification). <code>alpha=1</code> means that the rectified image is
                decimated and shifted so that all the pixels from the original images from
                the cameras are retained in the rectified images (no source image pixels are
                lost). Obviously, any intermediate value yields an intermediate result
                between those two extreme cases.
            </dd>
            <dd><code>newImageSize</code> - New image resolution after rectification. The same size
                should be passed to "initUndistortRectifyMap" (see the <code>stereo_calib.cpp</code>
                sample in OpenCV samples directory). When (0,0) is passed (default), it is
                set to the original <code>imageSize</code>. Setting it to larger value can
                help you preserve details in the original image, especially when there is a
                big radial distortion.
            </dd>
            <dd><code>validPixROI1</code> - Optional output rectangles inside the rectified images
                where all the pixels are valid. If <code>alpha=0</code>, the ROIs cover the
                whole images. Otherwise, they are likely to be smaller (see the picture
                below).
            </dd>
            <dd><code>validPixROI2</code> - Optional output rectangles inside the rectified images
                where all the pixels are valid. If <code>alpha=0</code>, the ROIs cover the
                whole images. Otherwise, they are likely to be smaller (see the picture
                below).
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#stereorectify">org.opencv.calib3d.Calib3d.stereoRectify</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="stereoRectifyUncalibrated(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>stereoRectifyUncalibrated</h4>
<pre>public static&nbsp;boolean&nbsp;stereoRectifyUncalibrated(<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                                <a href="../../../org/opencv/core/Mat.html"
                                   title="class in org.opencv.core">Mat</a>&nbsp;points2,
                                <a href="../../../org/opencv/core/Mat.html"
                                   title="class in org.opencv.core">Mat</a>&nbsp;F,
                                <a href="../../../org/opencv/core/Size.html"
                                   title="class in org.opencv.core">Size</a>&nbsp;imgSize,
                                <a href="../../../org/opencv/core/Mat.html"
                                   title="class in org.opencv.core">Mat</a>&nbsp;H1,
                                <a href="../../../org/opencv/core/Mat.html"
                                   title="class in org.opencv.core">Mat</a>&nbsp;H2)</pre>
        <div class="block"><p>Computes a rectification transform for an uncalibrated stereo
            camera.</p>

            <p>The function computes the rectification transformations without knowing
                intrinsic parameters of the cameras and their relative position in the space,
                which explains the suffix "uncalibrated". Another related difference from
                "stereoRectify" is that the function outputs not the rectification
                transformations in the object (3D) space, but the planar perspective
                transformations encoded by the homography matrices <code>H1</code> and
                <code>H2</code>. The function implements the algorithm [Hartley99].</p>

            <p>Note:</p>

            <p>While the algorithm does not need to know the intrinsic parameters of the
                cameras, it heavily depends on the epipolar geometry. Therefore, if the
                camera lenses have a significant distortion, it would be better to correct it
                before computing the fundamental matrix and calling this function. For
                example, distortion coefficients can be estimated for each head of stereo
                camera separately by using "calibrateCamera". Then, the images can be
                corrected using "undistort", or just the point coordinates can be corrected
                with "undistortPoints".</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>points1</code> - Array of feature points in the first image.</dd>
            <dd><code>points2</code> - The corresponding points in the second image. The same
                formats
                as in "findFundamentalMat" are supported.
            </dd>
            <dd><code>F</code> - Input fundamental matrix. It can be computed from the same set of
                point pairs using "findFundamentalMat".
            </dd>
            <dd><code>imgSize</code> - Size of the image.</dd>
            <dd><code>H1</code> - Output rectification homography matrix for the first image.</dd>
            <dd><code>H2</code> - Output rectification homography matrix for the second image.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#stereorectifyuncalibrated">org.opencv.calib3d.Calib3d.stereoRectifyUncalibrated</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="stereoRectifyUncalibrated(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Mat, org.opencv.core.Mat, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>stereoRectifyUncalibrated</h4>
<pre>public static&nbsp;boolean&nbsp;stereoRectifyUncalibrated(<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points1,
                                <a href="../../../org/opencv/core/Mat.html"
                                   title="class in org.opencv.core">Mat</a>&nbsp;points2,
                                <a href="../../../org/opencv/core/Mat.html"
                                   title="class in org.opencv.core">Mat</a>&nbsp;F,
                                <a href="../../../org/opencv/core/Size.html"
                                   title="class in org.opencv.core">Size</a>&nbsp;imgSize,
                                <a href="../../../org/opencv/core/Mat.html"
                                   title="class in org.opencv.core">Mat</a>&nbsp;H1,
                                <a href="../../../org/opencv/core/Mat.html"
                                   title="class in org.opencv.core">Mat</a>&nbsp;H2,
                                double&nbsp;threshold)</pre>
        <div class="block"><p>Computes a rectification transform for an uncalibrated stereo
            camera.</p>

            <p>The function computes the rectification transformations without knowing
                intrinsic parameters of the cameras and their relative position in the space,
                which explains the suffix "uncalibrated". Another related difference from
                "stereoRectify" is that the function outputs not the rectification
                transformations in the object (3D) space, but the planar perspective
                transformations encoded by the homography matrices <code>H1</code> and
                <code>H2</code>. The function implements the algorithm [Hartley99].</p>

            <p>Note:</p>

            <p>While the algorithm does not need to know the intrinsic parameters of the
                cameras, it heavily depends on the epipolar geometry. Therefore, if the
                camera lenses have a significant distortion, it would be better to correct it
                before computing the fundamental matrix and calling this function. For
                example, distortion coefficients can be estimated for each head of stereo
                camera separately by using "calibrateCamera". Then, the images can be
                corrected using "undistort", or just the point coordinates can be corrected
                with "undistortPoints".</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>points1</code> - Array of feature points in the first image.</dd>
            <dd><code>points2</code> - The corresponding points in the second image. The same
                formats
                as in "findFundamentalMat" are supported.
            </dd>
            <dd><code>F</code> - Input fundamental matrix. It can be computed from the same set of
                point pairs using "findFundamentalMat".
            </dd>
            <dd><code>imgSize</code> - Size of the image.</dd>
            <dd><code>H1</code> - Output rectification homography matrix for the first image.</dd>
            <dd><code>H2</code> - Output rectification homography matrix for the second image.</dd>
            <dd><code>threshold</code> - Optional threshold used to filter out the outliers. If the
                parameter is greater than zero, all the point pairs that do not comply with
                the epipolar geometry (that is, the points for which <em>|points2[i]^T*F*points1[i]|&gtthreshold</em>)
                are rejected prior to computing the homographies. Otherwise,all the points
                are considered inliers.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#stereorectifyuncalibrated">org.opencv.calib3d.Calib3d.stereoRectifyUncalibrated</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="triangulatePoints(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>triangulatePoints</h4>
<pre>public static&nbsp;void&nbsp;triangulatePoints(<a href="../../../org/opencv/core/Mat.html"
                                                       title="class in org.opencv.core">Mat</a>&nbsp;projMatr1,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;projMatr2,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;projPoints1,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;projPoints2,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points4D)</pre>
        <div class="block"><p>Reconstructs points by triangulation.</p>

            <p>The function reconstructs 3-dimensional points (in homogeneous coordinates)
                by using their observations with a stereo camera. Projections matrices can be
                obtained from "stereoRectify".</p>

            <p>Note:</p>

            <p>Keep in mind that all input data should be of float type in order for this
                function to work.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>projMatr1</code> - 3x4 projection matrix of the first camera.</dd>
            <dd><code>projMatr2</code> - 3x4 projection matrix of the second camera.</dd>
            <dd><code>projPoints1</code> - 2xN array of feature points in the first image. In case
                of
                c++ version it can be also a vector of feature points or two-channel matrix
                of size 1xN or Nx1.
            </dd>
            <dd><code>projPoints2</code> - 2xN array of corresponding points in the second image. In
                case of c++ version it can be also a vector of feature points or two-channel
                matrix of size 1xN or Nx1.
            </dd>
            <dd><code>points4D</code> - 4xN array of reconstructed points in homogeneous
                coordinates.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#triangulatepoints">org.opencv.calib3d.Calib3d.triangulatePoints</a>,
                <a href="../../../org/opencv/calib3d/Calib3d.html#reprojectImageTo3D(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean, int)"><code>reprojectImageTo3D(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, boolean, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="validateDisparity(org.opencv.core.Mat, org.opencv.core.Mat, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>validateDisparity</h4>
<pre>public static&nbsp;void&nbsp;validateDisparity(<a href="../../../org/opencv/core/Mat.html"
                                                       title="class in org.opencv.core">Mat</a>&nbsp;disparity,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cost,
                     int&nbsp;minDisparity,
                     int&nbsp;numberOfDisparities)</pre>
    </li>
</ul>
<a name="validateDisparity(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int)">
    <!--   -->
</a>
<ul class="blockListLast">
    <li class="blockList">
        <h4>validateDisparity</h4>
<pre>public static&nbsp;void&nbsp;validateDisparity(<a href="../../../org/opencv/core/Mat.html"
                                                       title="class in org.opencv.core">Mat</a>&nbsp;disparity,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cost,
                     int&nbsp;minDisparity,
                     int&nbsp;numberOfDisparities,
                     int&nbsp;disp12MaxDisp)</pre>
    </li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
    <!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a
        name="navbar_bottom_firstrow">
    <!--   -->
</a>
    <ul class="navList" title="Navigation">
        <li><a href="../../../overview-summary.html">Overview</a></li>
        <li><a href="package-summary.html">Package</a></li>
        <li class="navBarCell1Rev">Class</li>
        <li><a href="package-tree.html">Tree</a></li>
        <li><a href="../../../index-all.html">Index</a></li>
        <li><a href="../../../help-doc.html">Help</a></li>
    </ul>
    <div class="aboutLanguage"><em><a href=http://docs.opencv.org>OpenCV 2.4.11
        Documentation</a></em></div>
</div>
<div class="subNav">
    <ul class="navList">
        <li>PREV CLASS</li>
        <li><a href="../../../org/opencv/calib3d/StereoBM.html" title="class in org.opencv.calib3d"><span
                class="strong">NEXT CLASS</span></a></li>
    </ul>
    <ul class="navList">
        <li><a href="../../../index.html?org/opencv/calib3d/Calib3d.html" target="_top">FRAMES</a>
        </li>
        <li><a href="Calib3d.html" target="_top">NO FRAMES</a></li>
    </ul>
    <ul class="navList" id="allclasses_navbar_bottom">
        <li><a href="../../../allclasses-noframe.html">All Classes</a></li>
    </ul>
    <div>
        <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->

        </script>
    </div>
    <div>
        <ul class="subNavList">
            <li>SUMMARY:&nbsp;</li>
            <li>NESTED&nbsp;|&nbsp;</li>
            <li><a href="#field_summary">FIELD</a>&nbsp;|&nbsp;</li>
            <li><a href="#constructor_summary">CONSTR</a>&nbsp;|&nbsp;</li>
            <li><a href="#method_summary">METHOD</a></li>
        </ul>
        <ul class="subNavList">
            <li>DETAIL:&nbsp;</li>
            <li><a href="#field_detail">FIELD</a>&nbsp;|&nbsp;</li>
            <li><a href="#constructor_detail">CONSTR</a>&nbsp;|&nbsp;</li>
            <li><a href="#method_detail">METHOD</a></li>
        </ul>
    </div>
    <a name="skip-navbar_bottom">
        <!--   -->
    </a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
