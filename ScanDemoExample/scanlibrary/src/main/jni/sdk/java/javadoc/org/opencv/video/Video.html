<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
    <!-- Generated by javadoc (version 1.6.0_34) on Wed Mar 04 17:44:06 MSK 2015 -->
    <title>Video</title>
    <meta name="date" content="2015-03-04">
    <link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Video";
    }
//-->

</script>
<noscript>
    <div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
    <!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
    <!--   -->
</a>
    <ul class="navList" title="Navigation">
        <li><a href="../../../overview-summary.html">Overview</a></li>
        <li><a href="package-summary.html">Package</a></li>
        <li class="navBarCell1Rev">Class</li>
        <li><a href="package-tree.html">Tree</a></li>
        <li><a href="../../../index-all.html">Index</a></li>
        <li><a href="../../../help-doc.html">Help</a></li>
    </ul>
    <div class="aboutLanguage"><em>OpenCV 2.4.11</em></div>
</div>
<div class="subNav">
    <ul class="navList">
        <li><a href="../../../org/opencv/video/KalmanFilter.html" title="class in org.opencv.video"><span
                class="strong">PREV CLASS</span></a></li>
        <li>NEXT CLASS</li>
    </ul>
    <ul class="navList">
        <li><a href="../../../index.html?org/opencv/video/Video.html" target="_top">FRAMES</a></li>
        <li><a href="Video.html" target="_top">NO FRAMES</a></li>
    </ul>
    <ul class="navList" id="allclasses_navbar_top">
        <li><a href="../../../allclasses-noframe.html">All Classes</a></li>
    </ul>
    <div>
        <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->

        </script>
    </div>
    <div>
        <ul class="subNavList">
            <li>SUMMARY:&nbsp;</li>
            <li>NESTED&nbsp;|&nbsp;</li>
            <li><a href="#field_summary">FIELD</a>&nbsp;|&nbsp;</li>
            <li><a href="#constructor_summary">CONSTR</a>&nbsp;|&nbsp;</li>
            <li><a href="#method_summary">METHOD</a></li>
        </ul>
        <ul class="subNavList">
            <li>DETAIL:&nbsp;</li>
            <li><a href="#field_detail">FIELD</a>&nbsp;|&nbsp;</li>
            <li><a href="#constructor_detail">CONSTR</a>&nbsp;|&nbsp;</li>
            <li><a href="#method_detail">METHOD</a></li>
        </ul>
    </div>
    <a name="skip-navbar_top">
        <!--   -->
    </a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
    <p class="subTitle">org.opencv.video</p>

    <h2 title="Class Video" class="title">Class Video</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
    <li>java.lang.Object</li>
    <li>
        <ul class="inheritance">
            <li>org.opencv.video.Video</li>
        </ul>
    </li>
</ul>
<div class="description">
    <ul class="blockList">
        <li class="blockList">
            <hr>
            <br>
<pre>public class <strong>Video</strong>
extends java.lang.Object</pre>
        </li>
    </ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
    <li class="blockList"><a name="field_summary">
        <!--   -->
    </a>

        <h3>Field Summary</h3>
        <table class="overviewSummary" border="0" cellpadding="3" cellspacing="0"
               summary="Field Summary table, listing fields, and an explanation">
            <caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
            <tr>
                <th class="colFirst" scope="col">Modifier and Type</th>
                <th class="colLast" scope="col">Field and Description</th>
            </tr>
            <tr class="altColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/video/Video.html#OPTFLOW_FARNEBACK_GAUSSIAN">OPTFLOW_FARNEBACK_GAUSSIAN</a></strong></code>&nbsp;
                </td>
            </tr>
            <tr class="rowColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/video/Video.html#OPTFLOW_LK_GET_MIN_EIGENVALS">OPTFLOW_LK_GET_MIN_EIGENVALS</a></strong></code>&nbsp;
                </td>
            </tr>
            <tr class="altColor">
                <td class="colFirst"><code>static int</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/video/Video.html#OPTFLOW_USE_INITIAL_FLOW">OPTFLOW_USE_INITIAL_FLOW</a></strong></code>&nbsp;
                </td>
            </tr>
        </table>
    </li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
    <li class="blockList"><a name="constructor_summary">
        <!--   -->
    </a>

        <h3>Constructor Summary</h3>
        <table class="overviewSummary" border="0" cellpadding="3" cellspacing="0"
               summary="Constructor Summary table, listing constructors, and an explanation">
            <caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
            <tr>
                <th class="colOne" scope="col">Constructor and Description</th>
            </tr>
            <tr class="altColor">
                <td class="colOne"><code><strong><a
                        href="../../../org/opencv/video/Video.html#Video()">Video</a></strong>()</code>&nbsp;
                </td>
            </tr>
        </table>
    </li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
    <!--   -->
</a>

<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0"
       summary="Method Summary table, listing methods, and an explanation">
    <caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
    <tr>
        <th class="colFirst" scope="col">Modifier and Type</th>
        <th class="colLast" scope="col">Method and Description</th>
    </tr>
    <tr class="altColor">
        <td class="colFirst"><code>static int</code></td>
        <td class="colLast"><code><strong><a
                href="../../../org/opencv/video/Video.html#buildOpticalFlowPyramid(org.opencv.core.Mat, java.util.List, org.opencv.core.Size, int)">buildOpticalFlowPyramid</a></strong>(<a
                href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
            java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                                 title="class in org.opencv.core">Mat</a>&gt;&nbsp;pyramid,
            <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;winSize,
            int&nbsp;maxLevel)</code>

            <div class="block">Constructs the image pyramid which can be passed to
                "calcOpticalFlowPyrLK".
            </div>
        </td>
    </tr>
    <tr class="rowColor">
        <td class="colFirst"><code>static int</code></td>
        <td class="colLast"><code><strong><a
                href="../../../org/opencv/video/Video.html#buildOpticalFlowPyramid(org.opencv.core.Mat, java.util.List, org.opencv.core.Size, int, boolean, int, int, boolean)">buildOpticalFlowPyramid</a></strong>(<a
                href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
            java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                                 title="class in org.opencv.core">Mat</a>&gt;&nbsp;pyramid,
            <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;winSize,
            int&nbsp;maxLevel,
            boolean&nbsp;withDerivatives,
            int&nbsp;pyrBorder,
            int&nbsp;derivBorder,
            boolean&nbsp;tryReuseInputImage)</code>

            <div class="block">Constructs the image pyramid which can be passed to
                "calcOpticalFlowPyrLK".
            </div>
        </td>
    </tr>
    <tr class="altColor">
        <td class="colFirst"><code>static double</code></td>
        <td class="colLast"><code><strong><a
                href="../../../org/opencv/video/Video.html#calcGlobalOrientation(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, double)">calcGlobalOrientation</a></strong>(<a
                href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;orientation,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mhi,
            double&nbsp;timestamp,
            double&nbsp;duration)</code>

            <div class="block">Calculates a global motion orientation in a selected region.</div>
        </td>
    </tr>
    <tr class="rowColor">
        <td class="colFirst"><code>static void</code></td>
        <td class="colLast"><code><strong><a
                href="../../../org/opencv/video/Video.html#calcMotionGradient(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, double)">calcMotionGradient</a></strong>(<a
                href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mhi,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;orientation,
            double&nbsp;delta1,
            double&nbsp;delta2)</code>

            <div class="block">Calculates a gradient orientation of a motion history image.</div>
        </td>
    </tr>
    <tr class="altColor">
        <td class="colFirst"><code>static void</code></td>
        <td class="colLast"><code><strong><a
                href="../../../org/opencv/video/Video.html#calcMotionGradient(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, double, int)">calcMotionGradient</a></strong>(<a
                href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mhi,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;orientation,
            double&nbsp;delta1,
            double&nbsp;delta2,
            int&nbsp;apertureSize)</code>

            <div class="block">Calculates a gradient orientation of a motion history image.</div>
        </td>
    </tr>
    <tr class="rowColor">
        <td class="colFirst"><code>static void</code></td>
        <td class="colLast"><code><strong><a
                href="../../../org/opencv/video/Video.html#calcOpticalFlowFarneback(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, int, int, int, int, double, int)">calcOpticalFlowFarneback</a></strong>(<a
                href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;prev,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;next,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;flow,
            double&nbsp;pyr_scale,
            int&nbsp;levels,
            int&nbsp;winsize,
            int&nbsp;iterations,
            int&nbsp;poly_n,
            double&nbsp;poly_sigma,
            int&nbsp;flags)</code>

            <div class="block">Computes a dense optical flow using the Gunnar Farneback's
                algorithm.
            </div>
        </td>
    </tr>
    <tr class="altColor">
        <td class="colFirst"><code>static void</code></td>
        <td class="colLast"><code><strong><a
                href="../../../org/opencv/video/Video.html#calcOpticalFlowPyrLK(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfByte, org.opencv.core.MatOfFloat)">calcOpticalFlowPyrLK</a></strong>(<a
                href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;prevImg,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;nextImg,
            <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;prevPts,
            <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;nextPts,
            <a href="../../../org/opencv/core/MatOfByte.html" title="class in org.opencv.core">MatOfByte</a>&nbsp;status,
            <a href="../../../org/opencv/core/MatOfFloat.html" title="class in org.opencv.core">MatOfFloat</a>&nbsp;err)</code>

            <div class="block">Calculates an optical flow for a sparse feature set using the
                iterative
                Lucas-Kanade method with pyramids.
            </div>
        </td>
    </tr>
    <tr class="rowColor">
        <td class="colFirst"><code>static void</code></td>
        <td class="colLast"><code><strong><a
                href="../../../org/opencv/video/Video.html#calcOpticalFlowPyrLK(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfByte, org.opencv.core.MatOfFloat, org.opencv.core.Size, int)">calcOpticalFlowPyrLK</a></strong>(<a
                href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;prevImg,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;nextImg,
            <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;prevPts,
            <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;nextPts,
            <a href="../../../org/opencv/core/MatOfByte.html" title="class in org.opencv.core">MatOfByte</a>&nbsp;status,
            <a href="../../../org/opencv/core/MatOfFloat.html" title="class in org.opencv.core">MatOfFloat</a>&nbsp;err,
            <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;winSize,
            int&nbsp;maxLevel)</code>

            <div class="block">Calculates an optical flow for a sparse feature set using the
                iterative
                Lucas-Kanade method with pyramids.
            </div>
        </td>
    </tr>
    <tr class="altColor">
        <td class="colFirst"><code>static void</code></td>
        <td class="colLast"><code><strong><a
                href="../../../org/opencv/video/Video.html#calcOpticalFlowPyrLK(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfByte, org.opencv.core.MatOfFloat, org.opencv.core.Size, int, org.opencv.core.TermCriteria, int, double)">calcOpticalFlowPyrLK</a></strong>(<a
                href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;prevImg,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;nextImg,
            <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;prevPts,
            <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;nextPts,
            <a href="../../../org/opencv/core/MatOfByte.html" title="class in org.opencv.core">MatOfByte</a>&nbsp;status,
            <a href="../../../org/opencv/core/MatOfFloat.html" title="class in org.opencv.core">MatOfFloat</a>&nbsp;err,
            <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;winSize,
            int&nbsp;maxLevel,
            <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria,
            int&nbsp;flags,
            double&nbsp;minEigThreshold)</code>

            <div class="block">Calculates an optical flow for a sparse feature set using the
                iterative
                Lucas-Kanade method with pyramids.
            </div>
        </td>
    </tr>
    <tr class="rowColor">
        <td class="colFirst"><code>static void</code></td>
        <td class="colLast"><code><strong><a
                href="../../../org/opencv/video/Video.html#calcOpticalFlowSF(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int, int)">calcOpticalFlowSF</a></strong>(<a
                href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;from,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;to,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;flow,
            int&nbsp;layers,
            int&nbsp;averaging_block_size,
            int&nbsp;max_flow)</code>

            <div class="block">Calculate an optical flow using "SimpleFlow" algorithm.</div>
        </td>
    </tr>
    <tr class="altColor">
        <td class="colFirst"><code>static void</code></td>
        <td class="colLast"><code><strong><a
                href="../../../org/opencv/video/Video.html#calcOpticalFlowSF(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, double, double, int, double, double, double, int, double, double, double)">calcOpticalFlowSF</a></strong>(<a
                href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;from,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;to,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;flow,
            int&nbsp;layers,
            int&nbsp;averaging_block_size,
            int&nbsp;max_flow,
            double&nbsp;sigma_dist,
            double&nbsp;sigma_color,
            int&nbsp;postprocess_window,
            double&nbsp;sigma_dist_fix,
            double&nbsp;sigma_color_fix,
            double&nbsp;occ_thr,
            int&nbsp;upscale_averaging_radius,
            double&nbsp;upscale_sigma_dist,
            double&nbsp;upscale_sigma_color,
            double&nbsp;speed_up_thr)</code>

            <div class="block">Calculate an optical flow using "SimpleFlow" algorithm.</div>
        </td>
    </tr>
    <tr class="rowColor">
        <td class="colFirst"><code>static <a href="../../../org/opencv/core/RotatedRect.html"
                                             title="class in org.opencv.core">RotatedRect</a></code>
        </td>
        <td class="colLast"><code><strong><a
                href="../../../org/opencv/video/Video.html#CamShift(org.opencv.core.Mat, org.opencv.core.Rect, org.opencv.core.TermCriteria)">CamShift</a></strong>(<a
                href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;probImage,
            <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;window,
            <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria)</code>

            <div class="block">Finds an object center, size, and orientation.</div>
        </td>
    </tr>
    <tr class="altColor">
        <td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html"
                                             title="class in org.opencv.core">Mat</a></code></td>
        <td class="colLast"><code><strong><a
                href="../../../org/opencv/video/Video.html#estimateRigidTransform(org.opencv.core.Mat, org.opencv.core.Mat, boolean)">estimateRigidTransform</a></strong>(<a
                href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
            boolean&nbsp;fullAffine)</code>

            <div class="block">Computes an optimal affine transformation between two 2D point
                sets.
            </div>
        </td>
    </tr>
    <tr class="rowColor">
        <td class="colFirst"><code>static int</code></td>
        <td class="colLast"><code><strong><a
                href="../../../org/opencv/video/Video.html#meanShift(org.opencv.core.Mat, org.opencv.core.Rect, org.opencv.core.TermCriteria)">meanShift</a></strong>(<a
                href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;probImage,
            <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;window,
            <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria)</code>

            <div class="block">Finds an object on a back projection image.</div>
        </td>
    </tr>
    <tr class="altColor">
        <td class="colFirst"><code>static void</code></td>
        <td class="colLast"><code><strong><a
                href="../../../org/opencv/video/Video.html#segmentMotion(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfRect, double, double)">segmentMotion</a></strong>(<a
                href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mhi,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;segmask,
            <a href="../../../org/opencv/core/MatOfRect.html" title="class in org.opencv.core">MatOfRect</a>&nbsp;boundingRects,
            double&nbsp;timestamp,
            double&nbsp;segThresh)</code>

            <div class="block">Splits a motion history image into a few parts corresponding to
                separate
                independent motions (for example, left hand, right hand).
            </div>
        </td>
    </tr>
    <tr class="rowColor">
        <td class="colFirst"><code>static void</code></td>
        <td class="colLast"><code><strong><a
                href="../../../org/opencv/video/Video.html#updateMotionHistory(org.opencv.core.Mat, org.opencv.core.Mat, double, double)">updateMotionHistory</a></strong>(<a
                href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;silhouette,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mhi,
            double&nbsp;timestamp,
            double&nbsp;duration)</code>

            <div class="block">Updates the motion history image by a moving silhouette.</div>
        </td>
    </tr>
</table>
<ul class="blockList">
    <li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
        <!--   -->
    </a>

        <h3>Methods inherited from class&nbsp;java.lang.Object</h3>
        <code>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
    <li class="blockList"><a name="field_detail">
        <!--   -->
    </a>

        <h3>Field Detail</h3>
        <a name="OPTFLOW_FARNEBACK_GAUSSIAN">
            <!--   -->
        </a>
        <ul class="blockList">
            <li class="blockList">
                <h4>OPTFLOW_FARNEBACK_GAUSSIAN</h4>
                <pre>public static final&nbsp;int OPTFLOW_FARNEBACK_GAUSSIAN</pre>
                <dl>
                    <dt><span class="strong">See Also:</span></dt>
                    <dd>
                        <a href="../../../constant-values.html#org.opencv.video.Video.OPTFLOW_FARNEBACK_GAUSSIAN">Constant
                            Field Values</a></dd>
                </dl>
            </li>
        </ul>
        <a name="OPTFLOW_LK_GET_MIN_EIGENVALS">
            <!--   -->
        </a>
        <ul class="blockList">
            <li class="blockList">
                <h4>OPTFLOW_LK_GET_MIN_EIGENVALS</h4>
                <pre>public static final&nbsp;int OPTFLOW_LK_GET_MIN_EIGENVALS</pre>
                <dl>
                    <dt><span class="strong">See Also:</span></dt>
                    <dd>
                        <a href="../../../constant-values.html#org.opencv.video.Video.OPTFLOW_LK_GET_MIN_EIGENVALS">Constant
                            Field Values</a></dd>
                </dl>
            </li>
        </ul>
        <a name="OPTFLOW_USE_INITIAL_FLOW">
            <!--   -->
        </a>
        <ul class="blockListLast">
            <li class="blockList">
                <h4>OPTFLOW_USE_INITIAL_FLOW</h4>
                <pre>public static final&nbsp;int OPTFLOW_USE_INITIAL_FLOW</pre>
                <dl>
                    <dt><span class="strong">See Also:</span></dt>
                    <dd>
                        <a href="../../../constant-values.html#org.opencv.video.Video.OPTFLOW_USE_INITIAL_FLOW">Constant
                            Field Values</a></dd>
                </dl>
            </li>
        </ul>
    </li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
    <li class="blockList"><a name="constructor_detail">
        <!--   -->
    </a>

        <h3>Constructor Detail</h3>
        <a name="Video()">
            <!--   -->
        </a>
        <ul class="blockListLast">
            <li class="blockList">
                <h4>Video</h4>
                <pre>public&nbsp;Video()</pre>
            </li>
        </ul>
    </li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
    <!--   -->
</a>

<h3>Method Detail</h3>
<a name="buildOpticalFlowPyramid(org.opencv.core.Mat, java.util.List, org.opencv.core.Size, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>buildOpticalFlowPyramid</h4>
<pre>public static&nbsp;int&nbsp;buildOpticalFlowPyramid(<a href="../../../org/opencv/core/Mat.html"
                                                            title="class in org.opencv.core">Mat</a>&nbsp;img,
                          java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                                               title="class in org.opencv.core">Mat</a>&gt;&nbsp;pyramid,
                          <a href="../../../org/opencv/core/Size.html"
                             title="class in org.opencv.core">Size</a>&nbsp;winSize,
                          int&nbsp;maxLevel)</pre>
        <div class="block"><p>Constructs the image pyramid which can be passed to
            "calcOpticalFlowPyrLK".</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>img</code> - 8-bit input image.</dd>
            <dd><code>pyramid</code> - output pyramid.</dd>
            <dd><code>winSize</code> - window size of optical flow algorithm. Must be not less than
                <code>winSize</code> argument of "calcOpticalFlowPyrLK". It is needed to
                calculate required padding for pyramid levels.
            </dd>
            <dd><code>maxLevel</code> - 0-based maximal pyramid level number.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#buildopticalflowpyramid">org.opencv.video.Video.buildOpticalFlowPyramid</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="buildOpticalFlowPyramid(org.opencv.core.Mat, java.util.List, org.opencv.core.Size, int, boolean, int, int, boolean)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>buildOpticalFlowPyramid</h4>
<pre>public static&nbsp;int&nbsp;buildOpticalFlowPyramid(<a href="../../../org/opencv/core/Mat.html"
                                                            title="class in org.opencv.core">Mat</a>&nbsp;img,
                          java.util.List&lt;<a href="../../../org/opencv/core/Mat.html"
                                               title="class in org.opencv.core">Mat</a>&gt;&nbsp;pyramid,
                          <a href="../../../org/opencv/core/Size.html"
                             title="class in org.opencv.core">Size</a>&nbsp;winSize,
                          int&nbsp;maxLevel,
                          boolean&nbsp;withDerivatives,
                          int&nbsp;pyrBorder,
                          int&nbsp;derivBorder,
                          boolean&nbsp;tryReuseInputImage)</pre>
        <div class="block"><p>Constructs the image pyramid which can be passed to
            "calcOpticalFlowPyrLK".</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>img</code> - 8-bit input image.</dd>
            <dd><code>pyramid</code> - output pyramid.</dd>
            <dd><code>winSize</code> - window size of optical flow algorithm. Must be not less than
                <code>winSize</code> argument of "calcOpticalFlowPyrLK". It is needed to
                calculate required padding for pyramid levels.
            </dd>
            <dd><code>maxLevel</code> - 0-based maximal pyramid level number.</dd>
            <dd><code>withDerivatives</code> - set to precompute gradients for the every pyramid
                level. If pyramid is constructed without the gradients then "calcOpticalFlowPyrLK"
                will calculate them internally.
            </dd>
            <dd><code>pyrBorder</code> - the border mode for pyramid layers.</dd>
            <dd><code>derivBorder</code> - the border mode for gradients.</dd>
            <dd><code>tryReuseInputImage</code> - put ROI of input image into the pyramid if
                possible. You can pass <code>false</code> to force data copying.

                <p>:return: number of levels in constructed pyramid. Can be less than
                    <code>maxLevel</code>.</p></dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#buildopticalflowpyramid">org.opencv.video.Video.buildOpticalFlowPyramid</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="calcGlobalOrientation(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>calcGlobalOrientation</h4>
<pre>public static&nbsp;double&nbsp;calcGlobalOrientation(<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;orientation,
                           <a href="../../../org/opencv/core/Mat.html"
                              title="class in org.opencv.core">Mat</a>&nbsp;mask,
                           <a href="../../../org/opencv/core/Mat.html"
                              title="class in org.opencv.core">Mat</a>&nbsp;mhi,
                           double&nbsp;timestamp,
                           double&nbsp;duration)</pre>
        <div class="block"><p>Calculates a global motion orientation in a selected region.</p>

            <p>The function calculates an average motion direction in the selected region
                and returns the angle between 0 degrees and 360 degrees. The average
                direction is computed from the weighted orientation histogram, where a recent
                motion has a larger weight and the motion occurred in the past has a smaller
                weight, as recorded in <code>mhi</code>.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>orientation</code> - Motion gradient orientation image calculated by the
                function "calcMotionGradient".
            </dd>
            <dd><code>mask</code> - Mask image. It may be a conjunction of a valid gradient mask,
                also calculated by "calcMotionGradient", and the mask of a region whose
                direction needs to be calculated.
            </dd>
            <dd><code>mhi</code> - Motion history image calculated by "updateMotionHistory".</dd>
            <dd><code>timestamp</code> - Timestamp passed to "updateMotionHistory".</dd>
            <dd><code>duration</code> - Maximum duration of a motion track in milliseconds, passed
                to
                "updateMotionHistory".
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#calcglobalorientation">org.opencv.video.Video.calcGlobalOrientation</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="calcMotionGradient(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>calcMotionGradient</h4>
<pre>public static&nbsp;void&nbsp;calcMotionGradient(<a href="../../../org/opencv/core/Mat.html"
                                                        title="class in org.opencv.core">Mat</a>&nbsp;mhi,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;orientation,
                      double&nbsp;delta1,
                      double&nbsp;delta2)</pre>
        <div class="block"><p>Calculates a gradient orientation of a motion history image.</p>

            <p>The function calculates a gradient orientation at each pixel <em>(x, y)</em>
                as:</p>

            <p><em>orientation(x,y)= arctan((dmhi/dy)/(dmhi/dx))</em></p>

            <p>In fact, "fastAtan2" and "phase" are used so that the computed angle is
                measured in degrees and covers the full range 0..360. Also, the
                <code>mask</code> is filled to indicate pixels where the computed angle is
                valid.</p>

            <p>Note:</p>
            <ul>
                <li> (Python) An example on how to perform a motion template technique can
                    be found at opencv_source_code/samples/python2/motempl.py
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>mhi</code> - Motion history single-channel floating-point image.</dd>
            <dd><code>mask</code> - Output mask image that has the type <code>CV_8UC1</code> and the
                same size as <code>mhi</code>. Its non-zero elements mark pixels where the
                motion gradient data is correct.
            </dd>
            <dd><code>orientation</code> - Output motion gradient orientation image that has the
                same
                type and the same size as <code>mhi</code>. Each pixel of the image is a
                motion orientation, from 0 to 360 degrees.
            </dd>
            <dd><code>delta1</code> - Minimal (or maximal) allowed difference between
                <code>mhi</code> values within a pixel neighborhood.
            </dd>
            <dd><code>delta2</code> - Maximal (or minimal) allowed difference between
                <code>mhi</code> values within a pixel neighborhood. That is, the function
                finds the minimum (<em>m(x,y)</em>) and maximum (<em>M(x,y)</em>)
                <code>mhi</code> values over <em>3 x 3</em> neighborhood of each pixel and
                marks the motion orientation at <em>(x, y)</em> as valid only if

                <p><em>min(delta1, delta2) <= M(x,y)-m(x,y) <= max(delta1, delta2).</em></p></dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#calcmotiongradient">org.opencv.video.Video.calcMotionGradient</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="calcMotionGradient(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, double, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>calcMotionGradient</h4>
<pre>public static&nbsp;void&nbsp;calcMotionGradient(<a href="../../../org/opencv/core/Mat.html"
                                                        title="class in org.opencv.core">Mat</a>&nbsp;mhi,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;orientation,
                      double&nbsp;delta1,
                      double&nbsp;delta2,
                      int&nbsp;apertureSize)</pre>
        <div class="block"><p>Calculates a gradient orientation of a motion history image.</p>

            <p>The function calculates a gradient orientation at each pixel <em>(x, y)</em>
                as:</p>

            <p><em>orientation(x,y)= arctan((dmhi/dy)/(dmhi/dx))</em></p>

            <p>In fact, "fastAtan2" and "phase" are used so that the computed angle is
                measured in degrees and covers the full range 0..360. Also, the
                <code>mask</code> is filled to indicate pixels where the computed angle is
                valid.</p>

            <p>Note:</p>
            <ul>
                <li> (Python) An example on how to perform a motion template technique can
                    be found at opencv_source_code/samples/python2/motempl.py
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>mhi</code> - Motion history single-channel floating-point image.</dd>
            <dd><code>mask</code> - Output mask image that has the type <code>CV_8UC1</code> and the
                same size as <code>mhi</code>. Its non-zero elements mark pixels where the
                motion gradient data is correct.
            </dd>
            <dd><code>orientation</code> - Output motion gradient orientation image that has the
                same
                type and the same size as <code>mhi</code>. Each pixel of the image is a
                motion orientation, from 0 to 360 degrees.
            </dd>
            <dd><code>delta1</code> - Minimal (or maximal) allowed difference between
                <code>mhi</code> values within a pixel neighborhood.
            </dd>
            <dd><code>delta2</code> - Maximal (or minimal) allowed difference between
                <code>mhi</code> values within a pixel neighborhood. That is, the function
                finds the minimum (<em>m(x,y)</em>) and maximum (<em>M(x,y)</em>)
                <code>mhi</code> values over <em>3 x 3</em> neighborhood of each pixel and
                marks the motion orientation at <em>(x, y)</em> as valid only if

                <p><em>min(delta1, delta2) <= M(x,y)-m(x,y) <= max(delta1, delta2).</em></p></dd>
            <dd><code>apertureSize</code> - Aperture size of the "Sobel" operator.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#calcmotiongradient">org.opencv.video.Video.calcMotionGradient</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="calcOpticalFlowFarneback(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double, int, int, int, int, double, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>calcOpticalFlowFarneback</h4>
<pre>public static&nbsp;void&nbsp;calcOpticalFlowFarneback(<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;prev,
                            <a href="../../../org/opencv/core/Mat.html"
                               title="class in org.opencv.core">Mat</a>&nbsp;next,
                            <a href="../../../org/opencv/core/Mat.html"
                               title="class in org.opencv.core">Mat</a>&nbsp;flow,
                            double&nbsp;pyr_scale,
                            int&nbsp;levels,
                            int&nbsp;winsize,
                            int&nbsp;iterations,
                            int&nbsp;poly_n,
                            double&nbsp;poly_sigma,
                            int&nbsp;flags)</pre>
        <div class="block"><p>Computes a dense optical flow using the Gunnar Farneback's
            algorithm.</p>

            <p>The function finds an optical flow for each <code>prev</code> pixel using the
                [Farneback2003] algorithm so that</p>

            <p><em>prev(y,x) ~ next(y + flow(y,x)[1], x + flow(y,x)[0])</em></p>

            <p>Note:</p>
            <ul>
                <li> An example using the optical flow algorithm described by Gunnar
                    Farneback can be found at opencv_source_code/samples/cpp/fback.cpp
                <li> (Python) An example using the optical flow algorithm described by
                    Gunnar Farneback can be found at opencv_source_code/samples/python2/opt_flow.py
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>prev</code> - first 8-bit single-channel input image.</dd>
            <dd><code>next</code> - second input image of the same size and the same type as
                <code>prev</code>.
            </dd>
            <dd><code>flow</code> - computed flow image that has the same size as <code>prev</code>
                and type <code>CV_32FC2</code>.
            </dd>
            <dd><code>pyr_scale</code> - parameter, specifying the image scale (<1) to build
                pyramids
                for each image; <code>pyr_scale=0.5</code> means a classical pyramid, where
                each next layer is twice smaller than the previous one.
            </dd>
            <dd><code>levels</code> - number of pyramid layers including the initial image;
                <code>levels=1</code> means that no extra layers are created and only the
                original images are used.
            </dd>
            <dd><code>winsize</code> - averaging window size; larger values increase the algorithm
                robustness to image noise and give more chances for fast motion detection,
                but yield more blurred motion field.
            </dd>
            <dd><code>iterations</code> - number of iterations the algorithm does at each pyramid
                level.
            </dd>
            <dd><code>poly_n</code> - size of the pixel neighborhood used to find polynomial
                expansion in each pixel; larger values mean that the image will be
                approximated with smoother surfaces, yielding more robust algorithm and more
                blurred motion field, typically <code>poly_n</code> =5 or 7.
            </dd>
            <dd><code>poly_sigma</code> - standard deviation of the Gaussian that is used to smooth
                derivatives used as a basis for the polynomial expansion; for
                <code>poly_n=5</code>, you can set <code>poly_sigma=1.1</code>, for
                <code>poly_n=7</code>, a good value would be <code>poly_sigma=1.5</code>.
            </dd>
            <dd><code>flags</code> - operation flags that can be a combination of the following:
                <ul>
                    <li> OPTFLOW_USE_INITIAL_FLOW uses the input <code>flow</code> as an
                        initial flow approximation.
                    <li> OPTFLOW_FARNEBACK_GAUSSIAN uses the Gaussian <em>winsizexwinsize</em>
                        filter instead of a box filter of the same size for optical flow estimation;
                        usually, this option gives z more accurate flow than with a box filter, at
                        the cost of lower speed; normally, <code>winsize</code> for a Gaussian
                        window
                        should be set to a larger value to achieve the same level of robustness.
                </ul>
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#calcopticalflowfarneback">org.opencv.video.Video.calcOpticalFlowFarneback</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="calcOpticalFlowPyrLK(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfByte, org.opencv.core.MatOfFloat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>calcOpticalFlowPyrLK</h4>
<pre>public static&nbsp;void&nbsp;calcOpticalFlowPyrLK(<a href="../../../org/opencv/core/Mat.html"
                                                          title="class in org.opencv.core">Mat</a>&nbsp;prevImg,
                        <a href="../../../org/opencv/core/Mat.html"
                           title="class in org.opencv.core">Mat</a>&nbsp;nextImg,
                        <a href="../../../org/opencv/core/MatOfPoint2f.html"
                           title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;prevPts,
                        <a href="../../../org/opencv/core/MatOfPoint2f.html"
                           title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;nextPts,
                        <a href="../../../org/opencv/core/MatOfByte.html"
                           title="class in org.opencv.core">MatOfByte</a>&nbsp;status,
                        <a href="../../../org/opencv/core/MatOfFloat.html"
                           title="class in org.opencv.core">MatOfFloat</a>&nbsp;err)</pre>
        <div class="block"><p>Calculates an optical flow for a sparse feature set using the
            iterative
            Lucas-Kanade method with pyramids.</p>

            <p>The function implements a sparse iterative version of the Lucas-Kanade
                optical flow in pyramids. See [Bouguet00]. The function is parallelized with
                the TBB library.</p>

            <p>Note:</p>
            <ul>
                <li> An example using the Lucas-Kanade optical flow algorithm can be found
                    at opencv_source_code/samples/cpp/lkdemo.cpp
                <li> (Python) An example using the Lucas-Kanade optical flow algorithm can
                    be found at opencv_source_code/samples/python2/lk_track.py
                <li> (Python) An example using the Lucas-Kanade tracker for homography
                    matching can be found at opencv_source_code/samples/python2/lk_homography.py
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>prevImg</code> - first 8-bit input image or pyramid constructed by
                "buildOpticalFlowPyramid".
            </dd>
            <dd><code>nextImg</code> - second input image or pyramid of the same size and the same
                type as <code>prevImg</code>.
            </dd>
            <dd><code>prevPts</code> - vector of 2D points for which the flow needs to be found;
                point coordinates must be single-precision floating-point numbers.
            </dd>
            <dd><code>nextPts</code> - output vector of 2D points (with single-precision
                floating-point coordinates) containing the calculated new positions of input
                features in the second image; when <code>OPTFLOW_USE_INITIAL_FLOW</code> flag
                is passed, the vector must have the same size as in the input.
            </dd>
            <dd><code>status</code> - output status vector (of unsigned chars); each element of the
                vector is set to 1 if the flow for the corresponding features has been found,
                otherwise, it is set to 0.
            </dd>
            <dd><code>err</code> - output vector of errors; each element of the vector is set to an
                error for the corresponding feature, type of the error measure can be set in
                <code>flags</code> parameter; if the flow wasn't found then the error is not
                defined (use the <code>status</code> parameter to find such cases).
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#calcopticalflowpyrlk">org.opencv.video.Video.calcOpticalFlowPyrLK</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="calcOpticalFlowPyrLK(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfByte, org.opencv.core.MatOfFloat, org.opencv.core.Size, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>calcOpticalFlowPyrLK</h4>
<pre>public static&nbsp;void&nbsp;calcOpticalFlowPyrLK(<a href="../../../org/opencv/core/Mat.html"
                                                          title="class in org.opencv.core">Mat</a>&nbsp;prevImg,
                        <a href="../../../org/opencv/core/Mat.html"
                           title="class in org.opencv.core">Mat</a>&nbsp;nextImg,
                        <a href="../../../org/opencv/core/MatOfPoint2f.html"
                           title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;prevPts,
                        <a href="../../../org/opencv/core/MatOfPoint2f.html"
                           title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;nextPts,
                        <a href="../../../org/opencv/core/MatOfByte.html"
                           title="class in org.opencv.core">MatOfByte</a>&nbsp;status,
                        <a href="../../../org/opencv/core/MatOfFloat.html"
                           title="class in org.opencv.core">MatOfFloat</a>&nbsp;err,
                        <a href="../../../org/opencv/core/Size.html"
                           title="class in org.opencv.core">Size</a>&nbsp;winSize,
                        int&nbsp;maxLevel)</pre>
        <div class="block"><p>Calculates an optical flow for a sparse feature set using the
            iterative
            Lucas-Kanade method with pyramids.</p>

            <p>The function implements a sparse iterative version of the Lucas-Kanade
                optical flow in pyramids. See [Bouguet00]. The function is parallelized with
                the TBB library.</p>

            <p>Note:</p>
            <ul>
                <li> An example using the Lucas-Kanade optical flow algorithm can be found
                    at opencv_source_code/samples/cpp/lkdemo.cpp
                <li> (Python) An example using the Lucas-Kanade optical flow algorithm can
                    be found at opencv_source_code/samples/python2/lk_track.py
                <li> (Python) An example using the Lucas-Kanade tracker for homography
                    matching can be found at opencv_source_code/samples/python2/lk_homography.py
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>prevImg</code> - first 8-bit input image or pyramid constructed by
                "buildOpticalFlowPyramid".
            </dd>
            <dd><code>nextImg</code> - second input image or pyramid of the same size and the same
                type as <code>prevImg</code>.
            </dd>
            <dd><code>prevPts</code> - vector of 2D points for which the flow needs to be found;
                point coordinates must be single-precision floating-point numbers.
            </dd>
            <dd><code>nextPts</code> - output vector of 2D points (with single-precision
                floating-point coordinates) containing the calculated new positions of input
                features in the second image; when <code>OPTFLOW_USE_INITIAL_FLOW</code> flag
                is passed, the vector must have the same size as in the input.
            </dd>
            <dd><code>status</code> - output status vector (of unsigned chars); each element of the
                vector is set to 1 if the flow for the corresponding features has been found,
                otherwise, it is set to 0.
            </dd>
            <dd><code>err</code> - output vector of errors; each element of the vector is set to an
                error for the corresponding feature, type of the error measure can be set in
                <code>flags</code> parameter; if the flow wasn't found then the error is not
                defined (use the <code>status</code> parameter to find such cases).
            </dd>
            <dd><code>winSize</code> - size of the search window at each pyramid level.</dd>
            <dd><code>maxLevel</code> - 0-based maximal pyramid level number; if set to 0, pyramids
                are not used (single level), if set to 1, two levels are used, and so on; if
                pyramids are passed to input then algorithm will use as many levels as
                pyramids have but no more than <code>maxLevel</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#calcopticalflowpyrlk">org.opencv.video.Video.calcOpticalFlowPyrLK</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="calcOpticalFlowPyrLK(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfByte, org.opencv.core.MatOfFloat, org.opencv.core.Size, int, org.opencv.core.TermCriteria, int, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>calcOpticalFlowPyrLK</h4>
<pre>public static&nbsp;void&nbsp;calcOpticalFlowPyrLK(<a href="../../../org/opencv/core/Mat.html"
                                                          title="class in org.opencv.core">Mat</a>&nbsp;prevImg,
                        <a href="../../../org/opencv/core/Mat.html"
                           title="class in org.opencv.core">Mat</a>&nbsp;nextImg,
                        <a href="../../../org/opencv/core/MatOfPoint2f.html"
                           title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;prevPts,
                        <a href="../../../org/opencv/core/MatOfPoint2f.html"
                           title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;nextPts,
                        <a href="../../../org/opencv/core/MatOfByte.html"
                           title="class in org.opencv.core">MatOfByte</a>&nbsp;status,
                        <a href="../../../org/opencv/core/MatOfFloat.html"
                           title="class in org.opencv.core">MatOfFloat</a>&nbsp;err,
                        <a href="../../../org/opencv/core/Size.html"
                           title="class in org.opencv.core">Size</a>&nbsp;winSize,
                        int&nbsp;maxLevel,
                        <a href="../../../org/opencv/core/TermCriteria.html"
                           title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria,
                        int&nbsp;flags,
                        double&nbsp;minEigThreshold)</pre>
        <div class="block"><p>Calculates an optical flow for a sparse feature set using the
            iterative
            Lucas-Kanade method with pyramids.</p>

            <p>The function implements a sparse iterative version of the Lucas-Kanade
                optical flow in pyramids. See [Bouguet00]. The function is parallelized with
                the TBB library.</p>

            <p>Note:</p>
            <ul>
                <li> An example using the Lucas-Kanade optical flow algorithm can be found
                    at opencv_source_code/samples/cpp/lkdemo.cpp
                <li> (Python) An example using the Lucas-Kanade optical flow algorithm can
                    be found at opencv_source_code/samples/python2/lk_track.py
                <li> (Python) An example using the Lucas-Kanade tracker for homography
                    matching can be found at opencv_source_code/samples/python2/lk_homography.py
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>prevImg</code> - first 8-bit input image or pyramid constructed by
                "buildOpticalFlowPyramid".
            </dd>
            <dd><code>nextImg</code> - second input image or pyramid of the same size and the same
                type as <code>prevImg</code>.
            </dd>
            <dd><code>prevPts</code> - vector of 2D points for which the flow needs to be found;
                point coordinates must be single-precision floating-point numbers.
            </dd>
            <dd><code>nextPts</code> - output vector of 2D points (with single-precision
                floating-point coordinates) containing the calculated new positions of input
                features in the second image; when <code>OPTFLOW_USE_INITIAL_FLOW</code> flag
                is passed, the vector must have the same size as in the input.
            </dd>
            <dd><code>status</code> - output status vector (of unsigned chars); each element of the
                vector is set to 1 if the flow for the corresponding features has been found,
                otherwise, it is set to 0.
            </dd>
            <dd><code>err</code> - output vector of errors; each element of the vector is set to an
                error for the corresponding feature, type of the error measure can be set in
                <code>flags</code> parameter; if the flow wasn't found then the error is not
                defined (use the <code>status</code> parameter to find such cases).
            </dd>
            <dd><code>winSize</code> - size of the search window at each pyramid level.</dd>
            <dd><code>maxLevel</code> - 0-based maximal pyramid level number; if set to 0, pyramids
                are not used (single level), if set to 1, two levels are used, and so on; if
                pyramids are passed to input then algorithm will use as many levels as
                pyramids have but no more than <code>maxLevel</code>.
            </dd>
            <dd><code>criteria</code> - parameter, specifying the termination criteria of the
                iterative search algorithm (after the specified maximum number of iterations
                <code>criteria.maxCount</code> or when the search window moves by less than
                <code>criteria.epsilon</code>.
            </dd>
            <dd><code>flags</code> - operation flags:
                <ul>
                    <li> OPTFLOW_USE_INITIAL_FLOW uses initial estimations, stored in
                        <code>nextPts</code>; if the flag is not set, then <code>prevPts</code> is
                        copied to <code>nextPts</code> and is considered the initial estimate.
                    <li> OPTFLOW_LK_GET_MIN_EIGENVALS use minimum eigen values as an error
                        measure (see <code>minEigThreshold</code> description); if the flag is not
                        set, then L1 distance between patches around the original and a moved point,
                        divided by number of pixels in a window, is used as a error measure.
                </ul>
            </dd>
            <dd><code>minEigThreshold</code> - the algorithm calculates the minimum eigen value of a
                2x2 normal matrix of optical flow equations (this matrix is called a spatial
                gradient matrix in [Bouguet00]), divided by number of pixels in a window; if
                this value is less than <code>minEigThreshold</code>, then a corresponding
                feature is filtered out and its flow is not processed, so it allows to remove
                bad points and get a performance boost.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#calcopticalflowpyrlk">org.opencv.video.Video.calcOpticalFlowPyrLK</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="calcOpticalFlowSF(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>calcOpticalFlowSF</h4>
<pre>public static&nbsp;void&nbsp;calcOpticalFlowSF(<a href="../../../org/opencv/core/Mat.html"
                                                       title="class in org.opencv.core">Mat</a>&nbsp;from,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;to,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;flow,
                     int&nbsp;layers,
                     int&nbsp;averaging_block_size,
                     int&nbsp;max_flow)</pre>
        <div class="block"><p>Calculate an optical flow using "SimpleFlow" algorithm.</p>

            <p>See [Tao2012]. And site of project -
                http://graphics.berkeley.edu/papers/Tao-SAN-2012-05/.</p>

            <p>Note:</p>
            <ul>
                <li> An example using the simpleFlow algorithm can be found at
                    opencv_source_code/samples/cpp/simpleflow_demo.cpp
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>from</code> - a from</dd>
            <dd><code>to</code> - a to</dd>
            <dd><code>flow</code> - a flow</dd>
            <dd><code>layers</code> - Number of layers</dd>
            <dd><code>averaging_block_size</code> - Size of block through which we sum up when
                calculate cost function for pixel
            </dd>
            <dd><code>max_flow</code> - maximal flow that we search at each level</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#calcopticalflowsf">org.opencv.video.Video.calcOpticalFlowSF</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="calcOpticalFlowSF(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, double, double, int, double, double, double, int, double, double, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>calcOpticalFlowSF</h4>
<pre>public static&nbsp;void&nbsp;calcOpticalFlowSF(<a href="../../../org/opencv/core/Mat.html"
                                                       title="class in org.opencv.core">Mat</a>&nbsp;from,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;to,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;flow,
                     int&nbsp;layers,
                     int&nbsp;averaging_block_size,
                     int&nbsp;max_flow,
                     double&nbsp;sigma_dist,
                     double&nbsp;sigma_color,
                     int&nbsp;postprocess_window,
                     double&nbsp;sigma_dist_fix,
                     double&nbsp;sigma_color_fix,
                     double&nbsp;occ_thr,
                     int&nbsp;upscale_averaging_radius,
                     double&nbsp;upscale_sigma_dist,
                     double&nbsp;upscale_sigma_color,
                     double&nbsp;speed_up_thr)</pre>
        <div class="block"><p>Calculate an optical flow using "SimpleFlow" algorithm.</p>

            <p>See [Tao2012]. And site of project -
                http://graphics.berkeley.edu/papers/Tao-SAN-2012-05/.</p>

            <p>Note:</p>
            <ul>
                <li> An example using the simpleFlow algorithm can be found at
                    opencv_source_code/samples/cpp/simpleflow_demo.cpp
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>from</code> - a from</dd>
            <dd><code>to</code> - a to</dd>
            <dd><code>flow</code> - a flow</dd>
            <dd><code>layers</code> - Number of layers</dd>
            <dd><code>averaging_block_size</code> - Size of block through which we sum up when
                calculate cost function for pixel
            </dd>
            <dd><code>max_flow</code> - maximal flow that we search at each level</dd>
            <dd><code>sigma_dist</code> - vector smooth spatial sigma parameter</dd>
            <dd><code>sigma_color</code> - vector smooth color sigma parameter</dd>
            <dd><code>postprocess_window</code> - window size for postprocess cross bilateral filter
            </dd>
            <dd><code>sigma_dist_fix</code> - spatial sigma for postprocess cross bilateralf filter
            </dd>
            <dd><code>sigma_color_fix</code> - color sigma for postprocess cross bilateral filter
            </dd>
            <dd><code>occ_thr</code> - threshold for detecting occlusions</dd>
            <dd><code>upscale_averaging_radius</code> - a upscale_averaging_radius</dd>
            <dd><code>upscale_sigma_dist</code> - spatial sigma for bilateral upscale operation</dd>
            <dd><code>upscale_sigma_color</code> - color sigma for bilateral upscale operation</dd>
            <dd><code>speed_up_thr</code> - threshold to detect point with irregular flow - where
                flow should be recalculated after upscale
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#calcopticalflowsf">org.opencv.video.Video.calcOpticalFlowSF</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="CamShift(org.opencv.core.Mat, org.opencv.core.Rect, org.opencv.core.TermCriteria)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CamShift</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/RotatedRect.html"
                           title="class in org.opencv.core">RotatedRect</a>&nbsp;CamShift(<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;probImage,
                   <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;window,
                   <a href="../../../org/opencv/core/TermCriteria.html"
                      title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria)</pre>
        <div class="block"><p>Finds an object center, size, and orientation.</p>

            <p>The function implements the CAMSHIFT object tracking algorithm [Bradski98].
                First, it finds an object center using "meanShift" and then adjusts the
                window size and finds the optimal rotation. The function returns the rotated
                rectangle structure that includes the object position, size, and orientation.
                The next position of the search window can be obtained with <code>RotatedRect.boundingRect()</code>.
            </p>

            <p>See the OpenCV sample <code>camshiftdemo.c</code> that tracks colored
                objects.</p>

            <p>Note:</p>
            <ul>
                <li> (Python) A sample explaining the camshift tracking algorithm can be
                    found at opencv_source_code/samples/python2/camshift.py
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>probImage</code> - Back projection of the object histogram. See
                "calcBackProject".
            </dd>
            <dd><code>window</code> - Initial search window.</dd>
            <dd><code>criteria</code> - Stop criteria for the underlying "meanShift".

                <p>:returns: (in old interfaces) Number of iterations CAMSHIFT took to converge</p>
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#camshift">org.opencv.video.Video.CamShift</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="estimateRigidTransform(org.opencv.core.Mat, org.opencv.core.Mat, boolean)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>estimateRigidTransform</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html"
                           title="class in org.opencv.core">Mat</a>&nbsp;estimateRigidTransform(<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                         <a href="../../../org/opencv/core/Mat.html"
                            title="class in org.opencv.core">Mat</a>&nbsp;dst,
                         boolean&nbsp;fullAffine)</pre>
        <div class="block"><p>Computes an optimal affine transformation between two 2D point
            sets.</p>

            <p>The function finds an optimal affine transform *[A|b]* (a <code>2 x 3</code>
                floating-point matrix) that approximates best the affine transformation
                between:</p>
            <ul>
                <li> Two point sets
                <li> Two raster images. In this case, the function first finds some
                    features in the <code>src</code> image and finds the corresponding features
                    in <code>dst</code> image. After that, the problem is reduced to the first
                    case.
            </ul>

            <p>In case of point sets, the problem is formulated as follows: you need to find
                a 2x2 matrix *A* and 2x1 vector *b* so that:</p>

            <p><em>[A^*|b^*] = arg min _([A|b]) sum _i|dst[i] - A (src[i])^T - b| ^2</em></p>

            <p>where <code>src[i]</code> and <code>dst[i]</code> are the i-th points in
                <code>src</code> and <code>dst</code>, respectively</p>

            <p><em>[A|b]</em> can be either arbitrary (when <code>fullAffine=true</code>) or
                have a form of</p>

            <p><em>a_11 a_12 b_1
                -a_12 a_11 b_2 </em></p>

            <p>when <code>fullAffine=false</code>.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - First input 2D point set stored in <code>std.vector</code> or
                <code>Mat</code>, or an image stored in <code>Mat</code>.
            </dd>
            <dd><code>dst</code> - Second input 2D point set of the same size and the same type as
                <code>A</code>, or another image.
            </dd>
            <dd><code>fullAffine</code> - If true, the function finds an optimal affine
                transformation with no additional restrictions (6 degrees of freedom).
                Otherwise, the class of transformations to choose from is limited to
                combinations of translation, rotation, and uniform scaling (5 degrees of
                freedom).
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#estimaterigidtransform">org.opencv.video.Video.estimateRigidTransform</a>,
                <a href="../../../org/opencv/calib3d/Calib3d.html#findHomography(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, int, double, org.opencv.core.Mat)"><code>Calib3d.findHomography(org.opencv.core.MatOfPoint2f,
                    org.opencv.core.MatOfPoint2f, int, double, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#getAffineTransform(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f)"><code>Imgproc.getAffineTransform(org.opencv.core.MatOfPoint2f,
                    org.opencv.core.MatOfPoint2f)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#getPerspectiveTransform(org.opencv.core.Mat, org.opencv.core.Mat)"><code>Imgproc.getPerspectiveTransform(org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="meanShift(org.opencv.core.Mat, org.opencv.core.Rect, org.opencv.core.TermCriteria)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>meanShift</h4>
<pre>public static&nbsp;int&nbsp;meanShift(<a href="../../../org/opencv/core/Mat.html"
                                              title="class in org.opencv.core">Mat</a>&nbsp;probImage,
            <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;window,
            <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria)</pre>
        <div class="block"><p>Finds an object on a back projection image.</p>

            <p>The function implements the iterative object search algorithm. It takes the
                input back projection of an object and the initial position. The mass center
                in <code>window</code> of the back projection image is computed and the
                search window center shifts to the mass center. The procedure is repeated
                until the specified number of iterations <code>criteria.maxCount</code> is
                done or until the window center shifts by less than <code>criteria.epsilon</code>.
                The algorithm is used inside "CamShift" and, unlike "CamShift", the search
                window size or orientation do not change during the search. You can simply
                pass the output of "calcBackProject" to this function. But better results can
                be obtained if you pre-filter the back projection and remove the noise. For
                example, you can do this by retrieving connected components with
                "findContours", throwing away contours with small area ("contourArea"), and
                rendering the remaining contours with "drawContours".</p>

            <p>Note:</p>
            <ul>
                <li> A mean-shift tracking sample can be found at
                    opencv_source_code/samples/cpp/camshiftdemo.cpp
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>probImage</code> - Back projection of the object histogram. See
                "calcBackProject" for details.
            </dd>
            <dd><code>window</code> - Initial search window.</dd>
            <dd><code>criteria</code> - Stop criteria for the iterative search algorithm.

                <p>:returns: Number of iterations CAMSHIFT took to converge.</p></dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#meanshift">org.opencv.video.Video.meanShift</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="segmentMotion(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfRect, double, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>segmentMotion</h4>
<pre>public static&nbsp;void&nbsp;segmentMotion(<a href="../../../org/opencv/core/Mat.html"
                                                   title="class in org.opencv.core">Mat</a>&nbsp;mhi,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;segmask,
                 <a href="../../../org/opencv/core/MatOfRect.html" title="class in org.opencv.core">MatOfRect</a>&nbsp;boundingRects,
                 double&nbsp;timestamp,
                 double&nbsp;segThresh)</pre>
        <div class="block"><p>Splits a motion history image into a few parts corresponding to
            separate
            independent motions (for example, left hand, right hand).</p>

            <p>The function finds all of the motion segments and marks them in
                <code>segmask</code> with individual values (1,2,...). It also computes a
                vector with ROIs of motion connected components. After that the motion
                direction for every component can be calculated with "calcGlobalOrientation"
                using the extracted mask of the particular component.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>mhi</code> - Motion history image.</dd>
            <dd><code>segmask</code> - Image where the found mask should be stored, single-channel,
                32-bit floating-point.
            </dd>
            <dd><code>boundingRects</code> - Vector containing ROIs of motion connected components.
            </dd>
            <dd><code>timestamp</code> - Current time in milliseconds or other units.</dd>
            <dd><code>segThresh</code> - Segmentation threshold that is recommended to be equal to
                the interval between motion history "steps" or greater.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#segmentmotion">org.opencv.video.Video.segmentMotion</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="updateMotionHistory(org.opencv.core.Mat, org.opencv.core.Mat, double, double)">
    <!--   -->
</a>
<ul class="blockListLast">
    <li class="blockList">
        <h4>updateMotionHistory</h4>
<pre>public static&nbsp;void&nbsp;updateMotionHistory(<a href="../../../org/opencv/core/Mat.html"
                                                         title="class in org.opencv.core">Mat</a>&nbsp;silhouette,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mhi,
                       double&nbsp;timestamp,
                       double&nbsp;duration)</pre>
        <div class="block"><p>Updates the motion history image by a moving silhouette.</p>

            <p>The function updates the motion history image as follows:</p>

            <p><em>mhi(x,y)= timestamp if silhouette(x,y) != 0; 0 if silhouette(x,y) = 0 and
                mhi &lt(timestamp - duration); mhi(x,y) otherwise</em></p>

            <p>That is, MHI pixels where the motion occurs are set to the current
                <code>timestamp</code>, while the pixels where the motion happened last time
                a long time ago are cleared.</p>

            <p>The function, together with "calcMotionGradient" and "calcGlobalOrientation",
                implements a motion templates technique described in [Davis97] and
                [Bradski00].
                See also the OpenCV sample <code>motempl.c</code> that demonstrates the use
                of all the motion template functions.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>silhouette</code> - Silhouette mask that has non-zero pixels where the motion
                occurs.
            </dd>
            <dd><code>mhi</code> - Motion history image that is updated by the function
                (single-channel, 32-bit floating-point).
            </dd>
            <dd><code>timestamp</code> - Current time in milliseconds or other units.</dd>
            <dd><code>duration</code> - Maximal duration of the motion track in the same units as
                <code>timestamp</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html#updatemotionhistory">org.opencv.video.Video.updateMotionHistory</a>
            </dd>
        </dl>
    </li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
    <!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a
        name="navbar_bottom_firstrow">
    <!--   -->
</a>
    <ul class="navList" title="Navigation">
        <li><a href="../../../overview-summary.html">Overview</a></li>
        <li><a href="package-summary.html">Package</a></li>
        <li class="navBarCell1Rev">Class</li>
        <li><a href="package-tree.html">Tree</a></li>
        <li><a href="../../../index-all.html">Index</a></li>
        <li><a href="../../../help-doc.html">Help</a></li>
    </ul>
    <div class="aboutLanguage"><em><a href=http://docs.opencv.org>OpenCV 2.4.11
        Documentation</a></em></div>
</div>
<div class="subNav">
    <ul class="navList">
        <li><a href="../../../org/opencv/video/KalmanFilter.html" title="class in org.opencv.video"><span
                class="strong">PREV CLASS</span></a></li>
        <li>NEXT CLASS</li>
    </ul>
    <ul class="navList">
        <li><a href="../../../index.html?org/opencv/video/Video.html" target="_top">FRAMES</a></li>
        <li><a href="Video.html" target="_top">NO FRAMES</a></li>
    </ul>
    <ul class="navList" id="allclasses_navbar_bottom">
        <li><a href="../../../allclasses-noframe.html">All Classes</a></li>
    </ul>
    <div>
        <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->

        </script>
    </div>
    <div>
        <ul class="subNavList">
            <li>SUMMARY:&nbsp;</li>
            <li>NESTED&nbsp;|&nbsp;</li>
            <li><a href="#field_summary">FIELD</a>&nbsp;|&nbsp;</li>
            <li><a href="#constructor_summary">CONSTR</a>&nbsp;|&nbsp;</li>
            <li><a href="#method_summary">METHOD</a></li>
        </ul>
        <ul class="subNavList">
            <li>DETAIL:&nbsp;</li>
            <li><a href="#field_detail">FIELD</a>&nbsp;|&nbsp;</li>
            <li><a href="#constructor_detail">CONSTR</a>&nbsp;|&nbsp;</li>
            <li><a href="#method_detail">METHOD</a></li>
        </ul>
    </div>
    <a name="skip-navbar_bottom">
        <!--   -->
    </a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
