<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
    <!-- Generated by javadoc (version 1.6.0_34) on Wed Mar 04 17:44:05 MSK 2015 -->
    <title>Mat</title>
    <meta name="date" content="2015-03-04">
    <link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Mat";
    }
//-->

</script>
<noscript>
    <div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
    <!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
    <!--   -->
</a>
    <ul class="navList" title="Navigation">
        <li><a href="../../../overview-summary.html">Overview</a></li>
        <li><a href="package-summary.html">Package</a></li>
        <li class="navBarCell1Rev">Class</li>
        <li><a href="package-tree.html">Tree</a></li>
        <li><a href="../../../index-all.html">Index</a></li>
        <li><a href="../../../help-doc.html">Help</a></li>
    </ul>
    <div class="aboutLanguage"><em>OpenCV 2.4.11</em></div>
</div>
<div class="subNav">
    <ul class="navList">
        <li><a href="../../../org/opencv/core/CvType.html" title="class in org.opencv.core"><span
                class="strong">PREV CLASS</span></a></li>
        <li><a href="../../../org/opencv/core/MatOfByte.html" title="class in org.opencv.core"><span
                class="strong">NEXT CLASS</span></a></li>
    </ul>
    <ul class="navList">
        <li><a href="../../../index.html?org/opencv/core/Mat.html" target="_top">FRAMES</a></li>
        <li><a href="Mat.html" target="_top">NO FRAMES</a></li>
    </ul>
    <ul class="navList" id="allclasses_navbar_top">
        <li><a href="../../../allclasses-noframe.html">All Classes</a></li>
    </ul>
    <div>
        <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->

        </script>
    </div>
    <div>
        <ul class="subNavList">
            <li>SUMMARY:&nbsp;</li>
            <li>NESTED&nbsp;|&nbsp;</li>
            <li><a href="#field_summary">FIELD</a>&nbsp;|&nbsp;</li>
            <li><a href="#constructor_summary">CONSTR</a>&nbsp;|&nbsp;</li>
            <li><a href="#method_summary">METHOD</a></li>
        </ul>
        <ul class="subNavList">
            <li>DETAIL:&nbsp;</li>
            <li><a href="#field_detail">FIELD</a>&nbsp;|&nbsp;</li>
            <li><a href="#constructor_detail">CONSTR</a>&nbsp;|&nbsp;</li>
            <li><a href="#method_detail">METHOD</a></li>
        </ul>
    </div>
    <a name="skip-navbar_top">
        <!--   -->
    </a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
    <p class="subTitle">org.opencv.core</p>

    <h2 title="Class Mat" class="title">Class Mat</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
    <li>java.lang.Object</li>
    <li>
        <ul class="inheritance">
            <li>org.opencv.core.Mat</li>
        </ul>
    </li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
    <dt>Direct Known Subclasses:</dt>
    <dd><a href="../../../org/opencv/core/MatOfByte.html"
           title="class in org.opencv.core">MatOfByte</a>, <a
            href="../../../org/opencv/core/MatOfDMatch.html" title="class in org.opencv.core">MatOfDMatch</a>,
        <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>,
        <a href="../../../org/opencv/core/MatOfFloat.html" title="class in org.opencv.core">MatOfFloat</a>,
        <a href="../../../org/opencv/core/MatOfFloat4.html" title="class in org.opencv.core">MatOfFloat4</a>,
        <a href="../../../org/opencv/core/MatOfFloat6.html" title="class in org.opencv.core">MatOfFloat6</a>,
        <a href="../../../org/opencv/core/MatOfInt.html"
           title="class in org.opencv.core">MatOfInt</a>, <a
                href="../../../org/opencv/core/MatOfInt4.html" title="class in org.opencv.core">MatOfInt4</a>,
        <a href="../../../org/opencv/core/MatOfKeyPoint.html" title="class in org.opencv.core">MatOfKeyPoint</a>,
        <a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>,
        <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>,
        <a href="../../../org/opencv/core/MatOfPoint3.html" title="class in org.opencv.core">MatOfPoint3</a>,
        <a href="../../../org/opencv/core/MatOfPoint3f.html" title="class in org.opencv.core">MatOfPoint3f</a>,
        <a href="../../../org/opencv/core/MatOfRect.html"
           title="class in org.opencv.core">MatOfRect</a></dd>
</dl>
<hr>
<br>
<pre>public class <strong>Mat</strong>
extends java.lang.Object</pre>
<div class="block"><p>OpenCV C++ n-dimensional dense array class</p>

<p>class CV_EXPORTS Mat <code></p>

<p>// C++ code:</p>


<p>public:</p>

<p>//... a lot of methods......</p>

<p>/ *! includes several bit-fields:</p>

<p>- the magic signature</p>

<p>- continuity flag</p>

<p>- depth</p>

<p>- number of channels</p>
<ul>
    <li> /
</ul>

<p>int flags;</p>

<p>//! the array dimensionality, >= 2</p>

<p>int dims;</p>

<p>//! the number of rows and columns or (-1, -1) when the array has more than 2
    dimensions</p>

<p>int rows, cols;</p>

<p>//! pointer to the data</p>

<p>uchar* data;</p>

<p>//! pointer to the reference counter;</p>

<p>// when array points to user-allocated data, the pointer is NULL</p>

<p>int* refcount;</p>

<p>// other members...</p>

<p>};</p>

<p>The class <code>Mat</code> represents an n-dimensional dense numerical
    single-channel or multi-channel array. It can be used to store real or
    complex-valued vectors and matrices, grayscale or color images, voxel
    volumes, vector fields, point clouds, tensors, histograms (though, very
    high-dimensional histograms may be better stored in a <code>SparseMat</code>).
    The data layout of the array </code></p>

<p><em>M</em> is defined by the array <code>M.step[]</code>, so that the address
    of element <em>(i_0,...,i_(M.dims-1))</em>, where <em>0 <= i_k&ltM.size[k]</em>,
    is computed as:</p>

<p><em>addr(M_(i_0,...,i_(M.dims-1))) = M.data + M.step[0]*i_0 + M.step[1]*i_1
    +... + M.step[M.dims-1]*i_(M.dims-1)</em></p>

<p>In case of a 2-dimensional array, the above formula is reduced to:</p>

<p><em>addr(M_(i,j)) = M.data + M.step[0]*i + M.step[1]*j</em></p>

<p>Note that <code>M.step[i] >= M.step[i+1]</code> (in fact, <code>M.step[i] >=
    M.step[i+1]*M.size[i+1]</code>). This means that 2-dimensional matrices are
    stored row-by-row, 3-dimensional matrices are stored plane-by-plane, and so
    on. <code>M.step[M.dims-1]</code> is minimal and always equal to the element
    size <code>M.elemSize()</code>.</p>

<p>So, the data layout in <code>Mat</code> is fully compatible with
    <code>CvMat</code>, <code>IplImage</code>, and <code>CvMatND</code> types
    from OpenCV 1.x. It is also compatible with the majority of dense array types
    from the standard toolkits and SDKs, such as Numpy (ndarray), Win32
    (independent device bitmaps), and others, that is, with any array that uses
    *steps* (or *strides*) to compute the position of a pixel. Due to this
    compatibility, it is possible to make a <code>Mat</code> header for
    user-allocated data and process it in-place using OpenCV functions.</p>

<p>There are many different ways to create a <code>Mat</code> object. The most
    popular options are listed below:</p>
<ul>
    <li> Use the <code>create(nrows, ncols, type)</code> method or the similar
        <code>Mat(nrows, ncols, type[, fillValue])</code> constructor. A new array of
        the specified size and type is allocated. <code>type</code> has the same
        meaning as in the <code>cvCreateMat</code> method.
</ul>
<p>For example, <code>CV_8UC1</code> means a 8-bit single-channel array,
    <code>CV_32FC2</code> means a 2-channel (complex) floating-point array, and
    so on.</p>

<p><code></p>

<p>// C++ code:</p>

<p>// make a 7x7 complex matrix filled with 1+3j.</p>

<p>Mat M(7,7,CV_32FC2,Scalar(1,3));</p>

<p>// and now turn M to a 100x60 15-channel 8-bit matrix.</p>

<p>// The old content will be deallocated</p>

<p>M.create(100,60,CV_8UC(15));</p>

<p></code></p>

<p>As noted in the introduction to this chapter, <code>create()</code> allocates
    only a new array when the shape or type of the current array are different
    from the specified ones.</p>
<ul>
    <li> Create a multi-dimensional array:
</ul>

<p><code></p>

<p>// C++ code:</p>

<p>// create a 100x100x100 8-bit array</p>

<p>int sz[] = {100, 100, 100};</p>

<p>Mat bigCube(3, sz, CV_8U, Scalar.all(0));</p>

<p></code></p>

<p>It passes the number of dimensions =1 to the <code>Mat</code> constructor but
    the created array will be 2-dimensional with the number of columns set to 1.
    So, <code>Mat.dims</code> is always >= 2 (can also be 0 when the array is
    empty).</p>
<ul>
    <li> Use a copy constructor or assignment operator where there can be an
        array or expression on the right side (see below). As noted in the
        introduction, the array assignment is an O(1) operation because it only
        copies the header and increases the reference counter. The <code>Mat.clone()</code>
        method can be used to get a full (deep) copy of the array when you need it.
    <li> Construct a header for a part of another array. It can be a single
        row, single column, several rows, several columns, rectangular region in the
        array (called a *minor* in algebra) or a diagonal. Such operations are also
        O(1) because the new header references the same data. You can actually modify
        a part of the array using this feature, for example:
</ul>

<p><code></p>

<p>// C++ code:</p>

<p>// add the 5-th row, multiplied by 3 to the 3rd row</p>

<p>M.row(3) = M.row(3) + M.row(5)*3;</p>

<p>// now copy the 7-th column to the 1-st column</p>

<p>// M.col(1) = M.col(7); // this will not work</p>

<p>Mat M1 = M.col(1);</p>

<p>M.col(7).copyTo(M1);</p>

<p>// create a new 320x240 image</p>

<p>Mat img(Size(320,240),CV_8UC3);</p>

<p>// select a ROI</p>

<p>Mat roi(img, Rect(10,10,100,100));</p>

<p>// fill the ROI with (0,255,0) (which is green in RGB space);</p>

<p>// the original 320x240 image will be modified</p>

<p>roi = Scalar(0,255,0);</p>

<p></code></p>

<p>Due to the additional <code>datastart</code> and <code>dataend</code>
    members, it is possible to compute a relative sub-array position in the main
    *container* array using <code>locateROI()</code>:</p>

<p><code></p>

<p>// C++ code:</p>

<p>Mat A = Mat.eye(10, 10, CV_32S);</p>

<p>// extracts A columns, 1 (inclusive) to 3 (exclusive).</p>

<p>Mat B = A(Range.all(), Range(1, 3));</p>

<p>// extracts B rows, 5 (inclusive) to 9 (exclusive).</p>

<p>// that is, C ~ A(Range(5, 9), Range(1, 3))</p>

<p>Mat C = B(Range(5, 9), Range.all());</p>

<p>Size size; Point ofs;</p>

<p>C.locateROI(size, ofs);</p>

<p>// size will be (width=10,height=10) and the ofs will be (x=1, y=5)</p>

<p></code></p>

<p>As in case of whole matrices, if you need a deep copy, use the
    <code>clone()</code> method of the extracted sub-matrices.</p>
<ul>
    <li> Make a header for user-allocated data. It can be useful to do the
        following:
    <li> Process "foreign" data using OpenCV (for example, when you implement a
        DirectShow* filter or a processing module for <code>gstreamer</code>, and so
        on). For example:
</ul>

<p><code></p>

<p>// C++ code:</p>

<p>void process_video_frame(const unsigned char* pixels,</p>

<p>int width, int height, int step)</p>


<p>Mat img(height, width, CV_8UC3, pixels, step);</p>

<p>GaussianBlur(img, img, Size(7,7), 1.5, 1.5);</p>


<p></code></p>
<ul>
    <li> Quickly initialize small matrices and/or get a super-fast element
        access.
</ul>

<p><code></p>

<p>// C++ code:</p>

<p>double m[3][3] = {{a, b, c}, {d, e, f}, {g, h, i}};</p>

<p>Mat M = Mat(3, 3, CV_64F, m).inv();</p>

<p></code></p>

<p>Partial yet very common cases of this *user-allocated data* case are
    conversions from <code>CvMat</code> and <code>IplImage</code> to
    <code>Mat</code>. For this purpose, there are special constructors taking
    pointers to <code>CvMat</code> or <code>IplImage</code> and the optional flag
    indicating whether to copy the data or not.</p>

<p>Backward conversion from <code>Mat</code> to <code>CvMat</code> or
    <code>IplImage</code> is provided via cast operators <code>Mat.operator
        CvMat() const</code> and <code>Mat.operator IplImage()</code>. The operators
    do NOT copy the data.</p>

<p><code></p>

<p>// C++ code:</p>

<p>IplImage* img = cvLoadImage("greatwave.jpg", 1);</p>

<p>Mat mtx(img); // convert IplImage* -> Mat</p>

<p>CvMat oldmat = mtx; // convert Mat -> CvMat</p>

<p>CV_Assert(oldmat.cols == img->width && oldmat.rows == img->height &&</p>

<p>oldmat.data.ptr == (uchar*)img->imageData && oldmat.step == img->widthStep);</p>

<p></code></p>
<ul>
    <li> Use MATLAB-style array initializers, <code>zeros(), ones(),
        eye()</code>, for example:
</ul>

<p><code></p>

<p>// C++ code:</p>

<p>// create a double-precision identity martix and add it to M.</p>

<p>M += Mat.eye(M.rows, M.cols, CV_64F);</p>

<p></code></p>
<ul>
    <li> Use a comma-separated initializer:
</ul>

<p><code></p>

<p>// C++ code:</p>

<p>// create a 3x3 double-precision identity matrix</p>

<p>Mat M = (Mat_
    <double>(3,3) << 1, 0, 0, 0, 1, 0, 0, 0, 1);
</p>

<p></code></p>

<p>With this approach, you first call a constructor of the "Mat_" class with the
    proper parameters, and then you just put <code><<</code> operator followed by
    comma-separated values that can be constants, variables, expressions, and so
    on. Also, note the extra parentheses required to avoid compilation errors.</p>

<p>Once the array is created, it is automatically managed via a
    reference-counting mechanism. If the array header is built on top of
    user-allocated data, you should handle the data by yourself.
    The array data is deallocated when no one points to it. If you want to
    release the data pointed by a array header before the array destructor is
    called, use <code>Mat.release()</code>.</p>

<p>The next important thing to learn about the array class is element access.
    This manual already described how to compute an address of each array
    element. Normally, you are not required to use the formula directly in the
    code. If you know the array element type (which can be retrieved using the
    method <code>Mat.type()</code>), you can access the element<em>M_(ij)</em>
    of a 2-dimensional array as: <code></p>

<p>// C++ code:</p>

<p>M.at
    <double>(i,j) += 1.f;
</p>

<p>assuming that M is a double-precision floating-point array. There are several
    variants of the method <code>at</code> for a different number of dimensions.
    </code></p>

<p>If you need to process a whole row of a 2D array, the most efficient way is
    to get the pointer to the row first, and then just use the plain C operator
    <code>[]</code> : <code></p>

<p>// C++ code:</p>

<p>// compute sum of positive matrix elements</p>

<p>// (assuming that M isa double-precision matrix)</p>

<p>double sum=0;</p>

<p>for(int i = 0; i < M.rows; i++)</p>


<p>const double* Mi = M.ptr
    <double>(i);
</p>

<p>for(int j = 0; j < M.cols; j++)</p>

<p>sum += std.max(Mi[j], 0.);</p>


<p>Some operations, like the one above, do not actually depend on the array
    shape. They just process elements of an array one by one (or elements from
    multiple arrays that have the same coordinates, for example, array addition).
    Such operations are called *element-wise*. It makes sense to check whether
    all the input/output arrays are continuous, namely, have no gaps at the end
    of each row. If yes, process them as a long single row:</p>

<p>// compute the sum of positive matrix elements, optimized variant</p>

<p>double sum=0;</p>

<p>int cols = M.cols, rows = M.rows;</p>

<p>if(M.isContinuous())</p>


<p>cols *= rows;</p>

<p>rows = 1;</p>


<p>for(int i = 0; i < rows; i++)</p>


<p>const double* Mi = M.ptr
    <double>(i);
</p>

<p>for(int j = 0; j < cols; j++)</p>

<p>sum += std.max(Mi[j], 0.);</p>


<p>In case of the continuous matrix, the outer loop body is executed just once.
    So, the overhead is smaller, which is especially noticeable in case of small
    matrices.
    </code></p>

<p>Finally, there are STL-style iterators that are smart enough to skip gaps
    between successive rows: <code></p>

<p>// C++ code:</p>

<p>// compute sum of positive matrix elements, iterator-based variant</p>

<p>double sum=0;</p>

<p>MatConstIterator_
    <double> it = M.begin
        <double>(), it_end = M.end
            <double>();
</p>

<p>for(; it != it_end; ++it)</p>

<p>sum += std.max(*it, 0.);</p>

<p>The matrix iterators are random-access iterators, so they can be passed to
    any STL algorithm, including <code>std.sort()</code>.
    </code></p>

<p>Note:</p>
<ul>
    <li> An example demonstrating the serial out capabilities of cv.Mat can be
        found at opencv_source_code/samples/cpp/cout_mat.cpp
</ul>
</div>
<dl>
    <dt><span class="strong">See Also:</span></dt>
    <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat">org.opencv.core.Mat</a>
    </dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
    <li class="blockList"><a name="field_summary">
        <!--   -->
    </a>

        <h3>Field Summary</h3>
        <table class="overviewSummary" border="0" cellpadding="3" cellspacing="0"
               summary="Field Summary table, listing fields, and an explanation">
            <caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
            <tr>
                <th class="colFirst" scope="col">Modifier and Type</th>
                <th class="colLast" scope="col">Field and Description</th>
            </tr>
            <tr class="altColor">
                <td class="colFirst"><code>long</code></td>
                <td class="colLast"><code><strong><a
                        href="../../../org/opencv/core/Mat.html#nativeObj">nativeObj</a></strong></code>&nbsp;
                </td>
            </tr>
        </table>
    </li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
    <li class="blockList"><a name="constructor_summary">
        <!--   -->
    </a>

        <h3>Constructor Summary</h3>
        <table class="overviewSummary" border="0" cellpadding="3" cellspacing="0"
               summary="Constructor Summary table, listing constructors, and an explanation">
            <caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
            <tr>
                <th class="colOne" scope="col">Constructor and Description</th>
            </tr>
            <tr class="altColor">
                <td class="colOne"><code><strong><a href="../../../org/opencv/core/Mat.html#Mat()">Mat</a></strong>()</code>

                    <div class="block">Various Mat constructors</div>
                </td>
            </tr>
            <tr class="rowColor">
                <td class="colOne"><code><strong><a
                        href="../../../org/opencv/core/Mat.html#Mat(int, int, int)">Mat</a></strong>(int&nbsp;rows,
                    int&nbsp;cols,
                    int&nbsp;type)</code>

                    <div class="block">Various Mat constructors</div>
                </td>
            </tr>
            <tr class="altColor">
                <td class="colOne"><code><strong><a
                        href="../../../org/opencv/core/Mat.html#Mat(int, int, int, org.opencv.core.Scalar)">Mat</a></strong>(int&nbsp;rows,
                    int&nbsp;cols,
                    int&nbsp;type,
                    <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;s)</code>

                    <div class="block">Various Mat constructors</div>
                </td>
            </tr>
            <tr class="rowColor">
                <td class="colOne"><code><strong><a
                        href="../../../org/opencv/core/Mat.html#Mat(long)">Mat</a></strong>(long&nbsp;addr)</code>&nbsp;
                </td>
            </tr>
            <tr class="altColor">
                <td class="colOne"><code><strong><a
                        href="../../../org/opencv/core/Mat.html#Mat(org.opencv.core.Mat, org.opencv.core.Range)">Mat</a></strong>(<a
                        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;m,
                    <a href="../../../org/opencv/core/Range.html" title="class in org.opencv.core">Range</a>&nbsp;rowRange)</code>

                    <div class="block">Various Mat constructors</div>
                </td>
            </tr>
            <tr class="rowColor">
                <td class="colOne"><code><strong><a
                        href="../../../org/opencv/core/Mat.html#Mat(org.opencv.core.Mat, org.opencv.core.Range, org.opencv.core.Range)">Mat</a></strong>(<a
                        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;m,
                    <a href="../../../org/opencv/core/Range.html" title="class in org.opencv.core">Range</a>&nbsp;rowRange,
                    <a href="../../../org/opencv/core/Range.html" title="class in org.opencv.core">Range</a>&nbsp;colRange)</code>

                    <div class="block">Various Mat constructors</div>
                </td>
            </tr>
            <tr class="altColor">
                <td class="colOne"><code><strong><a
                        href="../../../org/opencv/core/Mat.html#Mat(org.opencv.core.Mat, org.opencv.core.Rect)">Mat</a></strong>(<a
                        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;m,
                    <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;roi)</code>

                    <div class="block">Various Mat constructors</div>
                </td>
            </tr>
            <tr class="rowColor">
                <td class="colOne"><code><strong><a
                        href="../../../org/opencv/core/Mat.html#Mat(org.opencv.core.Size, int)">Mat</a></strong>(<a
                        href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;size,
                    int&nbsp;type)</code>

                    <div class="block">Various Mat constructors</div>
                </td>
            </tr>
            <tr class="altColor">
                <td class="colOne"><code><strong><a
                        href="../../../org/opencv/core/Mat.html#Mat(org.opencv.core.Size, int, org.opencv.core.Scalar)">Mat</a></strong>(<a
                        href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;size,
                    int&nbsp;type,
                    <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;s)</code>

                    <div class="block">Various Mat constructors</div>
                </td>
            </tr>
        </table>
    </li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
    <!--   -->
</a>

<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0"
       summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
    <th class="colFirst" scope="col">Modifier and Type</th>
    <th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
    <td class="colFirst"><code><a href="../../../org/opencv/core/Mat.html"
                                  title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#adjustROI(int, int, int, int)">adjustROI</a></strong>(int&nbsp;dtop,
        int&nbsp;dbottom,
        int&nbsp;dleft,
        int&nbsp;dright)</code>

        <div class="block">Adjusts a submatrix size and position within the parent matrix.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#assignTo(org.opencv.core.Mat)">assignTo</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;m)</code>

        <div class="block">Provides a functional form of <code>convertTo</code>.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#assignTo(org.opencv.core.Mat, int)">assignTo</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;m,
        int&nbsp;type)</code>

        <div class="block">Provides a functional form of <code>convertTo</code>.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Mat.html#channels()">channels</a></strong>()</code>

        <div class="block">Returns the number of matrix channels.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Mat.html#checkVector(int)">checkVector</a></strong>(int&nbsp;elemChannels)</code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#checkVector(int, int)">checkVector</a></strong>(int&nbsp;elemChannels,
        int&nbsp;depth)</code>&nbsp;</td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#checkVector(int, int, boolean)">checkVector</a></strong>(int&nbsp;elemChannels,
        int&nbsp;depth,
        boolean&nbsp;requireContinuous)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code><a href="../../../org/opencv/core/Mat.html"
                                  title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Mat.html#clone()">clone</a></strong>()</code>

        <div class="block">Creates a full copy of the array and the underlying data.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code><a href="../../../org/opencv/core/Mat.html"
                                  title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#col(int)">col</a></strong>(int&nbsp;x)</code>

        <div class="block">Creates a matrix header for the specified matrix column.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code><a href="../../../org/opencv/core/Mat.html"
                                  title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#colRange(int, int)">colRange</a></strong>(int&nbsp;startcol,
        int&nbsp;endcol)</code>

        <div class="block">Creates a matrix header for the specified column span.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code><a href="../../../org/opencv/core/Mat.html"
                                  title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#colRange(org.opencv.core.Range)">colRange</a></strong>(<a
            href="../../../org/opencv/core/Range.html" title="class in org.opencv.core">Range</a>&nbsp;r)</code>

        <div class="block">Creates a matrix header for the specified column span.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#cols()">cols</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#convertTo(org.opencv.core.Mat, int)">convertTo</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;m,
        int&nbsp;rtype)</code>

        <div class="block">Converts an array to another data type with optional scaling.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#convertTo(org.opencv.core.Mat, int, double)">convertTo</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;m,
        int&nbsp;rtype,
        double&nbsp;alpha)</code>

        <div class="block">Converts an array to another data type with optional scaling.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#convertTo(org.opencv.core.Mat, int, double, double)">convertTo</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;m,
        int&nbsp;rtype,
        double&nbsp;alpha,
        double&nbsp;beta)</code>

        <div class="block">Converts an array to another data type with optional scaling.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#copyTo(org.opencv.core.Mat)">copyTo</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;m)</code>

        <div class="block">Copies the matrix to another one.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#copyTo(org.opencv.core.Mat, org.opencv.core.Mat)">copyTo</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;m,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>

        <div class="block">Copies the matrix to another one.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#create(int, int, int)">create</a></strong>(int&nbsp;rows,
        int&nbsp;cols,
        int&nbsp;type)</code>

        <div class="block">Allocates new array data if needed.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#create(org.opencv.core.Size, int)">create</a></strong>(<a
            href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;size,
        int&nbsp;type)</code>

        <div class="block">Allocates new array data if needed.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code><a href="../../../org/opencv/core/Mat.html"
                                  title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#cross(org.opencv.core.Mat)">cross</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;m)</code>

        <div class="block">Computes a cross-product of two 3-element vectors.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>long</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Mat.html#dataAddr()">dataAddr</a></strong>()</code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Mat.html#depth()">depth</a></strong>()</code>

        <div class="block">Returns the depth of a matrix element.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code><a href="../../../org/opencv/core/Mat.html"
                                  title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#diag()">diag</a></strong>()</code>

        <div class="block">Extracts a diagonal from a matrix, or creates a diagonal matrix.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code><a href="../../../org/opencv/core/Mat.html"
                                  title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Mat.html#diag(int)">diag</a></strong>(int&nbsp;d)</code>

        <div class="block">Extracts a diagonal from a matrix, or creates a diagonal matrix.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#diag(org.opencv.core.Mat)">diag</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;d)</code>

        <div class="block">Extracts a diagonal from a matrix, or creates a diagonal matrix.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#dims()">dims</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>double</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#dot(org.opencv.core.Mat)">dot</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;m)</code>

        <div class="block">Computes a dot-product of two vectors.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>java.lang.String</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#dump()">dump</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>long</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Mat.html#elemSize()">elemSize</a></strong>()</code>

        <div class="block">Returns the matrix element size in bytes.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>long</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Mat.html#elemSize1()">elemSize1</a></strong>()</code>

        <div class="block">Returns the size of each matrix element channel in bytes.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>boolean</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Mat.html#empty()">empty</a></strong>()</code>

        <div class="block">Returns <code>true</code> if the array has no elements.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#eye(int, int, int)">eye</a></strong>(int&nbsp;rows,
        int&nbsp;cols,
        int&nbsp;type)</code>

        <div class="block">Returns an identity matrix of the specified size and type.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#eye(org.opencv.core.Size, int)">eye</a></strong>(<a
            href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;size,
        int&nbsp;type)</code>

        <div class="block">Returns an identity matrix of the specified size and type.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>double[]</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#get(int, int)">get</a></strong>(int&nbsp;row,
        int&nbsp;col)</code>&nbsp;</td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#get(int, int, byte[])">get</a></strong>(int&nbsp;row,
        int&nbsp;col,
        byte[]&nbsp;data)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#get(int, int, double[])">get</a></strong>(int&nbsp;row,
        int&nbsp;col,
        double[]&nbsp;data)</code>&nbsp;</td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#get(int, int, float[])">get</a></strong>(int&nbsp;row,
        int&nbsp;col,
        float[]&nbsp;data)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#get(int, int, int[])">get</a></strong>(int&nbsp;row,
        int&nbsp;col,
        int[]&nbsp;data)</code>&nbsp;</td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#get(int, int, short[])">get</a></strong>(int&nbsp;row,
        int&nbsp;col,
        short[]&nbsp;data)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>long</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#getNativeObjAddr()">getNativeObjAddr</a></strong>()</code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#height()">height</a></strong>()</code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code><a href="../../../org/opencv/core/Mat.html"
                                  title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#inv()">inv</a></strong>()</code>

        <div class="block">Inverses a matrix.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code><a href="../../../org/opencv/core/Mat.html"
                                  title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#inv(int)">inv</a></strong>(int&nbsp;method)</code>

        <div class="block">Inverses a matrix.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>boolean</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Mat.html#isContinuous()">isContinuous</a></strong>()</code>

        <div class="block">Reports whether the matrix is continuous or not.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>boolean</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Mat.html#isSubmatrix()">isSubmatrix</a></strong>()</code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#locateROI(org.opencv.core.Size, org.opencv.core.Point)">locateROI</a></strong>(<a
            href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;wholeSize,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;ofs)</code>

        <div class="block">Locates the matrix header within a parent matrix.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code><a href="../../../org/opencv/core/Mat.html"
                                  title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#mul(org.opencv.core.Mat)">mul</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;m)</code>

        <div class="block">Performs an element-wise multiplication or division of the two
            matrices.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code><a href="../../../org/opencv/core/Mat.html"
                                  title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#mul(org.opencv.core.Mat, double)">mul</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;m,
        double&nbsp;scale)</code>

        <div class="block">Performs an element-wise multiplication or division of the two
            matrices.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#ones(int, int, int)">ones</a></strong>(int&nbsp;rows,
        int&nbsp;cols,
        int&nbsp;type)</code>

        <div class="block">Returns an array of all 1's of the specified size and type.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#ones(org.opencv.core.Size, int)">ones</a></strong>(<a
            href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;size,
        int&nbsp;type)</code>

        <div class="block">Returns an array of all 1's of the specified size and type.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#push_back(org.opencv.core.Mat)">push_back</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;m)</code>

        <div class="block">Adds elements to the bottom of the matrix.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#put(int, int, byte[])">put</a></strong>(int&nbsp;row,
        int&nbsp;col,
        byte[]&nbsp;data)</code>&nbsp;</td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#put(int, int, double...)">put</a></strong>(int&nbsp;row,
        int&nbsp;col,
        double...&nbsp;data)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#put(int, int, float[])">put</a></strong>(int&nbsp;row,
        int&nbsp;col,
        float[]&nbsp;data)</code>&nbsp;</td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#put(int, int, int[])">put</a></strong>(int&nbsp;row,
        int&nbsp;col,
        int[]&nbsp;data)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#put(int, int, short[])">put</a></strong>(int&nbsp;row,
        int&nbsp;col,
        short[]&nbsp;data)</code>&nbsp;</td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#release()">release</a></strong>()</code>

        <div class="block">Decrements the reference counter and deallocates the matrix if needed.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code><a href="../../../org/opencv/core/Mat.html"
                                  title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Mat.html#reshape(int)">reshape</a></strong>(int&nbsp;cn)</code>

        <div class="block">Changes the shape and/or the number of channels of a 2D matrix without
            copying the data.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code><a href="../../../org/opencv/core/Mat.html"
                                  title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Mat.html#reshape(int, int)">reshape</a></strong>(int&nbsp;cn,
        int&nbsp;rows)</code>

        <div class="block">Changes the shape and/or the number of channels of a 2D matrix without
            copying the data.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code><a href="../../../org/opencv/core/Mat.html"
                                  title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#row(int)">row</a></strong>(int&nbsp;y)</code>

        <div class="block">Creates a matrix header for the specified matrix row.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code><a href="../../../org/opencv/core/Mat.html"
                                  title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#rowRange(int, int)">rowRange</a></strong>(int&nbsp;startrow,
        int&nbsp;endrow)</code>

        <div class="block">Creates a matrix header for the specified row span.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code><a href="../../../org/opencv/core/Mat.html"
                                  title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#rowRange(org.opencv.core.Range)">rowRange</a></strong>(<a
            href="../../../org/opencv/core/Range.html" title="class in org.opencv.core">Range</a>&nbsp;r)</code>

        <div class="block">Creates a matrix header for the specified row span.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#rows()">rows</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code><a href="../../../org/opencv/core/Mat.html"
                                  title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#setTo(org.opencv.core.Mat)">setTo</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;value)</code>

        <div class="block">Sets all or some of the array elements to the specified value.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code><a href="../../../org/opencv/core/Mat.html"
                                  title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#setTo(org.opencv.core.Mat, org.opencv.core.Mat)">setTo</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;value,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>

        <div class="block">Sets all or some of the array elements to the specified value.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code><a href="../../../org/opencv/core/Mat.html"
                                  title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#setTo(org.opencv.core.Scalar)">setTo</a></strong>(<a
            href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;s)</code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code><a href="../../../org/opencv/core/Mat.html"
                                  title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#setTo(org.opencv.core.Scalar, org.opencv.core.Mat)">setTo</a></strong>(<a
            href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;value,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>

        <div class="block">Sets all or some of the array elements to the specified value.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code><a href="../../../org/opencv/core/Size.html"
                                  title="class in org.opencv.core">Size</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#size()">size</a></strong>()</code>

        <div class="block">Returns a matrix size.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>long</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Mat.html#step1()">step1</a></strong>()</code>

        <div class="block">Returns a normalized step.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>long</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#step1(int)">step1</a></strong>(int&nbsp;i)</code>

        <div class="block">Returns a normalized step.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code><a href="../../../org/opencv/core/Mat.html"
                                  title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#submat(int, int, int, int)">submat</a></strong>(int&nbsp;rowStart,
        int&nbsp;rowEnd,
        int&nbsp;colStart,
        int&nbsp;colEnd)</code>

        <div class="block">Extracts a rectangular submatrix.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code><a href="../../../org/opencv/core/Mat.html"
                                  title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#submat(org.opencv.core.Range, org.opencv.core.Range)">submat</a></strong>(<a
            href="../../../org/opencv/core/Range.html" title="class in org.opencv.core">Range</a>&nbsp;rowRange,
        <a href="../../../org/opencv/core/Range.html" title="class in org.opencv.core">Range</a>&nbsp;colRange)</code>

        <div class="block">Extracts a rectangular submatrix.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code><a href="../../../org/opencv/core/Mat.html"
                                  title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#submat(org.opencv.core.Rect)">submat</a></strong>(<a
            href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;roi)</code>

        <div class="block">Extracts a rectangular submatrix.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code><a href="../../../org/opencv/core/Mat.html"
                                  title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Mat.html#t()">t</a></strong>()</code>

        <div class="block">Transposes a matrix.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>java.lang.String</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Mat.html#toString()">toString</a></strong>()</code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>long</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Mat.html#total()">total</a></strong>()</code>

        <div class="block">Returns the total number of array elements.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#type()">type</a></strong>()</code>

        <div class="block">Returns the type of a matrix element.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/core/Mat.html#width()">width</a></strong>()</code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#zeros(int, int, int)">zeros</a></strong>(int&nbsp;rows,
        int&nbsp;cols,
        int&nbsp;type)</code>

        <div class="block">Returns a zero array of the specified size and type.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/core/Mat.html#zeros(org.opencv.core.Size, int)">zeros</a></strong>(<a
            href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;size,
        int&nbsp;type)</code>

        <div class="block">Returns a zero array of the specified size and type.</div>
    </td>
</tr>
</table>
<ul class="blockList">
    <li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
        <!--   -->
    </a>

        <h3>Methods inherited from class&nbsp;java.lang.Object</h3>
        <code>equals, getClass, hashCode, notify, notifyAll, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
    <li class="blockList"><a name="field_detail">
        <!--   -->
    </a>

        <h3>Field Detail</h3>
        <a name="nativeObj">
            <!--   -->
        </a>
        <ul class="blockListLast">
            <li class="blockList">
                <h4>nativeObj</h4>
                <pre>public final&nbsp;long nativeObj</pre>
            </li>
        </ul>
    </li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_detail">
    <!--   -->
</a>

<h3>Constructor Detail</h3>
<a name="Mat()">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>Mat</h4>
        <pre>public&nbsp;Mat()</pre>
        <div class="block"><p>Various Mat constructors</p>

            <p>These are various constructors that form a matrix. As noted in the
                "AutomaticAllocation", often the default constructor is enough, and the
                proper matrix will be allocated by an OpenCV function. The constructed matrix
                can further be assigned to another matrix or matrix expression or can be
                allocated with "Mat.create". In the former case, the old content is
                de-referenced.</p></div>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-mat">org.opencv.core.Mat.Mat</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="Mat(int, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>Mat</h4>
<pre>public&nbsp;Mat(int&nbsp;rows,
   int&nbsp;cols,
   int&nbsp;type)</pre>
        <div class="block"><p>Various Mat constructors</p>

            <p>These are various constructors that form a matrix. As noted in the
                "AutomaticAllocation", often the default constructor is enough, and the
                proper matrix will be allocated by an OpenCV function. The constructed matrix
                can further be assigned to another matrix or matrix expression or can be
                allocated with "Mat.create". In the former case, the old content is
                de-referenced.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>rows</code> - Number of rows in a 2D array.</dd>
            <dd><code>cols</code> - Number of columns in a 2D array.</dd>
            <dd><code>type</code> - Array type. Use <code>CV_8UC1,..., CV_64FC4</code> to create 1-4
                channel matrices, or <code>CV_8UC(n),..., CV_64FC(n)</code> to create
                multi-channel (up to <code>CV_CN_MAX</code> channels) matrices.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-mat">org.opencv.core.Mat.Mat</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="Mat(int, int, int, org.opencv.core.Scalar)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>Mat</h4>
<pre>public&nbsp;Mat(int&nbsp;rows,
   int&nbsp;cols,
   int&nbsp;type,
   <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;s)</pre>
        <div class="block"><p>Various Mat constructors</p>

            <p>These are various constructors that form a matrix. As noted in the
                "AutomaticAllocation", often the default constructor is enough, and the
                proper matrix will be allocated by an OpenCV function. The constructed matrix
                can further be assigned to another matrix or matrix expression or can be
                allocated with "Mat.create". In the former case, the old content is
                de-referenced.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>rows</code> - Number of rows in a 2D array.</dd>
            <dd><code>cols</code> - Number of columns in a 2D array.</dd>
            <dd><code>type</code> - Array type. Use <code>CV_8UC1,..., CV_64FC4</code> to create 1-4
                channel matrices, or <code>CV_8UC(n),..., CV_64FC(n)</code> to create
                multi-channel (up to <code>CV_CN_MAX</code> channels) matrices.
            </dd>
            <dd><code>s</code> - An optional value to initialize each matrix element with. To set
                all
                the matrix elements to the particular value after the construction, use the
                assignment operator <code>Mat.operator=(const Scalar& value)</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-mat">org.opencv.core.Mat.Mat</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="Mat(long)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>Mat</h4>
        <pre>public&nbsp;Mat(long&nbsp;addr)</pre>
    </li>
</ul>
<a name="Mat(org.opencv.core.Mat, org.opencv.core.Range)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>Mat</h4>
<pre>public&nbsp;Mat(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;m,
   <a href="../../../org/opencv/core/Range.html" title="class in org.opencv.core">Range</a>&nbsp;rowRange)</pre>
        <div class="block"><p>Various Mat constructors</p>

            <p>These are various constructors that form a matrix. As noted in the
                "AutomaticAllocation", often the default constructor is enough, and the
                proper matrix will be allocated by an OpenCV function. The constructed matrix
                can further be assigned to another matrix or matrix expression or can be
                allocated with "Mat.create". In the former case, the old content is
                de-referenced.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>m</code> - Array that (as a whole or partly) is assigned to the constructed
                matrix. No data is copied by these constructors. Instead, the header pointing
                to <code>m</code> data or its sub-array is constructed and associated with
                it. The reference counter, if any, is incremented. So, when you modify the
                matrix formed using such a constructor, you also modify the corresponding
                elements of <code>m</code>. If you want to have an independent copy of the
                sub-array, use <code>Mat.clone()</code>.
            </dd>
            <dd><code>rowRange</code> - Range of the <code>m</code> rows to take. As usual, the
                range
                start is inclusive and the range end is exclusive. Use <code>Range.all()</code>
                to take all the rows.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-mat">org.opencv.core.Mat.Mat</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="Mat(org.opencv.core.Mat, org.opencv.core.Range, org.opencv.core.Range)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>Mat</h4>
<pre>public&nbsp;Mat(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;m,
   <a href="../../../org/opencv/core/Range.html" title="class in org.opencv.core">Range</a>&nbsp;rowRange,
   <a href="../../../org/opencv/core/Range.html" title="class in org.opencv.core">Range</a>&nbsp;colRange)</pre>
        <div class="block"><p>Various Mat constructors</p>

            <p>These are various constructors that form a matrix. As noted in the
                "AutomaticAllocation", often the default constructor is enough, and the
                proper matrix will be allocated by an OpenCV function. The constructed matrix
                can further be assigned to another matrix or matrix expression or can be
                allocated with "Mat.create". In the former case, the old content is
                de-referenced.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>m</code> - Array that (as a whole or partly) is assigned to the constructed
                matrix. No data is copied by these constructors. Instead, the header pointing
                to <code>m</code> data or its sub-array is constructed and associated with
                it. The reference counter, if any, is incremented. So, when you modify the
                matrix formed using such a constructor, you also modify the corresponding
                elements of <code>m</code>. If you want to have an independent copy of the
                sub-array, use <code>Mat.clone()</code>.
            </dd>
            <dd><code>rowRange</code> - Range of the <code>m</code> rows to take. As usual, the
                range
                start is inclusive and the range end is exclusive. Use <code>Range.all()</code>
                to take all the rows.
            </dd>
            <dd><code>colRange</code> - Range of the <code>m</code> columns to take. Use
                <code>Range.all()</code> to take all the columns.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-mat">org.opencv.core.Mat.Mat</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="Mat(org.opencv.core.Mat, org.opencv.core.Rect)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>Mat</h4>
<pre>public&nbsp;Mat(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;m,
   <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;roi)</pre>
        <div class="block"><p>Various Mat constructors</p>

            <p>These are various constructors that form a matrix. As noted in the
                "AutomaticAllocation", often the default constructor is enough, and the
                proper matrix will be allocated by an OpenCV function. The constructed matrix
                can further be assigned to another matrix or matrix expression or can be
                allocated with "Mat.create". In the former case, the old content is
                de-referenced.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>m</code> - Array that (as a whole or partly) is assigned to the constructed
                matrix. No data is copied by these constructors. Instead, the header pointing
                to <code>m</code> data or its sub-array is constructed and associated with
                it. The reference counter, if any, is incremented. So, when you modify the
                matrix formed using such a constructor, you also modify the corresponding
                elements of <code>m</code>. If you want to have an independent copy of the
                sub-array, use <code>Mat.clone()</code>.
            </dd>
            <dd><code>roi</code> - Region of interest.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-mat">org.opencv.core.Mat.Mat</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="Mat(org.opencv.core.Size, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>Mat</h4>
<pre>public&nbsp;Mat(<a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;size,
   int&nbsp;type)</pre>
        <div class="block"><p>Various Mat constructors</p>

            <p>These are various constructors that form a matrix. As noted in the
                "AutomaticAllocation", often the default constructor is enough, and the
                proper matrix will be allocated by an OpenCV function. The constructed matrix
                can further be assigned to another matrix or matrix expression or can be
                allocated with "Mat.create". In the former case, the old content is
                de-referenced.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>size</code> - 2D array size: <code>Size(cols, rows)</code>. In the
                <code>Size()</code> constructor, the number of rows and the number of columns
                go in the reverse order.
            </dd>
            <dd><code>type</code> - Array type. Use <code>CV_8UC1,..., CV_64FC4</code> to create 1-4
                channel matrices, or <code>CV_8UC(n),..., CV_64FC(n)</code> to create
                multi-channel (up to <code>CV_CN_MAX</code> channels) matrices.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-mat">org.opencv.core.Mat.Mat</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="Mat(org.opencv.core.Size, int, org.opencv.core.Scalar)">
    <!--   -->
</a>
<ul class="blockListLast">
    <li class="blockList">
        <h4>Mat</h4>
<pre>public&nbsp;Mat(<a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;size,
   int&nbsp;type,
   <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;s)</pre>
        <div class="block"><p>Various Mat constructors</p>

            <p>These are various constructors that form a matrix. As noted in the
                "AutomaticAllocation", often the default constructor is enough, and the
                proper matrix will be allocated by an OpenCV function. The constructed matrix
                can further be assigned to another matrix or matrix expression or can be
                allocated with "Mat.create". In the former case, the old content is
                de-referenced.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>size</code> - 2D array size: <code>Size(cols, rows)</code>. In the
                <code>Size()</code> constructor, the number of rows and the number of columns
                go in the reverse order.
            </dd>
            <dd><code>type</code> - Array type. Use <code>CV_8UC1,..., CV_64FC4</code> to create 1-4
                channel matrices, or <code>CV_8UC(n),..., CV_64FC(n)</code> to create
                multi-channel (up to <code>CV_CN_MAX</code> channels) matrices.
            </dd>
            <dd><code>s</code> - An optional value to initialize each matrix element with. To set
                all
                the matrix elements to the particular value after the construction, use the
                assignment operator <code>Mat.operator=(const Scalar& value)</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-mat">org.opencv.core.Mat.Mat</a>
            </dd>
        </dl>
    </li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
    <!--   -->
</a>

<h3>Method Detail</h3>
<a name="adjustROI(int, int, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>adjustROI</h4>
<pre>public&nbsp;<a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;adjustROI(int&nbsp;dtop,
            int&nbsp;dbottom,
            int&nbsp;dleft,
            int&nbsp;dright)</pre>
        <div class="block"><p>Adjusts a submatrix size and position within the parent matrix.</p>

            <p>The method is complimentary to"Mat.locateROI". The typical use of these
                functions is to determine the submatrix position within the parent matrix and
                then shift the position somehow. Typically, it can be required for filtering
                operations when pixels outside of the ROI should be taken into account. When
                all the method parameters are positive, the ROI needs to grow in all
                directions by the specified amount, for example: <code></p>

            <p>// C++ code:</p>

            <p>A.adjustROI(2, 2, 2, 2);</p>

            <p>In this example, the matrix size is increased by 4 elements in each
                direction. The matrix is shifted by 2 elements to the left and 2 elements up,
                which brings in all the necessary pixels for the filtering with the 5x5
                kernel.
                </code></p>

            <p><code>adjustROI</code> forces the adjusted ROI to be inside of the parent
                matrix that is boundaries of the adjusted ROI are constrained by boundaries
                of the parent matrix. For example, if the submatrix <code>A</code> is located
                in the first row of a parent matrix and you called <code>A.adjustROI(2, 2, 2,
                    2)</code> then <code>A</code> will not be increased in the upward direction.</p>

            <p>The function is used internally by the OpenCV filtering functions, like
                "filter2D", morphological operations, and so on.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>dtop</code> - Shift of the top submatrix boundary upwards.</dd>
            <dd><code>dbottom</code> - Shift of the bottom submatrix boundary downwards.</dd>
            <dd><code>dleft</code> - Shift of the left submatrix boundary to the left.</dd>
            <dd><code>dright</code> - Shift of the right submatrix boundary to the right.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-adjustroi">org.opencv.core.Mat.adjustROI</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#copyMakeBorder(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, int, int, org.opencv.core.Scalar)"><code>Imgproc.copyMakeBorder(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int, int, int, int, org.opencv.core.Scalar)</code></a>
            </dd>
        </dl>
    </li>
</ul>
<a name="assignTo(org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>assignTo</h4>
        <pre>public&nbsp;void&nbsp;assignTo(<a href="../../../org/opencv/core/Mat.html"
                                               title="class in org.opencv.core">Mat</a>&nbsp;m)</pre>
        <div class="block"><p>Provides a functional form of <code>convertTo</code>.</p>

            <p>This is an internally used method called by the "MatrixExpressions" engine.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>m</code> - Destination array.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-assignto">org.opencv.core.Mat.assignTo</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="assignTo(org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>assignTo</h4>
<pre>public&nbsp;void&nbsp;assignTo(<a href="../../../org/opencv/core/Mat.html"
                                       title="class in org.opencv.core">Mat</a>&nbsp;m,
            int&nbsp;type)</pre>
        <div class="block"><p>Provides a functional form of <code>convertTo</code>.</p>

            <p>This is an internally used method called by the "MatrixExpressions" engine.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>m</code> - Destination array.</dd>
            <dd><code>type</code> - Desired destination array depth (or -1 if it should be the same
                as the source type).
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-assignto">org.opencv.core.Mat.assignTo</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="channels()">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>channels</h4>
        <pre>public&nbsp;int&nbsp;channels()</pre>
        <div class="block"><p>Returns the number of matrix channels.</p>

            <p>The method returns the number of matrix channels.</p></div>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-channels">org.opencv.core.Mat.channels</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="checkVector(int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>checkVector</h4>
        <pre>public&nbsp;int&nbsp;checkVector(int&nbsp;elemChannels)</pre>
    </li>
</ul>
<a name="checkVector(int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>checkVector</h4>
<pre>public&nbsp;int&nbsp;checkVector(int&nbsp;elemChannels,
              int&nbsp;depth)</pre>
    </li>
</ul>
<a name="checkVector(int, int, boolean)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>checkVector</h4>
<pre>public&nbsp;int&nbsp;checkVector(int&nbsp;elemChannels,
              int&nbsp;depth,
              boolean&nbsp;requireContinuous)</pre>
    </li>
</ul>
<a name="clone()">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>clone</h4>
        <pre>public&nbsp;<a href="../../../org/opencv/core/Mat.html"
                            title="class in org.opencv.core">Mat</a>&nbsp;clone()</pre>
        <div class="block"><p>Creates a full copy of the array and the underlying data.</p>

            <p>The method creates a full copy of the array. The original <code>step[]</code>
                is not taken into account. So, the array copy is a continuous array occupying
                <code>total()*elemSize()</code> bytes.</p></div>
        <dl>
            <dt><strong>Overrides:</strong></dt>
            <dd><code>clone</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-clone">org.opencv.core.Mat.clone</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="col(int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>col</h4>
        <pre>public&nbsp;<a href="../../../org/opencv/core/Mat.html"
                            title="class in org.opencv.core">Mat</a>&nbsp;col(int&nbsp;x)</pre>
        <div class="block"><p>Creates a matrix header for the specified matrix column.</p>

            <p>The method makes a new header for the specified matrix column and returns it.
                This is an O(1) operation, regardless of the matrix size. The underlying data
                of the new matrix is shared with the original matrix. See also the "Mat.row"
                description.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>x</code> - A 0-based column index.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-col">org.opencv.core.Mat.col</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="colRange(int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>colRange</h4>
<pre>public&nbsp;<a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;colRange(int&nbsp;startcol,
           int&nbsp;endcol)</pre>
        <div class="block"><p>Creates a matrix header for the specified column span.</p>

            <p>The method makes a new header for the specified column span of the matrix.
                Similarly to "Mat.row" and "Mat.col", this is an O(1) operation.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>startcol</code> - An inclusive 0-based start index of the column span.</dd>
            <dd><code>endcol</code> - An exclusive 0-based ending index of the column span.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-colrange">org.opencv.core.Mat.colRange</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="colRange(org.opencv.core.Range)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>colRange</h4>
        <pre>public&nbsp;<a href="../../../org/opencv/core/Mat.html"
                            title="class in org.opencv.core">Mat</a>&nbsp;colRange(<a
                href="../../../org/opencv/core/Range.html"
                title="class in org.opencv.core">Range</a>&nbsp;r)</pre>
        <div class="block"><p>Creates a matrix header for the specified column span.</p>

            <p>The method makes a new header for the specified column span of the matrix.
                Similarly to "Mat.row" and "Mat.col", this is an O(1) operation.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>r</code> - "Range" structure containing both the start and the end indices.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-colrange">org.opencv.core.Mat.colRange</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="cols()">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>cols</h4>
        <pre>public&nbsp;int&nbsp;cols()</pre>
    </li>
</ul>
<a name="convertTo(org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>convertTo</h4>
<pre>public&nbsp;void&nbsp;convertTo(<a href="../../../org/opencv/core/Mat.html"
                                        title="class in org.opencv.core">Mat</a>&nbsp;m,
             int&nbsp;rtype)</pre>
        <div class="block"><p>Converts an array to another data type with optional scaling.</p>

            <p>The method converts source pixel values to the target data type.
                <code>saturate_cast<></code> is applied at the end to avoid possible
                overflows:</p>

            <p><em>m(x,y) = saturate _ cast&ltrType&gt(alpha(*this)(x,y) + beta)</em></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>m</code> - output matrix; if it does not have a proper size or type before the
                operation, it is reallocated.
            </dd>
            <dd><code>rtype</code> - desired output matrix type or, rather, the depth since the
                number of channels are the same as the input has; if <code>rtype</code> is
                negative, the output matrix will have the same type as the input.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-convertto">org.opencv.core.Mat.convertTo</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="convertTo(org.opencv.core.Mat, int, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>convertTo</h4>
<pre>public&nbsp;void&nbsp;convertTo(<a href="../../../org/opencv/core/Mat.html"
                                        title="class in org.opencv.core">Mat</a>&nbsp;m,
             int&nbsp;rtype,
             double&nbsp;alpha)</pre>
        <div class="block"><p>Converts an array to another data type with optional scaling.</p>

            <p>The method converts source pixel values to the target data type.
                <code>saturate_cast<></code> is applied at the end to avoid possible
                overflows:</p>

            <p><em>m(x,y) = saturate _ cast&ltrType&gt(alpha(*this)(x,y) + beta)</em></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>m</code> - output matrix; if it does not have a proper size or type before the
                operation, it is reallocated.
            </dd>
            <dd><code>rtype</code> - desired output matrix type or, rather, the depth since the
                number of channels are the same as the input has; if <code>rtype</code> is
                negative, the output matrix will have the same type as the input.
            </dd>
            <dd><code>alpha</code> - optional scale factor.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-convertto">org.opencv.core.Mat.convertTo</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="convertTo(org.opencv.core.Mat, int, double, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>convertTo</h4>
<pre>public&nbsp;void&nbsp;convertTo(<a href="../../../org/opencv/core/Mat.html"
                                        title="class in org.opencv.core">Mat</a>&nbsp;m,
             int&nbsp;rtype,
             double&nbsp;alpha,
             double&nbsp;beta)</pre>
        <div class="block"><p>Converts an array to another data type with optional scaling.</p>

            <p>The method converts source pixel values to the target data type.
                <code>saturate_cast<></code> is applied at the end to avoid possible
                overflows:</p>

            <p><em>m(x,y) = saturate _ cast&ltrType&gt(alpha(*this)(x,y) + beta)</em></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>m</code> - output matrix; if it does not have a proper size or type before the
                operation, it is reallocated.
            </dd>
            <dd><code>rtype</code> - desired output matrix type or, rather, the depth since the
                number of channels are the same as the input has; if <code>rtype</code> is
                negative, the output matrix will have the same type as the input.
            </dd>
            <dd><code>alpha</code> - optional scale factor.</dd>
            <dd><code>beta</code> - optional delta added to the scaled values.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-convertto">org.opencv.core.Mat.convertTo</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="copyTo(org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>copyTo</h4>
        <pre>public&nbsp;void&nbsp;copyTo(<a href="../../../org/opencv/core/Mat.html"
                                             title="class in org.opencv.core">Mat</a>&nbsp;m)</pre>
        <div class="block"><p>Copies the matrix to another one.</p>

            <p>The method copies the matrix data to another matrix. Before copying the data,
                the method invokes <code></p>

            <p>// C++ code:</p>

            <p>m.create(this->size(), this->type());</p>

            <p>so that the destination matrix is reallocated if needed. While
                <code>m.copyTo(m);</code> works flawlessly, the function does not handle the
                case of a partial overlap between the source and the destination matrices.
                </code></p>

            <p>When the operation mask is specified, if the <code>Mat.create</code> call
                shown above reallocates the matrix, the newly allocated matrix is initialized
                with all zeros before copying the data.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>m</code> - Destination matrix. If it does not have a proper size or type
                before
                the operation, it is reallocated.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-copyto">org.opencv.core.Mat.copyTo</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="copyTo(org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>copyTo</h4>
<pre>public&nbsp;void&nbsp;copyTo(<a href="../../../org/opencv/core/Mat.html"
                                     title="class in org.opencv.core">Mat</a>&nbsp;m,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
        <div class="block"><p>Copies the matrix to another one.</p>

            <p>The method copies the matrix data to another matrix. Before copying the data,
                the method invokes <code></p>

            <p>// C++ code:</p>

            <p>m.create(this->size(), this->type());</p>

            <p>so that the destination matrix is reallocated if needed. While
                <code>m.copyTo(m);</code> works flawlessly, the function does not handle the
                case of a partial overlap between the source and the destination matrices.
                </code></p>

            <p>When the operation mask is specified, if the <code>Mat.create</code> call
                shown above reallocates the matrix, the newly allocated matrix is initialized
                with all zeros before copying the data.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>m</code> - Destination matrix. If it does not have a proper size or type
                before
                the operation, it is reallocated.
            </dd>
            <dd><code>mask</code> - Operation mask. Its non-zero elements indicate which matrix
                elements need to be copied.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-copyto">org.opencv.core.Mat.copyTo</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="create(int, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>create</h4>
<pre>public&nbsp;void&nbsp;create(int&nbsp;rows,
          int&nbsp;cols,
          int&nbsp;type)</pre>
        <div class="block"><p>Allocates new array data if needed.</p>

            <p>This is one of the key <code>Mat</code> methods. Most new-style OpenCV
                functions and methods that produce arrays call this method for each output
                array. The method uses the following algorithm:</p>
            <ul>
                <li> If the current array shape and the type match the new ones, return
                    immediately. Otherwise, de-reference the previous data by calling
                    "Mat.release".
                <li> Initialize the new header.
                <li> Allocate the new data of <code>total()*elemSize()</code> bytes.
                <li> Allocate the new, associated with the data, reference counter and set
                    it to 1.
            </ul>
            <p>Such a scheme makes the memory management robust and efficient at the same
                time and helps avoid extra typing for you. This means that usually there is
                no need to explicitly allocate output arrays. That is, instead of writing:
                <code></p>

            <p>// C++ code:</p>

            <p>Mat color;...</p>

            <p>Mat gray(color.rows, color.cols, color.depth());</p>

            <p>cvtColor(color, gray, CV_BGR2GRAY);</p>

            <p>you can simply write:</p>

            <p>Mat color;...</p>

            <p>Mat gray;</p>

            <p>cvtColor(color, gray, CV_BGR2GRAY);</p>

            <p>because <code>cvtColor</code>, as well as the most of OpenCV functions, calls
                <code>Mat.create()</code> for the output array internally.
                </code></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>rows</code> - New number of rows.</dd>
            <dd><code>cols</code> - New number of columns.</dd>
            <dd><code>type</code> - New matrix type.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-create">org.opencv.core.Mat.create</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="create(org.opencv.core.Size, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>create</h4>
<pre>public&nbsp;void&nbsp;create(<a href="../../../org/opencv/core/Size.html"
                                     title="class in org.opencv.core">Size</a>&nbsp;size,
          int&nbsp;type)</pre>
        <div class="block"><p>Allocates new array data if needed.</p>

            <p>This is one of the key <code>Mat</code> methods. Most new-style OpenCV
                functions and methods that produce arrays call this method for each output
                array. The method uses the following algorithm:</p>
            <ul>
                <li> If the current array shape and the type match the new ones, return
                    immediately. Otherwise, de-reference the previous data by calling
                    "Mat.release".
                <li> Initialize the new header.
                <li> Allocate the new data of <code>total()*elemSize()</code> bytes.
                <li> Allocate the new, associated with the data, reference counter and set
                    it to 1.
            </ul>
            <p>Such a scheme makes the memory management robust and efficient at the same
                time and helps avoid extra typing for you. This means that usually there is
                no need to explicitly allocate output arrays. That is, instead of writing:
                <code></p>

            <p>// C++ code:</p>

            <p>Mat color;...</p>

            <p>Mat gray(color.rows, color.cols, color.depth());</p>

            <p>cvtColor(color, gray, CV_BGR2GRAY);</p>

            <p>you can simply write:</p>

            <p>Mat color;...</p>

            <p>Mat gray;</p>

            <p>cvtColor(color, gray, CV_BGR2GRAY);</p>

            <p>because <code>cvtColor</code>, as well as the most of OpenCV functions, calls
                <code>Mat.create()</code> for the output array internally.
                </code></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>size</code> - Alternative new matrix size specification: <code>Size(cols,
                rows)</code></dd>
            <dd><code>type</code> - New matrix type.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-create">org.opencv.core.Mat.create</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="cross(org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>cross</h4>
        <pre>public&nbsp;<a href="../../../org/opencv/core/Mat.html"
                            title="class in org.opencv.core">Mat</a>&nbsp;cross(<a
                href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;m)</pre>
        <div class="block"><p>Computes a cross-product of two 3-element vectors.</p>

            <p>The method computes a cross-product of two 3-element vectors. The vectors
                must be 3-element floating-point vectors of the same shape and size. The
                result is another 3-element vector of the same shape and type as operands.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>m</code> - Another cross-product operand.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-cross">org.opencv.core.Mat.cross</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="dataAddr()">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>dataAddr</h4>
        <pre>public&nbsp;long&nbsp;dataAddr()</pre>
    </li>
</ul>
<a name="depth()">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>depth</h4>
        <pre>public&nbsp;int&nbsp;depth()</pre>
        <div class="block"><p>Returns the depth of a matrix element.</p>

            <p>The method returns the identifier of the matrix element depth (the type of
                each individual channel). For example, for a 16-bit signed element array, the
                method returns <code>CV_16S</code>. A complete list of matrix types contains
                the following values:</p>
            <ul>
                <li><code>CV_8U</code> - 8-bit unsigned integers (<code>0..255</code>)
                <li><code>CV_8S</code> - 8-bit signed integers (<code>-128..127</code>)
                <li><code>CV_16U</code> - 16-bit unsigned integers (<code>0..65535</code>)
                <li><code>CV_16S</code> - 16-bit signed integers (<code>-32768..32767</code>)
                <li><code>CV_32S</code> - 32-bit signed integers
                    (<code>-2147483648..2147483647</code>)
                <li><code>CV_32F</code> - 32-bit floating-point numbers (<code>-FLT_MAX..FLT_MAX,
                    INF, NAN</code>)
                <li><code>CV_64F</code> - 64-bit floating-point numbers (<code>-DBL_MAX..DBL_MAX,
                    INF, NAN</code>)
            </ul>
        </div>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-depth">org.opencv.core.Mat.depth</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="diag()">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>diag</h4>
        <pre>public&nbsp;<a href="../../../org/opencv/core/Mat.html"
                            title="class in org.opencv.core">Mat</a>&nbsp;diag()</pre>
        <div class="block"><p>Extracts a diagonal from a matrix, or creates a diagonal matrix.</p>

            <p>The method makes a new header for the specified matrix diagonal. The new
                matrix is represented as a single-column matrix. Similarly to "Mat.row" and
                "Mat.col", this is an O(1) operation.</p></div>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-diag">org.opencv.core.Mat.diag</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="diag(int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>diag</h4>
        <pre>public&nbsp;<a href="../../../org/opencv/core/Mat.html"
                            title="class in org.opencv.core">Mat</a>&nbsp;diag(int&nbsp;d)</pre>
        <div class="block"><p>Extracts a diagonal from a matrix, or creates a diagonal matrix.</p>

            <p>The method makes a new header for the specified matrix diagonal. The new
                matrix is represented as a single-column matrix. Similarly to "Mat.row" and
                "Mat.col", this is an O(1) operation.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>d</code> - Single-column matrix that forms a diagonal matrix or index of the
                diagonal, with the following values:
                <ul>
                    <li> d=0 is the main diagonal.
                    <li> d>0 is a diagonal from the lower half. For example, <code>d=1</code>
                        means the diagonal is set immediately below the main one.
                    <li> d<0 is a diagonal from the upper half. For example, <code>d=1</code>
                        means the diagonal is set immediately above the main one.
                </ul>
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-diag">org.opencv.core.Mat.diag</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="diag(org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>diag</h4>
        <pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html"
                                   title="class in org.opencv.core">Mat</a>&nbsp;diag(<a
                href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;d)</pre>
        <div class="block"><p>Extracts a diagonal from a matrix, or creates a diagonal matrix.</p>

            <p>The method makes a new header for the specified matrix diagonal. The new
                matrix is represented as a single-column matrix. Similarly to "Mat.row" and
                "Mat.col", this is an O(1) operation.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>d</code> - Single-column matrix that forms a diagonal matrix or index of the
                diagonal, with the following values:
                <ul>
                    <li> d=0 is the main diagonal.
                    <li> d>0 is a diagonal from the lower half. For example, <code>d=1</code>
                        means the diagonal is set immediately below the main one.
                    <li> d<0 is a diagonal from the upper half. For example, <code>d=1</code>
                        means the diagonal is set immediately above the main one.
                </ul>
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-diag">org.opencv.core.Mat.diag</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="dims()">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>dims</h4>
        <pre>public&nbsp;int&nbsp;dims()</pre>
    </li>
</ul>
<a name="dot(org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>dot</h4>
        <pre>public&nbsp;double&nbsp;dot(<a href="../../../org/opencv/core/Mat.html"
                                            title="class in org.opencv.core">Mat</a>&nbsp;m)</pre>
        <div class="block"><p>Computes a dot-product of two vectors.</p>

            <p>The method computes a dot-product of two matrices. If the matrices are not
                single-column or single-row vectors, the top-to-bottom left-to-right scan
                ordering is used to treat them as 1D vectors. The vectors must have the same
                size and type. If the matrices have more than one channel, the dot products
                from all the channels are summed together.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>m</code> - another dot-product operand.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-dot">org.opencv.core.Mat.dot</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="dump()">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>dump</h4>
        <pre>public&nbsp;java.lang.String&nbsp;dump()</pre>
    </li>
</ul>
<a name="elemSize()">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>elemSize</h4>
        <pre>public&nbsp;long&nbsp;elemSize()</pre>
        <div class="block"><p>Returns the matrix element size in bytes.</p>

            <p>The method returns the matrix element size in bytes. For example, if the
                matrix type is <code>CV_16SC3</code>, the method returns
                <code>3*sizeof(short)</code>
                or 6.</p></div>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-elemsize">org.opencv.core.Mat.elemSize</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="elemSize1()">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>elemSize1</h4>
        <pre>public&nbsp;long&nbsp;elemSize1()</pre>
        <div class="block"><p>Returns the size of each matrix element channel in bytes.</p>

            <p>The method returns the matrix element channel size in bytes, that is, it
                ignores the number of channels. For example, if the matrix type is
                <code>CV_16SC3</code>, the method returns <code>sizeof(short)</code> or 2.</p></div>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-elemsize1">org.opencv.core.Mat.elemSize1</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="empty()">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>empty</h4>
        <pre>public&nbsp;boolean&nbsp;empty()</pre>
        <div class="block"><p>Returns <code>true</code> if the array has no elements.</p>

            <p>The method returns <code>true</code> if <code>Mat.total()</code> is 0 or if
                <code>Mat.data</code> is NULL. Because of <code>pop_back()</code> and
                <code>resize()</code> methods <code>M.total() == 0</code> does not imply that
                <code>M.data == NULL</code>.</p></div>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-empty">org.opencv.core.Mat.empty</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="eye(int, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>eye</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html"
                           title="class in org.opencv.core">Mat</a>&nbsp;eye(int&nbsp;rows,
      int&nbsp;cols,
      int&nbsp;type)</pre>
        <div class="block"><p>Returns an identity matrix of the specified size and type.</p>

            <p>The method returns a Matlab-style identity matrix initializer, similarly to
                "Mat.zeros". Similarly to"Mat.ones", you can use a scale operation to
                create a scaled identity matrix efficiently: <code></p>

            <p>// C++ code:</p>

            <p>// make a 4x4 diagonal matrix with 0.1's on the diagonal.</p>

            <p>Mat A = Mat.eye(4, 4, CV_32F)*0.1;</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>rows</code> - Number of rows.</dd>
            <dd><code>cols</code> - Number of columns.</dd>
            <dd><code>type</code> - Created matrix type.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-eye">org.opencv.core.Mat.eye</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="eye(org.opencv.core.Size, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>eye</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html"
                           title="class in org.opencv.core">Mat</a>&nbsp;eye(<a
        href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;size,
      int&nbsp;type)</pre>
        <div class="block"><p>Returns an identity matrix of the specified size and type.</p>

            <p>The method returns a Matlab-style identity matrix initializer, similarly to
                "Mat.zeros". Similarly to"Mat.ones", you can use a scale operation to
                create a scaled identity matrix efficiently: <code></p>

            <p>// C++ code:</p>

            <p>// make a 4x4 diagonal matrix with 0.1's on the diagonal.</p>

            <p>Mat A = Mat.eye(4, 4, CV_32F)*0.1;</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>size</code> - Alternative matrix size specification as <code>Size(cols,
                rows)</code>.
            </dd>
            <dd><code>type</code> - Created matrix type.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-eye">org.opencv.core.Mat.eye</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="get(int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>get</h4>
<pre>public&nbsp;double[]&nbsp;get(int&nbsp;row,
           int&nbsp;col)</pre>
    </li>
</ul>
<a name="get(int, int, byte[])">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>get</h4>
<pre>public&nbsp;int&nbsp;get(int&nbsp;row,
      int&nbsp;col,
      byte[]&nbsp;data)</pre>
    </li>
</ul>
<a name="get(int, int, double[])">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>get</h4>
<pre>public&nbsp;int&nbsp;get(int&nbsp;row,
      int&nbsp;col,
      double[]&nbsp;data)</pre>
    </li>
</ul>
<a name="get(int, int, float[])">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>get</h4>
<pre>public&nbsp;int&nbsp;get(int&nbsp;row,
      int&nbsp;col,
      float[]&nbsp;data)</pre>
    </li>
</ul>
<a name="get(int, int, int[])">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>get</h4>
<pre>public&nbsp;int&nbsp;get(int&nbsp;row,
      int&nbsp;col,
      int[]&nbsp;data)</pre>
    </li>
</ul>
<a name="get(int, int, short[])">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>get</h4>
<pre>public&nbsp;int&nbsp;get(int&nbsp;row,
      int&nbsp;col,
      short[]&nbsp;data)</pre>
    </li>
</ul>
<a name="getNativeObjAddr()">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>getNativeObjAddr</h4>
        <pre>public&nbsp;long&nbsp;getNativeObjAddr()</pre>
    </li>
</ul>
<a name="height()">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>height</h4>
        <pre>public&nbsp;int&nbsp;height()</pre>
    </li>
</ul>
<a name="inv()">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>inv</h4>
        <pre>public&nbsp;<a href="../../../org/opencv/core/Mat.html"
                            title="class in org.opencv.core">Mat</a>&nbsp;inv()</pre>
        <div class="block"><p>Inverses a matrix.</p>

            <p>The method performs a matrix inversion by means of matrix expressions. This
                means that a temporary matrix inversion object is returned by the method and
                can be used further as a part of more complex matrix expressions or can be
                assigned to a matrix.</p></div>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-inv">org.opencv.core.Mat.inv</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="inv(int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>inv</h4>
        <pre>public&nbsp;<a href="../../../org/opencv/core/Mat.html"
                            title="class in org.opencv.core">Mat</a>&nbsp;inv(int&nbsp;method)</pre>
        <div class="block"><p>Inverses a matrix.</p>

            <p>The method performs a matrix inversion by means of matrix expressions. This
                means that a temporary matrix inversion object is returned by the method and
                can be used further as a part of more complex matrix expressions or can be
                assigned to a matrix.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>method</code> - Matrix inversion method. Possible values are the following:
                <ul>
                    <li> DECOMP_LU is the LU decomposition. The matrix must be non-singular.
                    <li> DECOMP_CHOLESKY is the Cholesky <em>LL^T</em> decomposition for
                        symmetrical positively defined matrices only. This type is about twice
                        faster
                        than LU on big matrices.
                    <li> DECOMP_SVD is the SVD decomposition. If the matrix is singular or even
                        non-square, the pseudo inversion is computed.
                </ul>
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-inv">org.opencv.core.Mat.inv</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="isContinuous()">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>isContinuous</h4>
        <pre>public&nbsp;boolean&nbsp;isContinuous()</pre>
        <div class="block"><p>Reports whether the matrix is continuous or not.</p>

            <p>The method returns <code>true</code> if the matrix elements are stored
                continuously without gaps at the end of each row. Otherwise, it returns
                <code>false</code>. Obviously, <code>1x1</code> or <code>1xN</code> matrices
                are always continuous. Matrices created with "Mat.create" are always
                continuous. But if you extract a part of the matrix using "Mat.col",
                "Mat.diag", and so on, or constructed a matrix header for externally
                allocated data, such matrices may no longer have this property.
                The continuity flag is stored as a bit in the <code>Mat.flags</code> field
                and is computed automatically when you construct a matrix header. Thus, the
                continuity check is a very fast operation, though theoretically it could be
                done as follows: <code></p>

            <p>// C++ code:</p>

            <p>// alternative implementation of Mat.isContinuous()</p>

            <p>bool myCheckMatContinuity(const Mat& m)</p>


            <p>//return (m.flags & Mat.CONTINUOUS_FLAG) != 0;</p>

            <p>return m.rows == 1 || m.step == m.cols*m.elemSize();</p>


            <p>The method is used in quite a few of OpenCV functions. The point is that
                element-wise operations (such as arithmetic and logical operations, math
                functions, alpha blending, color space transformations, and others) do not
                depend on the image geometry. Thus, if all the input and output arrays are
                continuous, the functions can process them as very long single-row vectors.
                The example below illustrates how an alpha-blending function can be
                implemented.</p>

            <p>template
                <typename T>
            </p>

            <p>void alphaBlendRGBA(const Mat& src1, const Mat& src2, Mat& dst)</p>


            <p>const float alpha_scale = (float)std.numeric_limits
                <T>.max(),
            </p>

            <p>inv_scale = 1.f/alpha_scale;</p>

            <p>CV_Assert(src1.type() == src2.type() &&</p>

            <p>src1.type() == CV_MAKETYPE(DataType
                <T>.depth, 4) &&
            </p>

            <p>src1.size() == src2.size());</p>

            <p>Size size = src1.size();</p>

            <p>dst.create(size, src1.type());</p>

            <p>// here is the idiom: check the arrays for continuity and,</p>

            <p>// if this is the case,</p>

            <p>// treat the arrays as 1D vectors</p>

            <p>if(src1.isContinuous() && src2.isContinuous() && dst.isContinuous())</p>


            <p>size.width *= size.height;</p>

            <p>size.height = 1;</p>


            <p>size.width *= 4;</p>

            <p>for(int i = 0; i < size.height; i++)</p>


            <p>// when the arrays are continuous,</p>

            <p>// the outer loop is executed only once</p>

            <p>const T* ptr1 = src1.ptr
                <T>(i);
            </p>

            <p>const T* ptr2 = src2.ptr
                <T>(i);
            </p>

            <p>T* dptr = dst.ptr
                <T>(i);
            </p>

            <p>for(int j = 0; j < size.width; j += 4)</p>


            <p>float alpha = ptr1[j+3]*inv_scale, beta = ptr2[j+3]*inv_scale;</p>

            <p>dptr[j] = saturate_cast
                <T>(ptr1[j]*alpha + ptr2[j]*beta);
            </p>

            <p>dptr[j+1] = saturate_cast
                <T>(ptr1[j+1]*alpha + ptr2[j+1]*beta);
            </p>

            <p>dptr[j+2] = saturate_cast
                <T>(ptr1[j+2]*alpha + ptr2[j+2]*beta);
            </p>

            <p>dptr[j+3] = saturate_cast
                <T>((1 - (1-alpha)*(1-beta))*alpha_scale);
            </p>


            <p>This approach, while being very simple, can boost the performance of a simple
                element-operation by 10-20 percents, especially if the image is rather small
                and the operation is quite simple.
                </code></p>

            <p>Another OpenCV idiom in this function, a call of "Mat.create" for the
                destination array, that allocates the destination array unless it already has
                the proper size and type. And while the newly allocated arrays are always
                continuous, you still need to check the destination array because
                "Mat.create" does not always allocate a new matrix.</p></div>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-iscontinuous">org.opencv.core.Mat.isContinuous</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="isSubmatrix()">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>isSubmatrix</h4>
        <pre>public&nbsp;boolean&nbsp;isSubmatrix()</pre>
    </li>
</ul>
<a name="locateROI(org.opencv.core.Size, org.opencv.core.Point)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>locateROI</h4>
<pre>public&nbsp;void&nbsp;locateROI(<a href="../../../org/opencv/core/Size.html"
                                        title="class in org.opencv.core">Size</a>&nbsp;wholeSize,
             <a href="../../../org/opencv/core/Point.html"
                title="class in org.opencv.core">Point</a>&nbsp;ofs)</pre>
        <div class="block"><p>Locates the matrix header within a parent matrix.</p>

            <p>After you extracted a submatrix from a matrix using "Mat.row", "Mat.col",
                "Mat.rowRange", "Mat.colRange", and others, the resultant submatrix points
                just to the part of the original big matrix. However, each submatrix contains
                information (represented by <code>datastart</code> and <code>dataend</code>
                fields) that helps reconstruct the original matrix size and the position of
                the extracted submatrix within the original matrix. The method
                <code>locateROI</code> does exactly that.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>wholeSize</code> - Output parameter that contains the size of the whole matrix
                containing <code>*this</code> as a part.
            </dd>
            <dd><code>ofs</code> - Output parameter that contains an offset of <code>*this</code>
                inside the whole matrix.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-locateroi">org.opencv.core.Mat.locateROI</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="mul(org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>mul</h4>
        <pre>public&nbsp;<a href="../../../org/opencv/core/Mat.html"
                            title="class in org.opencv.core">Mat</a>&nbsp;mul(<a
                href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;m)</pre>
        <div class="block"><p>Performs an element-wise multiplication or division of the two
            matrices.</p>

            <p>The method returns a temporary object encoding per-element array
                multiplication, with optional scale. Note that this is not a matrix
                multiplication that corresponds to a simpler "*" operator.
                Example: <code></p>

            <p>// C++ code:</p>

            <p>Mat C = A.mul(5/B); // equivalent to divide(A, B, C, 5)</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>m</code> - Another array of the same type and the same size as
                <code>*this</code>, or a matrix expression.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-mul">org.opencv.core.Mat.mul</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="mul(org.opencv.core.Mat, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>mul</h4>
<pre>public&nbsp;<a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;mul(<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;m,
      double&nbsp;scale)</pre>
        <div class="block"><p>Performs an element-wise multiplication or division of the two
            matrices.</p>

            <p>The method returns a temporary object encoding per-element array
                multiplication, with optional scale. Note that this is not a matrix
                multiplication that corresponds to a simpler "*" operator.
                Example: <code></p>

            <p>// C++ code:</p>

            <p>Mat C = A.mul(5/B); // equivalent to divide(A, B, C, 5)</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>m</code> - Another array of the same type and the same size as
                <code>*this</code>, or a matrix expression.
            </dd>
            <dd><code>scale</code> - Optional scale factor.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-mul">org.opencv.core.Mat.mul</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="ones(int, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>ones</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html"
                           title="class in org.opencv.core">Mat</a>&nbsp;ones(int&nbsp;rows,
       int&nbsp;cols,
       int&nbsp;type)</pre>
        <div class="block"><p>Returns an array of all 1's of the specified size and type.</p>

            <p>The method returns a Matlab-style 1's array initializer, similarly
                to"Mat.zeros". Note that using this method you can initialize an array with
                an arbitrary value, using the following Matlab idiom: <code></p>

            <p>// C++ code:</p>

            <p>Mat A = Mat.ones(100, 100, CV_8U)*3; // make 100x100 matrix filled with 3.</p>

            <p>The above operation does not form a 100x100 matrix of 1's and then multiply
                it by 3. Instead, it just remembers the scale factor (3 in this case) and use
                it when actually invoking the matrix initializer.
                </code></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>rows</code> - Number of rows.</dd>
            <dd><code>cols</code> - Number of columns.</dd>
            <dd><code>type</code> - Created matrix type.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-ones">org.opencv.core.Mat.ones</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="ones(org.opencv.core.Size, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>ones</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html"
                           title="class in org.opencv.core">Mat</a>&nbsp;ones(<a
        href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;size,
       int&nbsp;type)</pre>
        <div class="block"><p>Returns an array of all 1's of the specified size and type.</p>

            <p>The method returns a Matlab-style 1's array initializer, similarly
                to"Mat.zeros". Note that using this method you can initialize an array with
                an arbitrary value, using the following Matlab idiom: <code></p>

            <p>// C++ code:</p>

            <p>Mat A = Mat.ones(100, 100, CV_8U)*3; // make 100x100 matrix filled with 3.</p>

            <p>The above operation does not form a 100x100 matrix of 1's and then multiply
                it by 3. Instead, it just remembers the scale factor (3 in this case) and use
                it when actually invoking the matrix initializer.
                </code></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>size</code> - Alternative to the matrix size specification <code>Size(cols,
                rows)</code>.
            </dd>
            <dd><code>type</code> - Created matrix type.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-ones">org.opencv.core.Mat.ones</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="push_back(org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>push_back</h4>
        <pre>public&nbsp;void&nbsp;push_back(<a href="../../../org/opencv/core/Mat.html"
                                                title="class in org.opencv.core">Mat</a>&nbsp;m)</pre>
        <div class="block"><p>Adds elements to the bottom of the matrix.</p>

            <p>The methods add one or more elements to the bottom of the matrix. They
                emulate the corresponding method of the STL vector class. When
                <code>elem</code> is <code>Mat</code>, its type and the number of columns
                must be the same as in the container matrix.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>m</code> - Added line(s).</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-push-back">org.opencv.core.Mat.push_back</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="put(int, int, byte[])">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>put</h4>
<pre>public&nbsp;int&nbsp;put(int&nbsp;row,
      int&nbsp;col,
      byte[]&nbsp;data)</pre>
    </li>
</ul>
<a name="put(int, int, double...)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>put</h4>
<pre>public&nbsp;int&nbsp;put(int&nbsp;row,
      int&nbsp;col,
      double...&nbsp;data)</pre>
    </li>
</ul>
<a name="put(int, int, float[])">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>put</h4>
<pre>public&nbsp;int&nbsp;put(int&nbsp;row,
      int&nbsp;col,
      float[]&nbsp;data)</pre>
    </li>
</ul>
<a name="put(int, int, int[])">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>put</h4>
<pre>public&nbsp;int&nbsp;put(int&nbsp;row,
      int&nbsp;col,
      int[]&nbsp;data)</pre>
    </li>
</ul>
<a name="put(int, int, short[])">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>put</h4>
<pre>public&nbsp;int&nbsp;put(int&nbsp;row,
      int&nbsp;col,
      short[]&nbsp;data)</pre>
    </li>
</ul>
<a name="release()">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>release</h4>
        <pre>public&nbsp;void&nbsp;release()</pre>
        <div class="block"><p>Decrements the reference counter and deallocates the matrix if
            needed.</p>

            <p>The method decrements the reference counter associated with the matrix data.
                When the reference counter reaches 0, the matrix data is deallocated and the
                data and the reference counter pointers are set to NULL's. If the matrix
                header points to an external data set (see "Mat.Mat"), the reference counter
                is NULL, and the method has no effect in this case.</p>

            <p>This method can be called manually to force the matrix data deallocation. But
                since this method is automatically called in the destructor, or by any other
                method that changes the data pointer, it is usually not needed. The reference
                counter decrement and check for 0 is an atomic operation on the platforms
                that support it. Thus, it is safe to operate on the same matrices
                asynchronously in different threads.</p></div>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-release">org.opencv.core.Mat.release</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="reshape(int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>reshape</h4>
        <pre>public&nbsp;<a href="../../../org/opencv/core/Mat.html"
                            title="class in org.opencv.core">Mat</a>&nbsp;reshape(int&nbsp;cn)</pre>
        <div class="block"><p>Changes the shape and/or the number of channels of a 2D matrix without
            copying the data.</p>

            <p>The method makes a new matrix header for <code>*this</code> elements. The new
                matrix may have a different size and/or different number of channels. Any
                combination is possible if:</p>
            <ul>
                <li> No extra elements are included into the new matrix and no elements are
                    excluded. Consequently, the product <code>rows*cols*channels()</code> must
                    stay the same after the transformation.
                <li> No data is copied. That is, this is an O(1) operation. Consequently,
                    if you change the number of rows, or the operation changes the indices of
                    elements row in some other way, the matrix must be continuous. See
                    "Mat.isContinuous".
            </ul>
            <p>For example, if there is a set of 3D points stored as an STL vector, and you
                want to represent the points as a <code>3xN</code> matrix, do the following:
                <code></p>

            <p>// C++ code:</p>

            <p>std.vector
                <Point3f> vec;...
            </p>

            <p>Mat pointMat = Mat(vec). // convert vector to Mat, O(1) operation</p>

            <p>reshape(1). // make Nx3 1-channel matrix out of Nx1 3-channel.</p>

            <p>// Also, an O(1) operation</p>

            <p>t(); // finally, transpose the Nx3 matrix.</p>

            <p>// This involves copying all the elements</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>cn</code> - New number of channels. If the parameter is 0, the number of
                channels remains the same.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-reshape">org.opencv.core.Mat.reshape</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="reshape(int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>reshape</h4>
<pre>public&nbsp;<a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;reshape(int&nbsp;cn,
          int&nbsp;rows)</pre>
        <div class="block"><p>Changes the shape and/or the number of channels of a 2D matrix without
            copying the data.</p>

            <p>The method makes a new matrix header for <code>*this</code> elements. The new
                matrix may have a different size and/or different number of channels. Any
                combination is possible if:</p>
            <ul>
                <li> No extra elements are included into the new matrix and no elements are
                    excluded. Consequently, the product <code>rows*cols*channels()</code> must
                    stay the same after the transformation.
                <li> No data is copied. That is, this is an O(1) operation. Consequently,
                    if you change the number of rows, or the operation changes the indices of
                    elements row in some other way, the matrix must be continuous. See
                    "Mat.isContinuous".
            </ul>
            <p>For example, if there is a set of 3D points stored as an STL vector, and you
                want to represent the points as a <code>3xN</code> matrix, do the following:
                <code></p>

            <p>// C++ code:</p>

            <p>std.vector
                <Point3f> vec;...
            </p>

            <p>Mat pointMat = Mat(vec). // convert vector to Mat, O(1) operation</p>

            <p>reshape(1). // make Nx3 1-channel matrix out of Nx1 3-channel.</p>

            <p>// Also, an O(1) operation</p>

            <p>t(); // finally, transpose the Nx3 matrix.</p>

            <p>// This involves copying all the elements</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>cn</code> - New number of channels. If the parameter is 0, the number of
                channels remains the same.
            </dd>
            <dd><code>rows</code> - New number of rows. If the parameter is 0, the number of rows
                remains the same.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-reshape">org.opencv.core.Mat.reshape</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="row(int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>row</h4>
        <pre>public&nbsp;<a href="../../../org/opencv/core/Mat.html"
                            title="class in org.opencv.core">Mat</a>&nbsp;row(int&nbsp;y)</pre>
        <div class="block"><p>Creates a matrix header for the specified matrix row.</p>

            <p>The method makes a new header for the specified matrix row and returns it.
                This is an O(1) operation, regardless of the matrix size. The underlying data
                of the new matrix is shared with the original matrix. Here is the example of
                one of the classical basic matrix processing operations, <code>axpy</code>,
                used by LU and many other algorithms: <code></p>

            <p>// C++ code:</p>

            <p>inline void matrix_axpy(Mat& A, int i, int j, double alpha)</p>


            <p>A.row(i) += A.row(j)*alpha;</p>


            <p>Note: </code></p>

            <p>In the current implementation, the following code does not work as expected:
                <code></p>

            <p>// C++ code:</p>

            <p>Mat A;...</p>

            <p>A.row(i) = A.row(j); // will not work</p>

            <p>This happens because <code>A.row(i)</code> forms a temporary header that is
                further assigned to another header. Remember that each of these operations is
                O(1), that is, no data is copied. Thus, the above assignment is not true if
                you may have expected the j-th row to be copied to the i-th row. To achieve
                that, you should either turn this simple assignment into an expression or use
                the "Mat.copyTo" method:</p>

            <p>Mat A;...</p>

            <p>// works, but looks a bit obscure.</p>

            <p>A.row(i) = A.row(j) + 0;</p>

            <p>// this is a bit longer, but the recommended method.</p>

            <p>A.row(j).copyTo(A.row(i));</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>y</code> - A 0-based row index.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-row">org.opencv.core.Mat.row</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="rowRange(int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>rowRange</h4>
<pre>public&nbsp;<a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;rowRange(int&nbsp;startrow,
           int&nbsp;endrow)</pre>
        <div class="block"><p>Creates a matrix header for the specified row span.</p>

            <p>The method makes a new header for the specified row span of the matrix.
                Similarly to "Mat.row" and "Mat.col", this is an O(1) operation.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>startrow</code> - An inclusive 0-based start index of the row span.</dd>
            <dd><code>endrow</code> - An exclusive 0-based ending index of the row span.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-rowrange">org.opencv.core.Mat.rowRange</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="rowRange(org.opencv.core.Range)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>rowRange</h4>
        <pre>public&nbsp;<a href="../../../org/opencv/core/Mat.html"
                            title="class in org.opencv.core">Mat</a>&nbsp;rowRange(<a
                href="../../../org/opencv/core/Range.html"
                title="class in org.opencv.core">Range</a>&nbsp;r)</pre>
        <div class="block"><p>Creates a matrix header for the specified row span.</p>

            <p>The method makes a new header for the specified row span of the matrix.
                Similarly to "Mat.row" and "Mat.col", this is an O(1) operation.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>r</code> - "Range" structure containing both the start and the end indices.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-rowrange">org.opencv.core.Mat.rowRange</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="rows()">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>rows</h4>
        <pre>public&nbsp;int&nbsp;rows()</pre>
    </li>
</ul>
<a name="setTo(org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>setTo</h4>
        <pre>public&nbsp;<a href="../../../org/opencv/core/Mat.html"
                            title="class in org.opencv.core">Mat</a>&nbsp;setTo(<a
                href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;value)</pre>
        <div class="block"><p>Sets all or some of the array elements to the specified value.</p>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>value</code> - Assigned scalar converted to the actual array type.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-setto">org.opencv.core.Mat.setTo</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="setTo(org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>setTo</h4>
<pre>public&nbsp;<a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;setTo(<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;value,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
        <div class="block"><p>Sets all or some of the array elements to the specified value.</p>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>value</code> - Assigned scalar converted to the actual array type.</dd>
            <dd><code>mask</code> - Operation mask of the same size as <code>*this</code>. This is
                an
                advanced variant of the <code>Mat.operator=(const Scalar& s)</code>
                operator.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-setto">org.opencv.core.Mat.setTo</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="setTo(org.opencv.core.Scalar)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>setTo</h4>
        <pre>public&nbsp;<a href="../../../org/opencv/core/Mat.html"
                            title="class in org.opencv.core">Mat</a>&nbsp;setTo(<a
                href="../../../org/opencv/core/Scalar.html"
                title="class in org.opencv.core">Scalar</a>&nbsp;s)</pre>
    </li>
</ul>
<a name="setTo(org.opencv.core.Scalar, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>setTo</h4>
<pre>public&nbsp;<a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;setTo(<a
        href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;value,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
        <div class="block"><p>Sets all or some of the array elements to the specified value.</p>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>value</code> - Assigned scalar converted to the actual array type.</dd>
            <dd><code>mask</code> - Operation mask of the same size as <code>*this</code>. This is
                an
                advanced variant of the <code>Mat.operator=(const Scalar& s)</code>
                operator.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-setto">org.opencv.core.Mat.setTo</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="size()">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>size</h4>
        <pre>public&nbsp;<a href="../../../org/opencv/core/Size.html"
                            title="class in org.opencv.core">Size</a>&nbsp;size()</pre>
        <div class="block"><p>Returns a matrix size.</p>

            <p>The method returns a matrix size: <code>Size(cols, rows)</code>. When the
                matrix is more than 2-dimensional, the returned size is (-1, -1).</p></div>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-size">org.opencv.core.Mat.size</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="step1()">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>step1</h4>
        <pre>public&nbsp;long&nbsp;step1()</pre>
        <div class="block"><p>Returns a normalized step.</p>

            <p>The method returns a matrix step divided by "Mat.elemSize1()". It can be
                useful to quickly access an arbitrary matrix element.</p></div>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-step1">org.opencv.core.Mat.step1</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="step1(int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>step1</h4>
        <pre>public&nbsp;long&nbsp;step1(int&nbsp;i)</pre>
        <div class="block"><p>Returns a normalized step.</p>

            <p>The method returns a matrix step divided by "Mat.elemSize1()". It can be
                useful to quickly access an arbitrary matrix element.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>i</code> - a i</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-step1">org.opencv.core.Mat.step1</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="submat(int, int, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>submat</h4>
<pre>public&nbsp;<a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;submat(int&nbsp;rowStart,
         int&nbsp;rowEnd,
         int&nbsp;colStart,
         int&nbsp;colEnd)</pre>
        <div class="block"><p>Extracts a rectangular submatrix.</p>

            <p>The operators make a new header for the specified sub-array of
                <code>*this</code>. They are the most generalized forms of "Mat.row",
                "Mat.col", "Mat.rowRange", and "Mat.colRange". For example,
                <code>A(Range(0, 10), Range.all())</code> is equivalent to <code>A.rowRange(0,
                    10)</code>. Similarly to all of the above, the operators are O(1) operations,
                that is, no matrix data is copied.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>rowStart</code> - a rowStart</dd>
            <dd><code>rowEnd</code> - a rowEnd</dd>
            <dd><code>colStart</code> - a colStart</dd>
            <dd><code>colEnd</code> - a colEnd</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-operator">org.opencv.core.Mat.operator()</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="submat(org.opencv.core.Range, org.opencv.core.Range)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>submat</h4>
<pre>public&nbsp;<a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;submat(<a
        href="../../../org/opencv/core/Range.html" title="class in org.opencv.core">Range</a>&nbsp;rowRange,
         <a href="../../../org/opencv/core/Range.html" title="class in org.opencv.core">Range</a>&nbsp;colRange)</pre>
        <div class="block"><p>Extracts a rectangular submatrix.</p>

            <p>The operators make a new header for the specified sub-array of
                <code>*this</code>. They are the most generalized forms of "Mat.row",
                "Mat.col", "Mat.rowRange", and "Mat.colRange". For example,
                <code>A(Range(0, 10), Range.all())</code> is equivalent to <code>A.rowRange(0,
                    10)</code>. Similarly to all of the above, the operators are O(1) operations,
                that is, no matrix data is copied.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>rowRange</code> - Start and end row of the extracted submatrix. The upper
                boundary is not included. To select all the rows, use <code>Range.all()</code>.
            </dd>
            <dd><code>colRange</code> - Start and end column of the extracted submatrix. The upper
                boundary is not included. To select all the columns, use <code>Range.all()</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-operator">org.opencv.core.Mat.operator()</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="submat(org.opencv.core.Rect)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>submat</h4>
        <pre>public&nbsp;<a href="../../../org/opencv/core/Mat.html"
                            title="class in org.opencv.core">Mat</a>&nbsp;submat(<a
                href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;roi)</pre>
        <div class="block"><p>Extracts a rectangular submatrix.</p>

            <p>The operators make a new header for the specified sub-array of
                <code>*this</code>. They are the most generalized forms of "Mat.row",
                "Mat.col", "Mat.rowRange", and "Mat.colRange". For example,
                <code>A(Range(0, 10), Range.all())</code> is equivalent to <code>A.rowRange(0,
                    10)</code>. Similarly to all of the above, the operators are O(1) operations,
                that is, no matrix data is copied.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>roi</code> - Extracted submatrix specified as a rectangle.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-operator">org.opencv.core.Mat.operator()</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="t()">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>t</h4>
        <pre>public&nbsp;<a href="../../../org/opencv/core/Mat.html"
                            title="class in org.opencv.core">Mat</a>&nbsp;t()</pre>
        <div class="block"><p>Transposes a matrix.</p>

            <p>The method performs matrix transposition by means of matrix expressions. It
                does not perform the actual transposition but returns a temporary matrix
                transposition object that can be further used as a part of more complex
                matrix expressions or can be assigned to a matrix: <code></p>

            <p>// C++ code:</p>

            <p>Mat A1 = A + Mat.eye(A.size(), A.type())*lambda;</p>

            <p>Mat C = A1.t()*A1; // compute (A + lambda*I)^t * (A + lamda*I)</p></div>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-t">org.opencv.core.Mat.t</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="toString()">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>toString</h4>
        <pre>public&nbsp;java.lang.String&nbsp;toString()</pre>
        <dl>
            <dt><strong>Overrides:</strong></dt>
            <dd><code>toString</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
        </dl>
    </li>
</ul>
<a name="total()">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>total</h4>
        <pre>public&nbsp;long&nbsp;total()</pre>
        <div class="block"><p>Returns the total number of array elements.</p>

            <p>The method returns the number of array elements (a number of pixels if the
                array represents an image).</p></div>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-total">org.opencv.core.Mat.total</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="type()">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>type</h4>
        <pre>public&nbsp;int&nbsp;type()</pre>
        <div class="block"><p>Returns the type of a matrix element.</p>

            <p>The method returns a matrix element type. This is an identifier compatible
                with the <code>CvMat</code> type system, like <code>CV_16SC3</code> or 16-bit
                signed 3-channel array, and so on.</p></div>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-type">org.opencv.core.Mat.type</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="width()">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>width</h4>
        <pre>public&nbsp;int&nbsp;width()</pre>
    </li>
</ul>
<a name="zeros(int, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>zeros</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html"
                           title="class in org.opencv.core">Mat</a>&nbsp;zeros(int&nbsp;rows,
        int&nbsp;cols,
        int&nbsp;type)</pre>
        <div class="block"><p>Returns a zero array of the specified size and type.</p>

            <p>The method returns a Matlab-style zero array initializer. It can be used to
                quickly form a constant array as a function parameter, part of a matrix
                expression, or as a matrix initializer.
                <code></p>

            <p>// C++ code:</p>

            <p>Mat A;</p>

            <p>A = Mat.zeros(3, 3, CV_32F);</p>

            <p>In the example above, a new matrix is allocated only if <code>A</code> is not
                a 3x3 floating-point matrix. Otherwise, the existing matrix <code>A</code> is
                filled with zeros.
                </code></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>rows</code> - Number of rows.</dd>
            <dd><code>cols</code> - Number of columns.</dd>
            <dd><code>type</code> - Created matrix type.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-zeros">org.opencv.core.Mat.zeros</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="zeros(org.opencv.core.Size, int)">
    <!--   -->
</a>
<ul class="blockListLast">
    <li class="blockList">
        <h4>zeros</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html"
                           title="class in org.opencv.core">Mat</a>&nbsp;zeros(<a
        href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;size,
        int&nbsp;type)</pre>
        <div class="block"><p>Returns a zero array of the specified size and type.</p>

            <p>The method returns a Matlab-style zero array initializer. It can be used to
                quickly form a constant array as a function parameter, part of a matrix
                expression, or as a matrix initializer.
                <code></p>

            <p>// C++ code:</p>

            <p>Mat A;</p>

            <p>A = Mat.zeros(3, 3, CV_32F);</p>

            <p>In the example above, a new matrix is allocated only if <code>A</code> is not
                a 3x3 floating-point matrix. Otherwise, the existing matrix <code>A</code> is
                filled with zeros.
                </code></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>size</code> - Alternative to the matrix size specification <code>Size(cols,
                rows)</code>.
            </dd>
            <dd><code>type</code> - Created matrix type.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-zeros">org.opencv.core.Mat.zeros</a>
            </dd>
        </dl>
    </li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
    <!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a
        name="navbar_bottom_firstrow">
    <!--   -->
</a>
    <ul class="navList" title="Navigation">
        <li><a href="../../../overview-summary.html">Overview</a></li>
        <li><a href="package-summary.html">Package</a></li>
        <li class="navBarCell1Rev">Class</li>
        <li><a href="package-tree.html">Tree</a></li>
        <li><a href="../../../index-all.html">Index</a></li>
        <li><a href="../../../help-doc.html">Help</a></li>
    </ul>
    <div class="aboutLanguage"><em><a href=http://docs.opencv.org>OpenCV 2.4.11
        Documentation</a></em></div>
</div>
<div class="subNav">
    <ul class="navList">
        <li><a href="../../../org/opencv/core/CvType.html" title="class in org.opencv.core"><span
                class="strong">PREV CLASS</span></a></li>
        <li><a href="../../../org/opencv/core/MatOfByte.html" title="class in org.opencv.core"><span
                class="strong">NEXT CLASS</span></a></li>
    </ul>
    <ul class="navList">
        <li><a href="../../../index.html?org/opencv/core/Mat.html" target="_top">FRAMES</a></li>
        <li><a href="Mat.html" target="_top">NO FRAMES</a></li>
    </ul>
    <ul class="navList" id="allclasses_navbar_bottom">
        <li><a href="../../../allclasses-noframe.html">All Classes</a></li>
    </ul>
    <div>
        <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->

        </script>
    </div>
    <div>
        <ul class="subNavList">
            <li>SUMMARY:&nbsp;</li>
            <li>NESTED&nbsp;|&nbsp;</li>
            <li><a href="#field_summary">FIELD</a>&nbsp;|&nbsp;</li>
            <li><a href="#constructor_summary">CONSTR</a>&nbsp;|&nbsp;</li>
            <li><a href="#method_summary">METHOD</a></li>
        </ul>
        <ul class="subNavList">
            <li>DETAIL:&nbsp;</li>
            <li><a href="#field_detail">FIELD</a>&nbsp;|&nbsp;</li>
            <li><a href="#constructor_detail">CONSTR</a>&nbsp;|&nbsp;</li>
            <li><a href="#method_detail">METHOD</a></li>
        </ul>
    </div>
    <a name="skip-navbar_bottom">
        <!--   -->
    </a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
