<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
    <!-- Generated by javadoc (version 1.6.0_34) on Wed Mar 04 17:44:06 MSK 2015 -->
    <title>Imgproc</title>
    <meta name="date" content="2015-03-04">
    <link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Imgproc";
    }
//-->

</script>
<noscript>
    <div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
    <!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
    <!--   -->
</a>
    <ul class="navList" title="Navigation">
        <li><a href="../../../overview-summary.html">Overview</a></li>
        <li><a href="package-summary.html">Package</a></li>
        <li class="navBarCell1Rev">Class</li>
        <li><a href="package-tree.html">Tree</a></li>
        <li><a href="../../../index-all.html">Index</a></li>
        <li><a href="../../../help-doc.html">Help</a></li>
    </ul>
    <div class="aboutLanguage"><em>OpenCV 2.4.11</em></div>
</div>
<div class="subNav">
    <ul class="navList">
        <li><a href="../../../org/opencv/imgproc/CLAHE.html"
               title="class in org.opencv.imgproc"><span class="strong">PREV CLASS</span></a></li>
        <li><a href="../../../org/opencv/imgproc/Moments.html"
               title="class in org.opencv.imgproc"><span class="strong">NEXT CLASS</span></a></li>
    </ul>
    <ul class="navList">
        <li><a href="../../../index.html?org/opencv/imgproc/Imgproc.html" target="_top">FRAMES</a>
        </li>
        <li><a href="Imgproc.html" target="_top">NO FRAMES</a></li>
    </ul>
    <ul class="navList" id="allclasses_navbar_top">
        <li><a href="../../../allclasses-noframe.html">All Classes</a></li>
    </ul>
    <div>
        <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->

        </script>
    </div>
    <div>
        <ul class="subNavList">
            <li>SUMMARY:&nbsp;</li>
            <li>NESTED&nbsp;|&nbsp;</li>
            <li><a href="#field_summary">FIELD</a>&nbsp;|&nbsp;</li>
            <li><a href="#constructor_summary">CONSTR</a>&nbsp;|&nbsp;</li>
            <li><a href="#method_summary">METHOD</a></li>
        </ul>
        <ul class="subNavList">
            <li>DETAIL:&nbsp;</li>
            <li><a href="#field_detail">FIELD</a>&nbsp;|&nbsp;</li>
            <li><a href="#constructor_detail">CONSTR</a>&nbsp;|&nbsp;</li>
            <li><a href="#method_detail">METHOD</a></li>
        </ul>
    </div>
    <a name="skip-navbar_top">
        <!--   -->
    </a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
    <p class="subTitle">org.opencv.imgproc</p>

    <h2 title="Class Imgproc" class="title">Class Imgproc</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
    <li>java.lang.Object</li>
    <li>
        <ul class="inheritance">
            <li>org.opencv.imgproc.Imgproc</li>
        </ul>
    </li>
</ul>
<div class="description">
    <ul class="blockList">
        <li class="blockList">
            <hr>
            <br>
<pre>public class <strong>Imgproc</strong>
extends java.lang.Object</pre>
        </li>
    </ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_summary">
    <!--   -->
</a>

<h3>Field Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0"
       summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
    <th class="colFirst" scope="col">Modifier and Type</th>
    <th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#ADAPTIVE_THRESH_GAUSSIAN_C">ADAPTIVE_THRESH_GAUSSIAN_C</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#ADAPTIVE_THRESH_MEAN_C">ADAPTIVE_THRESH_MEAN_C</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#BORDER_CONSTANT">BORDER_CONSTANT</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#BORDER_DEFAULT">BORDER_DEFAULT</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#BORDER_ISOLATED">BORDER_ISOLATED</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#BORDER_REFLECT">BORDER_REFLECT</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#BORDER_REFLECT_101">BORDER_REFLECT_101</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#BORDER_REFLECT101">BORDER_REFLECT101</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#BORDER_REPLICATE">BORDER_REPLICATE</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#BORDER_TRANSPARENT">BORDER_TRANSPARENT</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#BORDER_WRAP">BORDER_WRAP</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CHAIN_APPROX_NONE">CHAIN_APPROX_NONE</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CHAIN_APPROX_SIMPLE">CHAIN_APPROX_SIMPLE</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CHAIN_APPROX_TC89_KCOS">CHAIN_APPROX_TC89_KCOS</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CHAIN_APPROX_TC89_L1">CHAIN_APPROX_TC89_L1</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerBG2BGR">COLOR_BayerBG2BGR</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerBG2BGR_VNG">COLOR_BayerBG2BGR_VNG</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerBG2GRAY">COLOR_BayerBG2GRAY</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerBG2RGB">COLOR_BayerBG2RGB</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerBG2RGB_VNG">COLOR_BayerBG2RGB_VNG</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGB2BGR">COLOR_BayerGB2BGR</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGB2BGR_VNG">COLOR_BayerGB2BGR_VNG</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGB2GRAY">COLOR_BayerGB2GRAY</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGB2RGB">COLOR_BayerGB2RGB</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGB2RGB_VNG">COLOR_BayerGB2RGB_VNG</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGR2BGR">COLOR_BayerGR2BGR</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGR2BGR_VNG">COLOR_BayerGR2BGR_VNG</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGR2GRAY">COLOR_BayerGR2GRAY</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGR2RGB">COLOR_BayerGR2RGB</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGR2RGB_VNG">COLOR_BayerGR2RGB_VNG</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerRG2BGR">COLOR_BayerRG2BGR</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerRG2BGR_VNG">COLOR_BayerRG2BGR_VNG</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerRG2GRAY">COLOR_BayerRG2GRAY</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerRG2RGB">COLOR_BayerRG2RGB</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerRG2RGB_VNG">COLOR_BayerRG2RGB_VNG</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR2BGR555">COLOR_BGR2BGR555</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR2BGR565">COLOR_BGR2BGR565</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR2BGRA">COLOR_BGR2BGRA</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR2GRAY">COLOR_BGR2GRAY</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR2HLS">COLOR_BGR2HLS</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR2HLS_FULL">COLOR_BGR2HLS_FULL</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR2HSV">COLOR_BGR2HSV</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR2HSV_FULL">COLOR_BGR2HSV_FULL</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR2Lab">COLOR_BGR2Lab</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR2Luv">COLOR_BGR2Luv</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR2RGB">COLOR_BGR2RGB</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR2RGBA">COLOR_BGR2RGBA</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR2XYZ">COLOR_BGR2XYZ</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR2YCrCb">COLOR_BGR2YCrCb</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR2YUV">COLOR_BGR2YUV</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR2YUV_I420">COLOR_BGR2YUV_I420</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR2YUV_IYUV">COLOR_BGR2YUV_IYUV</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR2YUV_YV12">COLOR_BGR2YUV_YV12</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR5552BGR">COLOR_BGR5552BGR</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR5552BGRA">COLOR_BGR5552BGRA</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR5552GRAY">COLOR_BGR5552GRAY</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR5552RGB">COLOR_BGR5552RGB</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR5552RGBA">COLOR_BGR5552RGBA</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR5652BGR">COLOR_BGR5652BGR</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR5652BGRA">COLOR_BGR5652BGRA</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR5652GRAY">COLOR_BGR5652GRAY</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR5652RGB">COLOR_BGR5652RGB</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR5652RGBA">COLOR_BGR5652RGBA</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGRA2BGR">COLOR_BGRA2BGR</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGRA2BGR555">COLOR_BGRA2BGR555</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGRA2BGR565">COLOR_BGRA2BGR565</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGRA2GRAY">COLOR_BGRA2GRAY</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGRA2RGB">COLOR_BGRA2RGB</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGRA2RGBA">COLOR_BGRA2RGBA</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGRA2YUV_I420">COLOR_BGRA2YUV_I420</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGRA2YUV_IYUV">COLOR_BGRA2YUV_IYUV</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGRA2YUV_YV12">COLOR_BGRA2YUV_YV12</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_COLORCVT_MAX">COLOR_COLORCVT_MAX</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_GRAY2BGR">COLOR_GRAY2BGR</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_GRAY2BGR555">COLOR_GRAY2BGR555</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_GRAY2BGR565">COLOR_GRAY2BGR565</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_GRAY2BGRA">COLOR_GRAY2BGRA</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_GRAY2RGB">COLOR_GRAY2RGB</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_GRAY2RGBA">COLOR_GRAY2RGBA</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_HLS2BGR">COLOR_HLS2BGR</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_HLS2BGR_FULL">COLOR_HLS2BGR_FULL</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_HLS2RGB">COLOR_HLS2RGB</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_HLS2RGB_FULL">COLOR_HLS2RGB_FULL</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_HSV2BGR">COLOR_HSV2BGR</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_HSV2BGR_FULL">COLOR_HSV2BGR_FULL</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_HSV2RGB">COLOR_HSV2RGB</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_HSV2RGB_FULL">COLOR_HSV2RGB_FULL</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_Lab2BGR">COLOR_Lab2BGR</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_Lab2LBGR">COLOR_Lab2LBGR</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_Lab2LRGB">COLOR_Lab2LRGB</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_Lab2RGB">COLOR_Lab2RGB</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_LBGR2Lab">COLOR_LBGR2Lab</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_LBGR2Luv">COLOR_LBGR2Luv</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_LRGB2Lab">COLOR_LRGB2Lab</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_LRGB2Luv">COLOR_LRGB2Luv</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_Luv2BGR">COLOR_Luv2BGR</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_Luv2LBGR">COLOR_Luv2LBGR</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_Luv2LRGB">COLOR_Luv2LRGB</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_Luv2RGB">COLOR_Luv2RGB</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_mRGBA2RGBA">COLOR_mRGBA2RGBA</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGB2BGR">COLOR_RGB2BGR</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGB2BGR555">COLOR_RGB2BGR555</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGB2BGR565">COLOR_RGB2BGR565</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGB2BGRA">COLOR_RGB2BGRA</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGB2GRAY">COLOR_RGB2GRAY</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGB2HLS">COLOR_RGB2HLS</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGB2HLS_FULL">COLOR_RGB2HLS_FULL</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGB2HSV">COLOR_RGB2HSV</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGB2HSV_FULL">COLOR_RGB2HSV_FULL</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGB2Lab">COLOR_RGB2Lab</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGB2Luv">COLOR_RGB2Luv</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGB2RGBA">COLOR_RGB2RGBA</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGB2XYZ">COLOR_RGB2XYZ</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGB2YCrCb">COLOR_RGB2YCrCb</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGB2YUV">COLOR_RGB2YUV</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGB2YUV_I420">COLOR_RGB2YUV_I420</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGB2YUV_IYUV">COLOR_RGB2YUV_IYUV</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGB2YUV_YV12">COLOR_RGB2YUV_YV12</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGBA2BGR">COLOR_RGBA2BGR</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGBA2BGR555">COLOR_RGBA2BGR555</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGBA2BGR565">COLOR_RGBA2BGR565</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGBA2BGRA">COLOR_RGBA2BGRA</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGBA2GRAY">COLOR_RGBA2GRAY</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGBA2mRGBA">COLOR_RGBA2mRGBA</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGBA2RGB">COLOR_RGBA2RGB</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGBA2YUV_I420">COLOR_RGBA2YUV_I420</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGBA2YUV_IYUV">COLOR_RGBA2YUV_IYUV</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGBA2YUV_YV12">COLOR_RGBA2YUV_YV12</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_XYZ2BGR">COLOR_XYZ2BGR</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_XYZ2RGB">COLOR_XYZ2RGB</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YCrCb2BGR">COLOR_YCrCb2BGR</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YCrCb2RGB">COLOR_YCrCb2RGB</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGR">COLOR_YUV2BGR</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGR_I420">COLOR_YUV2BGR_I420</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGR_IYUV">COLOR_YUV2BGR_IYUV</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGR_NV12">COLOR_YUV2BGR_NV12</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGR_NV21">COLOR_YUV2BGR_NV21</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGR_UYNV">COLOR_YUV2BGR_UYNV</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGR_UYVY">COLOR_YUV2BGR_UYVY</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGR_Y422">COLOR_YUV2BGR_Y422</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGR_YUNV">COLOR_YUV2BGR_YUNV</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGR_YUY2">COLOR_YUV2BGR_YUY2</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGR_YUYV">COLOR_YUV2BGR_YUYV</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGR_YV12">COLOR_YUV2BGR_YV12</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGR_YVYU">COLOR_YUV2BGR_YVYU</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGRA_I420">COLOR_YUV2BGRA_I420</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGRA_IYUV">COLOR_YUV2BGRA_IYUV</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGRA_NV12">COLOR_YUV2BGRA_NV12</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGRA_NV21">COLOR_YUV2BGRA_NV21</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGRA_UYNV">COLOR_YUV2BGRA_UYNV</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGRA_UYVY">COLOR_YUV2BGRA_UYVY</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGRA_Y422">COLOR_YUV2BGRA_Y422</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGRA_YUNV">COLOR_YUV2BGRA_YUNV</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGRA_YUY2">COLOR_YUV2BGRA_YUY2</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGRA_YUYV">COLOR_YUV2BGRA_YUYV</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGRA_YV12">COLOR_YUV2BGRA_YV12</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGRA_YVYU">COLOR_YUV2BGRA_YVYU</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2GRAY_420">COLOR_YUV2GRAY_420</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2GRAY_I420">COLOR_YUV2GRAY_I420</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2GRAY_IYUV">COLOR_YUV2GRAY_IYUV</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2GRAY_NV12">COLOR_YUV2GRAY_NV12</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2GRAY_NV21">COLOR_YUV2GRAY_NV21</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2GRAY_UYNV">COLOR_YUV2GRAY_UYNV</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2GRAY_UYVY">COLOR_YUV2GRAY_UYVY</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2GRAY_Y422">COLOR_YUV2GRAY_Y422</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2GRAY_YUNV">COLOR_YUV2GRAY_YUNV</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2GRAY_YUY2">COLOR_YUV2GRAY_YUY2</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2GRAY_YUYV">COLOR_YUV2GRAY_YUYV</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2GRAY_YV12">COLOR_YUV2GRAY_YV12</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2GRAY_YVYU">COLOR_YUV2GRAY_YVYU</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGB">COLOR_YUV2RGB</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGB_I420">COLOR_YUV2RGB_I420</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGB_IYUV">COLOR_YUV2RGB_IYUV</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGB_NV12">COLOR_YUV2RGB_NV12</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGB_NV21">COLOR_YUV2RGB_NV21</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGB_UYNV">COLOR_YUV2RGB_UYNV</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGB_UYVY">COLOR_YUV2RGB_UYVY</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGB_Y422">COLOR_YUV2RGB_Y422</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGB_YUNV">COLOR_YUV2RGB_YUNV</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGB_YUY2">COLOR_YUV2RGB_YUY2</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGB_YUYV">COLOR_YUV2RGB_YUYV</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGB_YV12">COLOR_YUV2RGB_YV12</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGB_YVYU">COLOR_YUV2RGB_YVYU</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGBA_I420">COLOR_YUV2RGBA_I420</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGBA_IYUV">COLOR_YUV2RGBA_IYUV</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGBA_NV12">COLOR_YUV2RGBA_NV12</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGBA_NV21">COLOR_YUV2RGBA_NV21</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGBA_UYNV">COLOR_YUV2RGBA_UYNV</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGBA_UYVY">COLOR_YUV2RGBA_UYVY</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGBA_Y422">COLOR_YUV2RGBA_Y422</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGBA_YUNV">COLOR_YUV2RGBA_YUNV</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGBA_YUY2">COLOR_YUV2RGBA_YUY2</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGBA_YUYV">COLOR_YUV2RGBA_YUYV</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGBA_YV12">COLOR_YUV2RGBA_YV12</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGBA_YVYU">COLOR_YUV2RGBA_YVYU</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV420p2BGR">COLOR_YUV420p2BGR</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV420p2BGRA">COLOR_YUV420p2BGRA</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV420p2GRAY">COLOR_YUV420p2GRAY</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV420p2RGB">COLOR_YUV420p2RGB</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV420p2RGBA">COLOR_YUV420p2RGBA</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV420sp2BGR">COLOR_YUV420sp2BGR</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV420sp2BGRA">COLOR_YUV420sp2BGRA</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV420sp2GRAY">COLOR_YUV420sp2GRAY</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV420sp2RGB">COLOR_YUV420sp2RGB</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV420sp2RGBA">COLOR_YUV420sp2RGBA</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_BILATERAL">CV_BILATERAL</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/imgproc/Imgproc.html#CV_BLUR">CV_BLUR</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_BLUR_NO_SCALE">CV_BLUR_NO_SCALE</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_CANNY_L2_GRADIENT">CV_CANNY_L2_GRADIENT</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_CHAIN_CODE">CV_CHAIN_CODE</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_CLOCKWISE">CV_CLOCKWISE</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_COMP_BHATTACHARYYA">CV_COMP_BHATTACHARYYA</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_COMP_CHISQR">CV_COMP_CHISQR</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_COMP_CORREL">CV_COMP_CORREL</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_COMP_HELLINGER">CV_COMP_HELLINGER</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_COMP_INTERSECT">CV_COMP_INTERSECT</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_CONTOURS_MATCH_I1">CV_CONTOURS_MATCH_I1</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_CONTOURS_MATCH_I2">CV_CONTOURS_MATCH_I2</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_CONTOURS_MATCH_I3">CV_CONTOURS_MATCH_I3</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_COUNTER_CLOCKWISE">CV_COUNTER_CLOCKWISE</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/imgproc/Imgproc.html#CV_DIST_C">CV_DIST_C</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_DIST_FAIR">CV_DIST_FAIR</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_DIST_HUBER">CV_DIST_HUBER</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/imgproc/Imgproc.html#CV_DIST_L1">CV_DIST_L1</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_DIST_L12">CV_DIST_L12</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/imgproc/Imgproc.html#CV_DIST_L2">CV_DIST_L2</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_DIST_LABEL_CCOMP">CV_DIST_LABEL_CCOMP</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_DIST_LABEL_PIXEL">CV_DIST_LABEL_PIXEL</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_DIST_MASK_3">CV_DIST_MASK_3</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_DIST_MASK_5">CV_DIST_MASK_5</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_DIST_MASK_PRECISE">CV_DIST_MASK_PRECISE</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_DIST_USER">CV_DIST_USER</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_DIST_WELSCH">CV_DIST_WELSCH</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_GAUSSIAN">CV_GAUSSIAN</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_GAUSSIAN_5x5">CV_GAUSSIAN_5x5</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_HOUGH_GRADIENT">CV_HOUGH_GRADIENT</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_HOUGH_MULTI_SCALE">CV_HOUGH_MULTI_SCALE</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_HOUGH_PROBABILISTIC">CV_HOUGH_PROBABILISTIC</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_HOUGH_STANDARD">CV_HOUGH_STANDARD</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_LINK_RUNS">CV_LINK_RUNS</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_MAX_SOBEL_KSIZE">CV_MAX_SOBEL_KSIZE</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/imgproc/Imgproc.html#CV_MEDIAN">CV_MEDIAN</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_mRGBA2RGBA">CV_mRGBA2RGBA</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_POLY_APPROX_DP">CV_POLY_APPROX_DP</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_RGBA2mRGBA">CV_RGBA2mRGBA</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/imgproc/Imgproc.html#CV_SCHARR">CV_SCHARR</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_SHAPE_CROSS">CV_SHAPE_CROSS</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_SHAPE_CUSTOM">CV_SHAPE_CUSTOM</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_SHAPE_ELLIPSE">CV_SHAPE_ELLIPSE</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_SHAPE_RECT">CV_SHAPE_RECT</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_WARP_FILL_OUTLIERS">CV_WARP_FILL_OUTLIERS</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#CV_WARP_INVERSE_MAP">CV_WARP_INVERSE_MAP</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#DIST_LABEL_CCOMP">DIST_LABEL_CCOMP</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#DIST_LABEL_PIXEL">DIST_LABEL_PIXEL</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#FLOODFILL_FIXED_RANGE">FLOODFILL_FIXED_RANGE</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#FLOODFILL_MASK_ONLY">FLOODFILL_MASK_ONLY</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/imgproc/Imgproc.html#GC_BGD">GC_BGD</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/imgproc/Imgproc.html#GC_EVAL">GC_EVAL</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/imgproc/Imgproc.html#GC_FGD">GC_FGD</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#GC_INIT_WITH_MASK">GC_INIT_WITH_MASK</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#GC_INIT_WITH_RECT">GC_INIT_WITH_RECT</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/imgproc/Imgproc.html#GC_PR_BGD">GC_PR_BGD</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/imgproc/Imgproc.html#GC_PR_FGD">GC_PR_FGD</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#GHT_POSITION">GHT_POSITION</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#GHT_ROTATION">GHT_ROTATION</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/imgproc/Imgproc.html#GHT_SCALE">GHT_SCALE</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/imgproc/Imgproc.html#INTER_AREA">INTER_AREA</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/imgproc/Imgproc.html#INTER_BITS">INTER_BITS</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#INTER_BITS2">INTER_BITS2</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#INTER_CUBIC">INTER_CUBIC</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#INTER_LANCZOS4">INTER_LANCZOS4</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#INTER_LINEAR">INTER_LINEAR</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/imgproc/Imgproc.html#INTER_MAX">INTER_MAX</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#INTER_NEAREST">INTER_NEAREST</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#INTER_TAB_SIZE">INTER_TAB_SIZE</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#INTER_TAB_SIZE2">INTER_TAB_SIZE2</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#KERNEL_ASYMMETRICAL">KERNEL_ASYMMETRICAL</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#KERNEL_GENERAL">KERNEL_GENERAL</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#KERNEL_INTEGER">KERNEL_INTEGER</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#KERNEL_SMOOTH">KERNEL_SMOOTH</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#KERNEL_SYMMETRICAL">KERNEL_SYMMETRICAL</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#MORPH_BLACKHAT">MORPH_BLACKHAT</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#MORPH_CLOSE">MORPH_CLOSE</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#MORPH_CROSS">MORPH_CROSS</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#MORPH_DILATE">MORPH_DILATE</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#MORPH_ELLIPSE">MORPH_ELLIPSE</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#MORPH_ERODE">MORPH_ERODE</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#MORPH_GRADIENT">MORPH_GRADIENT</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/imgproc/Imgproc.html#MORPH_OPEN">MORPH_OPEN</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/imgproc/Imgproc.html#MORPH_RECT">MORPH_RECT</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#MORPH_TOPHAT">MORPH_TOPHAT</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#PROJ_SPHERICAL_EQRECT">PROJ_SPHERICAL_EQRECT</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#PROJ_SPHERICAL_ORTHO">PROJ_SPHERICAL_ORTHO</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/imgproc/Imgproc.html#RETR_CCOMP">RETR_CCOMP</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#RETR_EXTERNAL">RETR_EXTERNAL</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#RETR_FLOODFILL">RETR_FLOODFILL</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/imgproc/Imgproc.html#RETR_LIST">RETR_LIST</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/imgproc/Imgproc.html#RETR_TREE">RETR_TREE</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#THRESH_BINARY">THRESH_BINARY</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#THRESH_BINARY_INV">THRESH_BINARY_INV</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#THRESH_MASK">THRESH_MASK</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#THRESH_OTSU">THRESH_OTSU</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#THRESH_TOZERO">THRESH_TOZERO</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#THRESH_TOZERO_INV">THRESH_TOZERO_INV</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#THRESH_TRUNC">THRESH_TRUNC</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/imgproc/Imgproc.html#TM_CCOEFF">TM_CCOEFF</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#TM_CCOEFF_NORMED">TM_CCOEFF_NORMED</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/imgproc/Imgproc.html#TM_CCORR">TM_CCORR</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#TM_CCORR_NORMED">TM_CCORR_NORMED</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a href="../../../org/opencv/imgproc/Imgproc.html#TM_SQDIFF">TM_SQDIFF</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#TM_SQDIFF_NORMED">TM_SQDIFF_NORMED</a></strong></code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#WARP_INVERSE_MAP">WARP_INVERSE_MAP</a></strong></code>&nbsp;
    </td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
    <li class="blockList"><a name="constructor_summary">
        <!--   -->
    </a>

        <h3>Constructor Summary</h3>
        <table class="overviewSummary" border="0" cellpadding="3" cellspacing="0"
               summary="Constructor Summary table, listing constructors, and an explanation">
            <caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
            <tr>
                <th class="colOne" scope="col">Constructor and Description</th>
            </tr>
            <tr class="altColor">
                <td class="colOne"><code><strong><a
                        href="../../../org/opencv/imgproc/Imgproc.html#Imgproc()">Imgproc</a></strong>()</code>&nbsp;
                </td>
            </tr>
        </table>
    </li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
    <!--   -->
</a>

<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0"
       summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
    <th class="colFirst" scope="col">Modifier and Type</th>
    <th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#accumulate(org.opencv.core.Mat, org.opencv.core.Mat)">accumulate</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Adds an image to the accumulator.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#accumulate(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">accumulate</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>

        <div class="block">Adds an image to the accumulator.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#accumulateProduct(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">accumulateProduct</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Adds the per-element product of two input images to the accumulator.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#accumulateProduct(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">accumulateProduct</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>

        <div class="block">Adds the per-element product of two input images to the accumulator.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#accumulateSquare(org.opencv.core.Mat, org.opencv.core.Mat)">accumulateSquare</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Adds the square of a source image to the accumulator.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#accumulateSquare(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">accumulateSquare</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>

        <div class="block">Adds the square of a source image to the accumulator.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#accumulateWeighted(org.opencv.core.Mat, org.opencv.core.Mat, double)">accumulateWeighted</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        double&nbsp;alpha)</code>

        <div class="block">Updates a running average.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#accumulateWeighted(org.opencv.core.Mat, org.opencv.core.Mat, double, org.opencv.core.Mat)">accumulateWeighted</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        double&nbsp;alpha,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>

        <div class="block">Updates a running average.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#adaptiveBilateralFilter(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double)">adaptiveBilateralFilter</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
        double&nbsp;sigmaSpace)</code>

        <div class="block">Applies the adaptive bilateral filter to an image.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#adaptiveBilateralFilter(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double, double, org.opencv.core.Point)">adaptiveBilateralFilter</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
        double&nbsp;sigmaSpace,
        double&nbsp;maxSigmaColor,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor)</code>

        <div class="block">Applies the adaptive bilateral filter to an image.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#adaptiveBilateralFilter(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double, double, org.opencv.core.Point, int)">adaptiveBilateralFilter</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
        double&nbsp;sigmaSpace,
        double&nbsp;maxSigmaColor,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
        int&nbsp;borderType)</code>

        <div class="block">Applies the adaptive bilateral filter to an image.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#adaptiveThreshold(org.opencv.core.Mat, org.opencv.core.Mat, double, int, int, int, double)">adaptiveThreshold</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        double&nbsp;maxValue,
        int&nbsp;adaptiveMethod,
        int&nbsp;thresholdType,
        int&nbsp;blockSize,
        double&nbsp;C)</code>

        <div class="block">Applies an adaptive threshold to an array.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#approxPolyDP(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, double, boolean)">approxPolyDP</a></strong>(<a
            href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;curve,
        <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;approxCurve,
        double&nbsp;epsilon,
        boolean&nbsp;closed)</code>

        <div class="block">Approximates a polygonal curve(s) with the specified precision.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static double</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#arcLength(org.opencv.core.MatOfPoint2f, boolean)">arcLength</a></strong>(<a
            href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;curve,
        boolean&nbsp;closed)</code>

        <div class="block">Calculates a contour perimeter or a curve length.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#bilateralFilter(org.opencv.core.Mat, org.opencv.core.Mat, int, double, double)">bilateralFilter</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;d,
        double&nbsp;sigmaColor,
        double&nbsp;sigmaSpace)</code>

        <div class="block">Applies the bilateral filter to an image.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#bilateralFilter(org.opencv.core.Mat, org.opencv.core.Mat, int, double, double, int)">bilateralFilter</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;d,
        double&nbsp;sigmaColor,
        double&nbsp;sigmaSpace,
        int&nbsp;borderType)</code>

        <div class="block">Applies the bilateral filter to an image.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#blur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size)">blur</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize)</code>

        <div class="block">Blurs an image using the normalized box filter.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#blur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Point)">blur</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor)</code>

        <div class="block">Blurs an image using the normalized box filter.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#blur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Point, int)">blur</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
        int&nbsp;borderType)</code>

        <div class="block">Blurs an image using the normalized box filter.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#borderInterpolate(int, int, int)">borderInterpolate</a></strong>(int&nbsp;p,
        int&nbsp;len,
        int&nbsp;borderType)</code>

        <div class="block">Computes the source location of an extrapolated pixel.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Rect.html"
                                         title="class in org.opencv.core">Rect</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#boundingRect(org.opencv.core.MatOfPoint)">boundingRect</a></strong>(<a
            href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;points)</code>

        <div class="block">Calculates the up-right bounding rectangle of a point set.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#boxFilter(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Size)">boxFilter</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;ddepth,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize)</code>

        <div class="block">Blurs an image using the box filter.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#boxFilter(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Size, org.opencv.core.Point, boolean)">boxFilter</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;ddepth,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
        boolean&nbsp;normalize)</code>

        <div class="block">Blurs an image using the box filter.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#boxFilter(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Size, org.opencv.core.Point, boolean, int)">boxFilter</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;ddepth,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
        boolean&nbsp;normalize,
        int&nbsp;borderType)</code>

        <div class="block">Blurs an image using the box filter.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#calcBackProject(java.util.List, org.opencv.core.MatOfInt, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfFloat, double)">calcBackProject</a></strong>(java.util.List&lt;<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;images,
        <a href="../../../org/opencv/core/MatOfInt.html"
           title="class in org.opencv.core">MatOfInt</a>&nbsp;channels,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;hist,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/MatOfFloat.html" title="class in org.opencv.core">MatOfFloat</a>&nbsp;ranges,
        double&nbsp;scale)</code>

        <div class="block">Calculates the back projection of a histogram.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#calcHist(java.util.List, org.opencv.core.MatOfInt, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfInt, org.opencv.core.MatOfFloat)">calcHist</a></strong>(java.util.List&lt;<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;images,
        <a href="../../../org/opencv/core/MatOfInt.html"
           title="class in org.opencv.core">MatOfInt</a>&nbsp;channels,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;hist,
        <a href="../../../org/opencv/core/MatOfInt.html"
           title="class in org.opencv.core">MatOfInt</a>&nbsp;histSize,
        <a href="../../../org/opencv/core/MatOfFloat.html" title="class in org.opencv.core">MatOfFloat</a>&nbsp;ranges)</code>

        <div class="block">Calculates a histogram of a set of arrays.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#calcHist(java.util.List, org.opencv.core.MatOfInt, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfInt, org.opencv.core.MatOfFloat, boolean)">calcHist</a></strong>(java.util.List&lt;<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;images,
        <a href="../../../org/opencv/core/MatOfInt.html"
           title="class in org.opencv.core">MatOfInt</a>&nbsp;channels,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;hist,
        <a href="../../../org/opencv/core/MatOfInt.html"
           title="class in org.opencv.core">MatOfInt</a>&nbsp;histSize,
        <a href="../../../org/opencv/core/MatOfFloat.html" title="class in org.opencv.core">MatOfFloat</a>&nbsp;ranges,
        boolean&nbsp;accumulate)</code>

        <div class="block">Calculates a histogram of a set of arrays.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#Canny(org.opencv.core.Mat, org.opencv.core.Mat, double, double)">Canny</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;edges,
        double&nbsp;threshold1,
        double&nbsp;threshold2)</code>

        <div class="block">Finds edges in an image using the [Canny86] algorithm.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#Canny(org.opencv.core.Mat, org.opencv.core.Mat, double, double, int, boolean)">Canny</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;edges,
        double&nbsp;threshold1,
        double&nbsp;threshold2,
        int&nbsp;apertureSize,
        boolean&nbsp;L2gradient)</code>

        <div class="block">Finds edges in an image using the [Canny86] algorithm.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static double</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#compareHist(org.opencv.core.Mat, org.opencv.core.Mat, int)">compareHist</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;H1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;H2,
        int&nbsp;method)</code>

        <div class="block">Compares two histograms.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static double</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#contourArea(org.opencv.core.Mat)">contourArea</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;contour)</code>

        <div class="block">Calculates a contour area.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static double</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#contourArea(org.opencv.core.Mat, boolean)">contourArea</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;contour,
        boolean&nbsp;oriented)</code>

        <div class="block">Calculates a contour area.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#convertMaps(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)">convertMaps</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dstmap1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dstmap2,
        int&nbsp;dstmap1type)</code>

        <div class="block">Converts image transformation maps from one representation to another.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#convertMaps(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, boolean)">convertMaps</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dstmap1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dstmap2,
        int&nbsp;dstmap1type,
        boolean&nbsp;nninterpolation)</code>

        <div class="block">Converts image transformation maps from one representation to another.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#convexHull(org.opencv.core.MatOfPoint, org.opencv.core.MatOfInt)">convexHull</a></strong>(<a
            href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;points,
        <a href="../../../org/opencv/core/MatOfInt.html"
           title="class in org.opencv.core">MatOfInt</a>&nbsp;hull)</code>

        <div class="block">Finds the convex hull of a point set.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#convexHull(org.opencv.core.MatOfPoint, org.opencv.core.MatOfInt, boolean)">convexHull</a></strong>(<a
            href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;points,
        <a href="../../../org/opencv/core/MatOfInt.html"
           title="class in org.opencv.core">MatOfInt</a>&nbsp;hull,
        boolean&nbsp;clockwise)</code>

        <div class="block">Finds the convex hull of a point set.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#convexityDefects(org.opencv.core.MatOfPoint, org.opencv.core.MatOfInt, org.opencv.core.MatOfInt4)">convexityDefects</a></strong>(<a
            href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;contour,
        <a href="../../../org/opencv/core/MatOfInt.html"
           title="class in org.opencv.core">MatOfInt</a>&nbsp;convexhull,
        <a href="../../../org/opencv/core/MatOfInt4.html"
           title="class in org.opencv.core">MatOfInt4</a>&nbsp;convexityDefects)</code>

        <div class="block">Finds the convexity defects of a contour.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#copyMakeBorder(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, int, int)">copyMakeBorder</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;top,
        int&nbsp;bottom,
        int&nbsp;left,
        int&nbsp;right,
        int&nbsp;borderType)</code>

        <div class="block">Forms a border around an image.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#copyMakeBorder(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, int, int, org.opencv.core.Scalar)">copyMakeBorder</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;top,
        int&nbsp;bottom,
        int&nbsp;left,
        int&nbsp;right,
        int&nbsp;borderType,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;value)</code>

        <div class="block">Forms a border around an image.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#cornerEigenValsAndVecs(org.opencv.core.Mat, org.opencv.core.Mat, int, int)">cornerEigenValsAndVecs</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;blockSize,
        int&nbsp;ksize)</code>

        <div class="block">Calculates eigenvalues and eigenvectors of image blocks for corner
            detection.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#cornerEigenValsAndVecs(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int)">cornerEigenValsAndVecs</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;blockSize,
        int&nbsp;ksize,
        int&nbsp;borderType)</code>

        <div class="block">Calculates eigenvalues and eigenvectors of image blocks for corner
            detection.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#cornerHarris(org.opencv.core.Mat, org.opencv.core.Mat, int, int, double)">cornerHarris</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;blockSize,
        int&nbsp;ksize,
        double&nbsp;k)</code>

        <div class="block">Harris edge detector.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#cornerHarris(org.opencv.core.Mat, org.opencv.core.Mat, int, int, double, int)">cornerHarris</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;blockSize,
        int&nbsp;ksize,
        double&nbsp;k,
        int&nbsp;borderType)</code>

        <div class="block">Harris edge detector.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#cornerMinEigenVal(org.opencv.core.Mat, org.opencv.core.Mat, int)">cornerMinEigenVal</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;blockSize)</code>

        <div class="block">Calculates the minimal eigenvalue of gradient matrices for corner
            detection.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#cornerMinEigenVal(org.opencv.core.Mat, org.opencv.core.Mat, int, int)">cornerMinEigenVal</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;blockSize,
        int&nbsp;ksize)</code>

        <div class="block">Calculates the minimal eigenvalue of gradient matrices for corner
            detection.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#cornerMinEigenVal(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int)">cornerMinEigenVal</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;blockSize,
        int&nbsp;ksize,
        int&nbsp;borderType)</code>

        <div class="block">Calculates the minimal eigenvalue of gradient matrices for corner
            detection.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#cornerSubPix(org.opencv.core.Mat, org.opencv.core.MatOfPoint2f, org.opencv.core.Size, org.opencv.core.Size, org.opencv.core.TermCriteria)">cornerSubPix</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
        <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;corners,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;winSize,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;zeroZone,
        <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria)</code>

        <div class="block">Refines the corner locations.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#createHanningWindow(org.opencv.core.Mat, org.opencv.core.Size, int)">createHanningWindow</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;winSize,
        int&nbsp;type)</code>

        <div class="block">This function computes a Hanning window coefficients in two dimensions.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#cvtColor(org.opencv.core.Mat, org.opencv.core.Mat, int)">cvtColor</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;code)</code>

        <div class="block">Converts an image from one color space to another.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#cvtColor(org.opencv.core.Mat, org.opencv.core.Mat, int, int)">cvtColor</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;code,
        int&nbsp;dstCn)</code>

        <div class="block">Converts an image from one color space to another.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#dilate(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">dilate</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel)</code>

        <div class="block">Dilates an image by using a specific structuring element.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#dilate(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, int)">dilate</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
        int&nbsp;iterations)</code>

        <div class="block">Dilates an image by using a specific structuring element.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#dilate(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, int, int, org.opencv.core.Scalar)">dilate</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
        int&nbsp;iterations,
        int&nbsp;borderType,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;borderValue)</code>

        <div class="block">Dilates an image by using a specific structuring element.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#distanceTransform(org.opencv.core.Mat, org.opencv.core.Mat, int, int)">distanceTransform</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;distanceType,
        int&nbsp;maskSize)</code>

        <div class="block">Calculates the distance to the closest zero pixel for each pixel of the
            source image.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#distanceTransformWithLabels(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int)">distanceTransformWithLabels</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;labels,
        int&nbsp;distanceType,
        int&nbsp;maskSize)</code>

        <div class="block">Calculates the distance to the closest zero pixel for each pixel of the
            source image.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#distanceTransformWithLabels(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int, int)">distanceTransformWithLabels</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;labels,
        int&nbsp;distanceType,
        int&nbsp;maskSize,
        int&nbsp;labelType)</code>

        <div class="block">Calculates the distance to the closest zero pixel for each pixel of the
            source image.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#drawContours(org.opencv.core.Mat, java.util.List, int, org.opencv.core.Scalar)">drawContours</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
        java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html"
                             title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;contours,
        int&nbsp;contourIdx,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</code>

        <div class="block">Draws contours outlines or filled contours.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#drawContours(org.opencv.core.Mat, java.util.List, int, org.opencv.core.Scalar, int)">drawContours</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
        java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html"
                             title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;contours,
        int&nbsp;contourIdx,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
        int&nbsp;thickness)</code>

        <div class="block">Draws contours outlines or filled contours.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#drawContours(org.opencv.core.Mat, java.util.List, int, org.opencv.core.Scalar, int, int, org.opencv.core.Mat, int, org.opencv.core.Point)">drawContours</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
        java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html"
                             title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;contours,
        int&nbsp;contourIdx,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
        int&nbsp;thickness,
        int&nbsp;lineType,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;hierarchy,
        int&nbsp;maxLevel,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;offset)</code>

        <div class="block">Draws contours outlines or filled contours.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#equalizeHist(org.opencv.core.Mat, org.opencv.core.Mat)">equalizeHist</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Equalizes the histogram of a grayscale image.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#erode(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">erode</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel)</code>

        <div class="block">Erodes an image by using a specific structuring element.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#erode(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, int)">erode</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
        int&nbsp;iterations)</code>

        <div class="block">Erodes an image by using a specific structuring element.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#erode(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, int, int, org.opencv.core.Scalar)">erode</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
        int&nbsp;iterations,
        int&nbsp;borderType,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;borderValue)</code>

        <div class="block">Erodes an image by using a specific structuring element.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#filter2D(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat)">filter2D</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;ddepth,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel)</code>

        <div class="block">Convolves an image with the kernel.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#filter2D(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, double)">filter2D</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;ddepth,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
        double&nbsp;delta)</code>

        <div class="block">Convolves an image with the kernel.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#filter2D(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, double, int)">filter2D</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;ddepth,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
        double&nbsp;delta,
        int&nbsp;borderType)</code>

        <div class="block">Convolves an image with the kernel.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#findContours(org.opencv.core.Mat, java.util.List, org.opencv.core.Mat, int, int)">findContours</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
        java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html"
                             title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;contours,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;hierarchy,
        int&nbsp;mode,
        int&nbsp;method)</code>

        <div class="block">Finds contours in a binary image.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#findContours(org.opencv.core.Mat, java.util.List, org.opencv.core.Mat, int, int, org.opencv.core.Point)">findContours</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
        java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html"
                             title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;contours,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;hierarchy,
        int&nbsp;mode,
        int&nbsp;method,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;offset)</code>

        <div class="block">Finds contours in a binary image.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/RotatedRect.html"
                                         title="class in org.opencv.core">RotatedRect</a></code>
    </td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#fitEllipse(org.opencv.core.MatOfPoint2f)">fitEllipse</a></strong>(<a
            href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points)</code>

        <div class="block">Fits an ellipse around a set of 2D points.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#fitLine(org.opencv.core.Mat, org.opencv.core.Mat, int, double, double, double)">fitLine</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;line,
        int&nbsp;distType,
        double&nbsp;param,
        double&nbsp;reps,
        double&nbsp;aeps)</code>

        <div class="block">Fits a line to a 2D or 3D point set.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#floodFill(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, org.opencv.core.Scalar)">floodFill</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;seedPoint,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;newVal)</code>

        <div class="block">Fills a connected component with the given color.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static int</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#floodFill(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, org.opencv.core.Scalar, org.opencv.core.Rect, org.opencv.core.Scalar, org.opencv.core.Scalar, int)">floodFill</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;seedPoint,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;newVal,
        <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;rect,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;loDiff,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;upDiff,
        int&nbsp;flags)</code>

        <div class="block">Fills a connected component with the given color.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#GaussianBlur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double)">GaussianBlur</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
        double&nbsp;sigmaX)</code>

        <div class="block">Blurs an image using a Gaussian filter.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#GaussianBlur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double, double)">GaussianBlur</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
        double&nbsp;sigmaX,
        double&nbsp;sigmaY)</code>

        <div class="block">Blurs an image using a Gaussian filter.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#GaussianBlur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double, double, int)">GaussianBlur</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
        double&nbsp;sigmaX,
        double&nbsp;sigmaY,
        int&nbsp;borderType)</code>

        <div class="block">Blurs an image using a Gaussian filter.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#getAffineTransform(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f)">getAffineTransform</a></strong>(<a
            href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;src,
        <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;dst)</code>

        <div class="block">Calculates an affine transform from three pairs of the corresponding
            points.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#getDefaultNewCameraMatrix(org.opencv.core.Mat)">getDefaultNewCameraMatrix</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix)</code>

        <div class="block">Returns the default new camera matrix.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#getDefaultNewCameraMatrix(org.opencv.core.Mat, org.opencv.core.Size, boolean)">getDefaultNewCameraMatrix</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imgsize,
        boolean&nbsp;centerPrincipalPoint)</code>

        <div class="block">Returns the default new camera matrix.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#getDerivKernels(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int)">getDerivKernels</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kx,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;ky,
        int&nbsp;dx,
        int&nbsp;dy,
        int&nbsp;ksize)</code>

        <div class="block">Returns filter coefficients for computing spatial image derivatives.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#getDerivKernels(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, boolean, int)">getDerivKernels</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kx,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;ky,
        int&nbsp;dx,
        int&nbsp;dy,
        int&nbsp;ksize,
        boolean&nbsp;normalize,
        int&nbsp;ktype)</code>

        <div class="block">Returns filter coefficients for computing spatial image derivatives.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#getGaborKernel(org.opencv.core.Size, double, double, double, double)">getGaborKernel</a></strong>(<a
            href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
        double&nbsp;sigma,
        double&nbsp;theta,
        double&nbsp;lambd,
        double&nbsp;gamma)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#getGaborKernel(org.opencv.core.Size, double, double, double, double, double, int)">getGaborKernel</a></strong>(<a
            href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
        double&nbsp;sigma,
        double&nbsp;theta,
        double&nbsp;lambd,
        double&nbsp;gamma,
        double&nbsp;psi,
        int&nbsp;ktype)</code>&nbsp;</td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#getGaussianKernel(int, double)">getGaussianKernel</a></strong>(int&nbsp;ksize,
        double&nbsp;sigma)</code>

        <div class="block">Returns Gaussian filter coefficients.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#getGaussianKernel(int, double, int)">getGaussianKernel</a></strong>(int&nbsp;ksize,
        double&nbsp;sigma,
        int&nbsp;ktype)</code>

        <div class="block">Returns Gaussian filter coefficients.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#getPerspectiveTransform(org.opencv.core.Mat, org.opencv.core.Mat)">getPerspectiveTransform</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Calculates a perspective transform from four pairs of the corresponding
            points.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#getRectSubPix(org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Point, org.opencv.core.Mat)">getRectSubPix</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;patchSize,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;patch)</code>

        <div class="block">Retrieves a pixel rectangle from an image with sub-pixel accuracy.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#getRectSubPix(org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Point, org.opencv.core.Mat, int)">getRectSubPix</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;patchSize,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;patch,
        int&nbsp;patchType)</code>

        <div class="block">Retrieves a pixel rectangle from an image with sub-pixel accuracy.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#getRotationMatrix2D(org.opencv.core.Point, double, double)">getRotationMatrix2D</a></strong>(<a
            href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
        double&nbsp;angle,
        double&nbsp;scale)</code>

        <div class="block">Calculates an affine matrix of 2D rotation.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#getStructuringElement(int, org.opencv.core.Size)">getStructuringElement</a></strong>(int&nbsp;shape,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize)</code>

        <div class="block">Returns a structuring element of the specified size and shape for
            morphological operations.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html"
                                         title="class in org.opencv.core">Mat</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#getStructuringElement(int, org.opencv.core.Size, org.opencv.core.Point)">getStructuringElement</a></strong>(int&nbsp;shape,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor)</code>

        <div class="block">Returns a structuring element of the specified size and shape for
            morphological operations.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#goodFeaturesToTrack(org.opencv.core.Mat, org.opencv.core.MatOfPoint, int, double, double)">goodFeaturesToTrack</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
        <a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;corners,
        int&nbsp;maxCorners,
        double&nbsp;qualityLevel,
        double&nbsp;minDistance)</code>

        <div class="block">Determines strong corners on an image.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#goodFeaturesToTrack(org.opencv.core.Mat, org.opencv.core.MatOfPoint, int, double, double, org.opencv.core.Mat, int, boolean, double)">goodFeaturesToTrack</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
        <a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;corners,
        int&nbsp;maxCorners,
        double&nbsp;qualityLevel,
        double&nbsp;minDistance,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
        int&nbsp;blockSize,
        boolean&nbsp;useHarrisDetector,
        double&nbsp;k)</code>

        <div class="block">Determines strong corners on an image.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#grabCut(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Rect, org.opencv.core.Mat, org.opencv.core.Mat, int)">grabCut</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
        <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;rect,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;bgdModel,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;fgdModel,
        int&nbsp;iterCount)</code>

        <div class="block">Runs the GrabCut algorithm.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#grabCut(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Rect, org.opencv.core.Mat, org.opencv.core.Mat, int, int)">grabCut</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
        <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;rect,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;bgdModel,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;fgdModel,
        int&nbsp;iterCount,
        int&nbsp;mode)</code>

        <div class="block">Runs the GrabCut algorithm.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#HoughCircles(org.opencv.core.Mat, org.opencv.core.Mat, int, double, double)">HoughCircles</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;circles,
        int&nbsp;method,
        double&nbsp;dp,
        double&nbsp;minDist)</code>

        <div class="block">Finds circles in a grayscale image using the Hough transform.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#HoughCircles(org.opencv.core.Mat, org.opencv.core.Mat, int, double, double, double, double, int, int)">HoughCircles</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;circles,
        int&nbsp;method,
        double&nbsp;dp,
        double&nbsp;minDist,
        double&nbsp;param1,
        double&nbsp;param2,
        int&nbsp;minRadius,
        int&nbsp;maxRadius)</code>

        <div class="block">Finds circles in a grayscale image using the Hough transform.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#HoughLines(org.opencv.core.Mat, org.opencv.core.Mat, double, double, int)">HoughLines</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines,
        double&nbsp;rho,
        double&nbsp;theta,
        int&nbsp;threshold)</code>

        <div class="block">Finds lines in a binary image using the standard Hough transform.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#HoughLines(org.opencv.core.Mat, org.opencv.core.Mat, double, double, int, double, double)">HoughLines</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines,
        double&nbsp;rho,
        double&nbsp;theta,
        int&nbsp;threshold,
        double&nbsp;srn,
        double&nbsp;stn)</code>

        <div class="block">Finds lines in a binary image using the standard Hough transform.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#HoughLinesP(org.opencv.core.Mat, org.opencv.core.Mat, double, double, int)">HoughLinesP</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines,
        double&nbsp;rho,
        double&nbsp;theta,
        int&nbsp;threshold)</code>

        <div class="block">Finds line segments in a binary image using the probabilistic Hough
            transform.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#HoughLinesP(org.opencv.core.Mat, org.opencv.core.Mat, double, double, int, double, double)">HoughLinesP</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines,
        double&nbsp;rho,
        double&nbsp;theta,
        int&nbsp;threshold,
        double&nbsp;minLineLength,
        double&nbsp;maxLineGap)</code>

        <div class="block">Finds line segments in a binary image using the probabilistic Hough
            transform.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#HuMoments(org.opencv.imgproc.Moments, org.opencv.core.Mat)">HuMoments</a></strong>(<a
            href="../../../org/opencv/imgproc/Moments.html" title="class in org.opencv.imgproc">Moments</a>&nbsp;m,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;hu)</code>

        <div class="block">Calculates seven Hu invariants.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#initUndistortRectifyMap(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, org.opencv.core.Mat, org.opencv.core.Mat)">initUndistortRectifyMap</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;newCameraMatrix,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;size,
        int&nbsp;m1type,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map2)</code>

        <div class="block">Computes the undistortion and rectification transformation map.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static float</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#initWideAngleProjMap(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int, org.opencv.core.Mat, org.opencv.core.Mat)">initWideAngleProjMap</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imageSize,
        int&nbsp;destImageWidth,
        int&nbsp;m1type,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map2)</code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static float</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#initWideAngleProjMap(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int, org.opencv.core.Mat, org.opencv.core.Mat, int, double)">initWideAngleProjMap</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;imageSize,
        int&nbsp;destImageWidth,
        int&nbsp;m1type,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map2,
        int&nbsp;projType,
        double&nbsp;alpha)</code>&nbsp;</td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#integral(org.opencv.core.Mat, org.opencv.core.Mat)">integral</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sum)</code>

        <div class="block">Calculates the integral of an image.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#integral(org.opencv.core.Mat, org.opencv.core.Mat, int)">integral</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sum,
        int&nbsp;sdepth)</code>

        <div class="block">Calculates the integral of an image.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#integral2(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">integral2</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sum,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sqsum)</code>

        <div class="block">Calculates the integral of an image.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#integral2(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)">integral2</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sum,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sqsum,
        int&nbsp;sdepth)</code>

        <div class="block">Calculates the integral of an image.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#integral3(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">integral3</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sum,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sqsum,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tilted)</code>

        <div class="block">Calculates the integral of an image.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#integral3(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)">integral3</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sum,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sqsum,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tilted,
        int&nbsp;sdepth)</code>

        <div class="block">Calculates the integral of an image.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static float</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#intersectConvexConvex(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">intersectConvexConvex</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;_p1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;_p2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;_p12)</code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static float</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#intersectConvexConvex(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)">intersectConvexConvex</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;_p1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;_p2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;_p12,
        boolean&nbsp;handleNested)</code>&nbsp;</td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#invertAffineTransform(org.opencv.core.Mat, org.opencv.core.Mat)">invertAffineTransform</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;M,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;iM)</code>

        <div class="block">Inverts an affine transformation.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static boolean</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#isContourConvex(org.opencv.core.MatOfPoint)">isContourConvex</a></strong>(<a
            href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;contour)</code>

        <div class="block">Tests a contour convexity.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#Laplacian(org.opencv.core.Mat, org.opencv.core.Mat, int)">Laplacian</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;ddepth)</code>

        <div class="block">Calculates the Laplacian of an image.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#Laplacian(org.opencv.core.Mat, org.opencv.core.Mat, int, int, double, double)">Laplacian</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;ddepth,
        int&nbsp;ksize,
        double&nbsp;scale,
        double&nbsp;delta)</code>

        <div class="block">Calculates the Laplacian of an image.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#Laplacian(org.opencv.core.Mat, org.opencv.core.Mat, int, int, double, double, int)">Laplacian</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;ddepth,
        int&nbsp;ksize,
        double&nbsp;scale,
        double&nbsp;delta,
        int&nbsp;borderType)</code>

        <div class="block">Calculates the Laplacian of an image.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static double</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#matchShapes(org.opencv.core.Mat, org.opencv.core.Mat, int, double)">matchShapes</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;contour1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;contour2,
        int&nbsp;method,
        double&nbsp;parameter)</code>

        <div class="block">Compares two shapes.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#matchTemplate(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)">matchTemplate</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;templ,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;result,
        int&nbsp;method)</code>

        <div class="block">Compares a template against overlapped image regions.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#medianBlur(org.opencv.core.Mat, org.opencv.core.Mat, int)">medianBlur</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;ksize)</code>

        <div class="block">Blurs an image using the median filter.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/RotatedRect.html"
                                         title="class in org.opencv.core">RotatedRect</a></code>
    </td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#minAreaRect(org.opencv.core.MatOfPoint2f)">minAreaRect</a></strong>(<a
            href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points)</code>

        <div class="block">Finds a rotated rectangle of the minimum area enclosing the input 2D
            point
            set.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#minEnclosingCircle(org.opencv.core.MatOfPoint2f, org.opencv.core.Point, float[])">minEnclosingCircle</a></strong>(<a
            href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
        float[]&nbsp;radius)</code>

        <div class="block">Finds a circle of the minimum area enclosing a 2D point set.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/imgproc/Moments.html"
                                         title="class in org.opencv.imgproc">Moments</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#moments(org.opencv.core.Mat)">moments</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;array)</code>

        <div class="block">Calculates all of the moments up to the third order of a polygon or
            rasterized shape.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/imgproc/Moments.html"
                                         title="class in org.opencv.imgproc">Moments</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#moments(org.opencv.core.Mat, boolean)">moments</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;array,
        boolean&nbsp;binaryImage)</code>

        <div class="block">Calculates all of the moments up to the third order of a polygon or
            rasterized shape.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#morphologyEx(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat)">morphologyEx</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;op,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel)</code>

        <div class="block">Performs advanced morphological transformations.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#morphologyEx(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, int)">morphologyEx</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;op,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
        int&nbsp;iterations)</code>

        <div class="block">Performs advanced morphological transformations.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#morphologyEx(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, int, int, org.opencv.core.Scalar)">morphologyEx</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;op,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
        int&nbsp;iterations,
        int&nbsp;borderType,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;borderValue)</code>

        <div class="block">Performs advanced morphological transformations.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Point.html"
                                         title="class in org.opencv.core">Point</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#phaseCorrelate(org.opencv.core.Mat, org.opencv.core.Mat)">phaseCorrelate</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2)</code>

        <div class="block">The function is used to detect translational shifts that occur between
            two
            images.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Point.html"
                                         title="class in org.opencv.core">Point</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#phaseCorrelate(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">phaseCorrelate</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;window)</code>

        <div class="block">The function is used to detect translational shifts that occur between
            two
            images.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Point.html"
                                         title="class in org.opencv.core">Point</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#phaseCorrelateRes(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">phaseCorrelateRes</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;window)</code>&nbsp;
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static <a href="../../../org/opencv/core/Point.html"
                                         title="class in org.opencv.core">Point</a></code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#phaseCorrelateRes(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double[])">phaseCorrelateRes</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;window,
        double[]&nbsp;response)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static double</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#pointPolygonTest(org.opencv.core.MatOfPoint2f, org.opencv.core.Point, boolean)">pointPolygonTest</a></strong>(<a
            href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;contour,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt,
        boolean&nbsp;measureDist)</code>

        <div class="block">Performs a point-in-contour test.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#preCornerDetect(org.opencv.core.Mat, org.opencv.core.Mat, int)">preCornerDetect</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;ksize)</code>

        <div class="block">Calculates a feature map for corner detection.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#preCornerDetect(org.opencv.core.Mat, org.opencv.core.Mat, int, int)">preCornerDetect</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;ksize,
        int&nbsp;borderType)</code>

        <div class="block">Calculates a feature map for corner detection.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static double</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#PSNR(org.opencv.core.Mat, org.opencv.core.Mat)">PSNR</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2)</code>&nbsp;
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#pyrDown(org.opencv.core.Mat, org.opencv.core.Mat)">pyrDown</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Blurs an image and downsamples it.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#pyrDown(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size)">pyrDown</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dstsize)</code>

        <div class="block">Blurs an image and downsamples it.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#pyrDown(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int)">pyrDown</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dstsize,
        int&nbsp;borderType)</code>

        <div class="block">Blurs an image and downsamples it.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#pyrMeanShiftFiltering(org.opencv.core.Mat, org.opencv.core.Mat, double, double)">pyrMeanShiftFiltering</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        double&nbsp;sp,
        double&nbsp;sr)</code>

        <div class="block">Performs initial step of meanshift segmentation of an image.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#pyrMeanShiftFiltering(org.opencv.core.Mat, org.opencv.core.Mat, double, double, int, org.opencv.core.TermCriteria)">pyrMeanShiftFiltering</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        double&nbsp;sp,
        double&nbsp;sr,
        int&nbsp;maxLevel,
        <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;termcrit)</code>

        <div class="block">Performs initial step of meanshift segmentation of an image.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#pyrUp(org.opencv.core.Mat, org.opencv.core.Mat)">pyrUp</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>

        <div class="block">Upsamples an image and then blurs it.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#pyrUp(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size)">pyrUp</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dstsize)</code>

        <div class="block">Upsamples an image and then blurs it.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#pyrUp(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int)">pyrUp</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dstsize,
        int&nbsp;borderType)</code>

        <div class="block">Upsamples an image and then blurs it.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#remap(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)">remap</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map2,
        int&nbsp;interpolation)</code>

        <div class="block">Applies a generic geometrical transformation to an image.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#remap(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int, org.opencv.core.Scalar)">remap</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map2,
        int&nbsp;interpolation,
        int&nbsp;borderMode,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;borderValue)</code>

        <div class="block">Applies a generic geometrical transformation to an image.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#resize(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size)">resize</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize)</code>

        <div class="block">Resizes an image.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#resize(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double, double, int)">resize</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize,
        double&nbsp;fx,
        double&nbsp;fy,
        int&nbsp;interpolation)</code>

        <div class="block">Resizes an image.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#Scharr(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int)">Scharr</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;ddepth,
        int&nbsp;dx,
        int&nbsp;dy)</code>

        <div class="block">Calculates the first x- or y- image derivative using Scharr operator.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#Scharr(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, double, double)">Scharr</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;ddepth,
        int&nbsp;dx,
        int&nbsp;dy,
        double&nbsp;scale,
        double&nbsp;delta)</code>

        <div class="block">Calculates the first x- or y- image derivative using Scharr operator.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#Scharr(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, double, double, int)">Scharr</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;ddepth,
        int&nbsp;dx,
        int&nbsp;dy,
        double&nbsp;scale,
        double&nbsp;delta,
        int&nbsp;borderType)</code>

        <div class="block">Calculates the first x- or y- image derivative using Scharr operator.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#sepFilter2D(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Mat)">sepFilter2D</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;ddepth,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernelX,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernelY)</code>

        <div class="block">Applies a separable linear filter to an image.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#sepFilter2D(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, double)">sepFilter2D</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;ddepth,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernelX,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernelY,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
        double&nbsp;delta)</code>

        <div class="block">Applies a separable linear filter to an image.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#sepFilter2D(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, double, int)">sepFilter2D</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;ddepth,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernelX,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernelY,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
        double&nbsp;delta,
        int&nbsp;borderType)</code>

        <div class="block">Applies a separable linear filter to an image.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#Sobel(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int)">Sobel</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;ddepth,
        int&nbsp;dx,
        int&nbsp;dy)</code>

        <div class="block">Calculates the first, second, third, or mixed image derivatives using an
            extended Sobel operator.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#Sobel(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, int, double, double)">Sobel</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;ddepth,
        int&nbsp;dx,
        int&nbsp;dy,
        int&nbsp;ksize,
        double&nbsp;scale,
        double&nbsp;delta)</code>

        <div class="block">Calculates the first, second, third, or mixed image derivatives using an
            extended Sobel operator.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#Sobel(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, int, double, double, int)">Sobel</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;ddepth,
        int&nbsp;dx,
        int&nbsp;dy,
        int&nbsp;ksize,
        double&nbsp;scale,
        double&nbsp;delta,
        int&nbsp;borderType)</code>

        <div class="block">Calculates the first, second, third, or mixed image derivatives using an
            extended Sobel operator.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static double</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#threshold(org.opencv.core.Mat, org.opencv.core.Mat, double, double, int)">threshold</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        double&nbsp;thresh,
        double&nbsp;maxval,
        int&nbsp;type)</code>

        <div class="block">Applies a fixed-level threshold to each array element.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#undistort(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">undistort</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs)</code>

        <div class="block">Transforms an image to compensate for lens distortion.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#undistort(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">undistort</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;newCameraMatrix)</code>

        <div class="block">Transforms an image to compensate for lens distortion.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#undistortPoints(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, org.opencv.core.Mat, org.opencv.core.Mat)">undistortPoints</a></strong>(<a
            href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;src,
        <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs)</code>

        <div class="block">Computes the ideal point coordinates from the observed point
            coordinates.
        </div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#undistortPoints(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">undistortPoints</a></strong>(<a
            href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;src,
        <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;R,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;P)</code>

        <div class="block">Computes the ideal point coordinates from the observed point
            coordinates.
        </div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#warpAffine(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size)">warpAffine</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;M,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize)</code>

        <div class="block">Applies an affine transformation to an image.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#warpAffine(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int)">warpAffine</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;M,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize,
        int&nbsp;flags)</code>

        <div class="block">Applies an affine transformation to an image.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#warpAffine(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int, org.opencv.core.Scalar)">warpAffine</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;M,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize,
        int&nbsp;flags,
        int&nbsp;borderMode,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;borderValue)</code>

        <div class="block">Applies an affine transformation to an image.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#warpPerspective(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size)">warpPerspective</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;M,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize)</code>

        <div class="block">Applies a perspective transformation to an image.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#warpPerspective(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int)">warpPerspective</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;M,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize,
        int&nbsp;flags)</code>

        <div class="block">Applies a perspective transformation to an image.</div>
    </td>
</tr>
<tr class="altColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#warpPerspective(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int, org.opencv.core.Scalar)">warpPerspective</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;M,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize,
        int&nbsp;flags,
        int&nbsp;borderMode,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;borderValue)</code>

        <div class="block">Applies a perspective transformation to an image.</div>
    </td>
</tr>
<tr class="rowColor">
    <td class="colFirst"><code>static void</code></td>
    <td class="colLast"><code><strong><a
            href="../../../org/opencv/imgproc/Imgproc.html#watershed(org.opencv.core.Mat, org.opencv.core.Mat)">watershed</a></strong>(<a
            href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;markers)</code>

        <div class="block">Performs a marker-based image segmentation using the watershed
            algorithm.
        </div>
    </td>
</tr>
</table>
<ul class="blockList">
    <li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
        <!--   -->
    </a>

        <h3>Methods inherited from class&nbsp;java.lang.Object</h3>
        <code>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_detail">
    <!--   -->
</a>

<h3>Field Detail</h3>
<a name="ADAPTIVE_THRESH_GAUSSIAN_C">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>ADAPTIVE_THRESH_GAUSSIAN_C</h4>
        <pre>public static final&nbsp;int ADAPTIVE_THRESH_GAUSSIAN_C</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.ADAPTIVE_THRESH_GAUSSIAN_C">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="ADAPTIVE_THRESH_MEAN_C">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>ADAPTIVE_THRESH_MEAN_C</h4>
        <pre>public static final&nbsp;int ADAPTIVE_THRESH_MEAN_C</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.ADAPTIVE_THRESH_MEAN_C">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="BORDER_CONSTANT">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>BORDER_CONSTANT</h4>
        <pre>public static final&nbsp;int BORDER_CONSTANT</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.BORDER_CONSTANT">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="BORDER_DEFAULT">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>BORDER_DEFAULT</h4>
        <pre>public static final&nbsp;int BORDER_DEFAULT</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.BORDER_DEFAULT">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="BORDER_ISOLATED">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>BORDER_ISOLATED</h4>
        <pre>public static final&nbsp;int BORDER_ISOLATED</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.BORDER_ISOLATED">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="BORDER_REFLECT">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>BORDER_REFLECT</h4>
        <pre>public static final&nbsp;int BORDER_REFLECT</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.BORDER_REFLECT">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="BORDER_REFLECT_101">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>BORDER_REFLECT_101</h4>
        <pre>public static final&nbsp;int BORDER_REFLECT_101</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.BORDER_REFLECT_101">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="BORDER_REFLECT101">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>BORDER_REFLECT101</h4>
        <pre>public static final&nbsp;int BORDER_REFLECT101</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.BORDER_REFLECT101">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="BORDER_REPLICATE">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>BORDER_REPLICATE</h4>
        <pre>public static final&nbsp;int BORDER_REPLICATE</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.BORDER_REPLICATE">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="BORDER_TRANSPARENT">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>BORDER_TRANSPARENT</h4>
        <pre>public static final&nbsp;int BORDER_TRANSPARENT</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.BORDER_TRANSPARENT">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="BORDER_WRAP">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>BORDER_WRAP</h4>
        <pre>public static final&nbsp;int BORDER_WRAP</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.BORDER_WRAP">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CHAIN_APPROX_NONE">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CHAIN_APPROX_NONE</h4>
        <pre>public static final&nbsp;int CHAIN_APPROX_NONE</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CHAIN_APPROX_NONE">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CHAIN_APPROX_SIMPLE">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CHAIN_APPROX_SIMPLE</h4>
        <pre>public static final&nbsp;int CHAIN_APPROX_SIMPLE</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CHAIN_APPROX_SIMPLE">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CHAIN_APPROX_TC89_KCOS">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CHAIN_APPROX_TC89_KCOS</h4>
        <pre>public static final&nbsp;int CHAIN_APPROX_TC89_KCOS</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CHAIN_APPROX_TC89_KCOS">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CHAIN_APPROX_TC89_L1">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CHAIN_APPROX_TC89_L1</h4>
        <pre>public static final&nbsp;int CHAIN_APPROX_TC89_L1</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CHAIN_APPROX_TC89_L1">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BayerBG2BGR">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BayerBG2BGR</h4>
        <pre>public static final&nbsp;int COLOR_BayerBG2BGR</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerBG2BGR">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BayerBG2BGR_VNG">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BayerBG2BGR_VNG</h4>
        <pre>public static final&nbsp;int COLOR_BayerBG2BGR_VNG</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerBG2BGR_VNG">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BayerBG2GRAY">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BayerBG2GRAY</h4>
        <pre>public static final&nbsp;int COLOR_BayerBG2GRAY</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerBG2GRAY">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BayerBG2RGB">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BayerBG2RGB</h4>
        <pre>public static final&nbsp;int COLOR_BayerBG2RGB</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerBG2RGB">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BayerBG2RGB_VNG">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BayerBG2RGB_VNG</h4>
        <pre>public static final&nbsp;int COLOR_BayerBG2RGB_VNG</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerBG2RGB_VNG">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BayerGB2BGR">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BayerGB2BGR</h4>
        <pre>public static final&nbsp;int COLOR_BayerGB2BGR</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGB2BGR">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BayerGB2BGR_VNG">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BayerGB2BGR_VNG</h4>
        <pre>public static final&nbsp;int COLOR_BayerGB2BGR_VNG</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGB2BGR_VNG">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BayerGB2GRAY">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BayerGB2GRAY</h4>
        <pre>public static final&nbsp;int COLOR_BayerGB2GRAY</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGB2GRAY">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BayerGB2RGB">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BayerGB2RGB</h4>
        <pre>public static final&nbsp;int COLOR_BayerGB2RGB</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGB2RGB">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BayerGB2RGB_VNG">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BayerGB2RGB_VNG</h4>
        <pre>public static final&nbsp;int COLOR_BayerGB2RGB_VNG</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGB2RGB_VNG">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BayerGR2BGR">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BayerGR2BGR</h4>
        <pre>public static final&nbsp;int COLOR_BayerGR2BGR</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGR2BGR">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BayerGR2BGR_VNG">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BayerGR2BGR_VNG</h4>
        <pre>public static final&nbsp;int COLOR_BayerGR2BGR_VNG</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGR2BGR_VNG">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BayerGR2GRAY">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BayerGR2GRAY</h4>
        <pre>public static final&nbsp;int COLOR_BayerGR2GRAY</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGR2GRAY">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BayerGR2RGB">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BayerGR2RGB</h4>
        <pre>public static final&nbsp;int COLOR_BayerGR2RGB</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGR2RGB">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BayerGR2RGB_VNG">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BayerGR2RGB_VNG</h4>
        <pre>public static final&nbsp;int COLOR_BayerGR2RGB_VNG</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGR2RGB_VNG">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BayerRG2BGR">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BayerRG2BGR</h4>
        <pre>public static final&nbsp;int COLOR_BayerRG2BGR</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerRG2BGR">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BayerRG2BGR_VNG">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BayerRG2BGR_VNG</h4>
        <pre>public static final&nbsp;int COLOR_BayerRG2BGR_VNG</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerRG2BGR_VNG">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BayerRG2GRAY">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BayerRG2GRAY</h4>
        <pre>public static final&nbsp;int COLOR_BayerRG2GRAY</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerRG2GRAY">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BayerRG2RGB">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BayerRG2RGB</h4>
        <pre>public static final&nbsp;int COLOR_BayerRG2RGB</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerRG2RGB">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BayerRG2RGB_VNG">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BayerRG2RGB_VNG</h4>
        <pre>public static final&nbsp;int COLOR_BayerRG2RGB_VNG</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerRG2RGB_VNG">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGR2BGR555">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGR2BGR555</h4>
        <pre>public static final&nbsp;int COLOR_BGR2BGR555</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR2BGR555">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGR2BGR565">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGR2BGR565</h4>
        <pre>public static final&nbsp;int COLOR_BGR2BGR565</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR2BGR565">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGR2BGRA">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGR2BGRA</h4>
        <pre>public static final&nbsp;int COLOR_BGR2BGRA</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR2BGRA">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGR2GRAY">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGR2GRAY</h4>
        <pre>public static final&nbsp;int COLOR_BGR2GRAY</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR2GRAY">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGR2HLS">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGR2HLS</h4>
        <pre>public static final&nbsp;int COLOR_BGR2HLS</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR2HLS">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGR2HLS_FULL">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGR2HLS_FULL</h4>
        <pre>public static final&nbsp;int COLOR_BGR2HLS_FULL</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR2HLS_FULL">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGR2HSV">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGR2HSV</h4>
        <pre>public static final&nbsp;int COLOR_BGR2HSV</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR2HSV">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGR2HSV_FULL">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGR2HSV_FULL</h4>
        <pre>public static final&nbsp;int COLOR_BGR2HSV_FULL</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR2HSV_FULL">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGR2Lab">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGR2Lab</h4>
        <pre>public static final&nbsp;int COLOR_BGR2Lab</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR2Lab">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGR2Luv">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGR2Luv</h4>
        <pre>public static final&nbsp;int COLOR_BGR2Luv</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR2Luv">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGR2RGB">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGR2RGB</h4>
        <pre>public static final&nbsp;int COLOR_BGR2RGB</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR2RGB">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGR2RGBA">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGR2RGBA</h4>
        <pre>public static final&nbsp;int COLOR_BGR2RGBA</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR2RGBA">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGR2XYZ">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGR2XYZ</h4>
        <pre>public static final&nbsp;int COLOR_BGR2XYZ</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR2XYZ">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGR2YCrCb">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGR2YCrCb</h4>
        <pre>public static final&nbsp;int COLOR_BGR2YCrCb</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR2YCrCb">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGR2YUV">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGR2YUV</h4>
        <pre>public static final&nbsp;int COLOR_BGR2YUV</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR2YUV">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGR2YUV_I420">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGR2YUV_I420</h4>
        <pre>public static final&nbsp;int COLOR_BGR2YUV_I420</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR2YUV_I420">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGR2YUV_IYUV">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGR2YUV_IYUV</h4>
        <pre>public static final&nbsp;int COLOR_BGR2YUV_IYUV</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR2YUV_IYUV">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGR2YUV_YV12">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGR2YUV_YV12</h4>
        <pre>public static final&nbsp;int COLOR_BGR2YUV_YV12</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR2YUV_YV12">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGR5552BGR">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGR5552BGR</h4>
        <pre>public static final&nbsp;int COLOR_BGR5552BGR</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR5552BGR">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGR5552BGRA">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGR5552BGRA</h4>
        <pre>public static final&nbsp;int COLOR_BGR5552BGRA</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR5552BGRA">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGR5552GRAY">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGR5552GRAY</h4>
        <pre>public static final&nbsp;int COLOR_BGR5552GRAY</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR5552GRAY">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGR5552RGB">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGR5552RGB</h4>
        <pre>public static final&nbsp;int COLOR_BGR5552RGB</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR5552RGB">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGR5552RGBA">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGR5552RGBA</h4>
        <pre>public static final&nbsp;int COLOR_BGR5552RGBA</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR5552RGBA">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGR5652BGR">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGR5652BGR</h4>
        <pre>public static final&nbsp;int COLOR_BGR5652BGR</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR5652BGR">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGR5652BGRA">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGR5652BGRA</h4>
        <pre>public static final&nbsp;int COLOR_BGR5652BGRA</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR5652BGRA">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGR5652GRAY">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGR5652GRAY</h4>
        <pre>public static final&nbsp;int COLOR_BGR5652GRAY</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR5652GRAY">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGR5652RGB">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGR5652RGB</h4>
        <pre>public static final&nbsp;int COLOR_BGR5652RGB</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR5652RGB">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGR5652RGBA">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGR5652RGBA</h4>
        <pre>public static final&nbsp;int COLOR_BGR5652RGBA</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR5652RGBA">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGRA2BGR">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGRA2BGR</h4>
        <pre>public static final&nbsp;int COLOR_BGRA2BGR</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGRA2BGR">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGRA2BGR555">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGRA2BGR555</h4>
        <pre>public static final&nbsp;int COLOR_BGRA2BGR555</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGRA2BGR555">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGRA2BGR565">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGRA2BGR565</h4>
        <pre>public static final&nbsp;int COLOR_BGRA2BGR565</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGRA2BGR565">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGRA2GRAY">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGRA2GRAY</h4>
        <pre>public static final&nbsp;int COLOR_BGRA2GRAY</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGRA2GRAY">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGRA2RGB">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGRA2RGB</h4>
        <pre>public static final&nbsp;int COLOR_BGRA2RGB</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGRA2RGB">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGRA2RGBA">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGRA2RGBA</h4>
        <pre>public static final&nbsp;int COLOR_BGRA2RGBA</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGRA2RGBA">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGRA2YUV_I420">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGRA2YUV_I420</h4>
        <pre>public static final&nbsp;int COLOR_BGRA2YUV_I420</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGRA2YUV_I420">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGRA2YUV_IYUV">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGRA2YUV_IYUV</h4>
        <pre>public static final&nbsp;int COLOR_BGRA2YUV_IYUV</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGRA2YUV_IYUV">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_BGRA2YUV_YV12">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_BGRA2YUV_YV12</h4>
        <pre>public static final&nbsp;int COLOR_BGRA2YUV_YV12</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGRA2YUV_YV12">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_COLORCVT_MAX">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_COLORCVT_MAX</h4>
        <pre>public static final&nbsp;int COLOR_COLORCVT_MAX</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_COLORCVT_MAX">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_GRAY2BGR">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_GRAY2BGR</h4>
        <pre>public static final&nbsp;int COLOR_GRAY2BGR</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_GRAY2BGR">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_GRAY2BGR555">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_GRAY2BGR555</h4>
        <pre>public static final&nbsp;int COLOR_GRAY2BGR555</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_GRAY2BGR555">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_GRAY2BGR565">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_GRAY2BGR565</h4>
        <pre>public static final&nbsp;int COLOR_GRAY2BGR565</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_GRAY2BGR565">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_GRAY2BGRA">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_GRAY2BGRA</h4>
        <pre>public static final&nbsp;int COLOR_GRAY2BGRA</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_GRAY2BGRA">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_GRAY2RGB">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_GRAY2RGB</h4>
        <pre>public static final&nbsp;int COLOR_GRAY2RGB</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_GRAY2RGB">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_GRAY2RGBA">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_GRAY2RGBA</h4>
        <pre>public static final&nbsp;int COLOR_GRAY2RGBA</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_GRAY2RGBA">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_HLS2BGR">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_HLS2BGR</h4>
        <pre>public static final&nbsp;int COLOR_HLS2BGR</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_HLS2BGR">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_HLS2BGR_FULL">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_HLS2BGR_FULL</h4>
        <pre>public static final&nbsp;int COLOR_HLS2BGR_FULL</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_HLS2BGR_FULL">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_HLS2RGB">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_HLS2RGB</h4>
        <pre>public static final&nbsp;int COLOR_HLS2RGB</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_HLS2RGB">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_HLS2RGB_FULL">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_HLS2RGB_FULL</h4>
        <pre>public static final&nbsp;int COLOR_HLS2RGB_FULL</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_HLS2RGB_FULL">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_HSV2BGR">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_HSV2BGR</h4>
        <pre>public static final&nbsp;int COLOR_HSV2BGR</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_HSV2BGR">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_HSV2BGR_FULL">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_HSV2BGR_FULL</h4>
        <pre>public static final&nbsp;int COLOR_HSV2BGR_FULL</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_HSV2BGR_FULL">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_HSV2RGB">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_HSV2RGB</h4>
        <pre>public static final&nbsp;int COLOR_HSV2RGB</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_HSV2RGB">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_HSV2RGB_FULL">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_HSV2RGB_FULL</h4>
        <pre>public static final&nbsp;int COLOR_HSV2RGB_FULL</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_HSV2RGB_FULL">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_Lab2BGR">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_Lab2BGR</h4>
        <pre>public static final&nbsp;int COLOR_Lab2BGR</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_Lab2BGR">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_Lab2LBGR">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_Lab2LBGR</h4>
        <pre>public static final&nbsp;int COLOR_Lab2LBGR</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_Lab2LBGR">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_Lab2LRGB">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_Lab2LRGB</h4>
        <pre>public static final&nbsp;int COLOR_Lab2LRGB</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_Lab2LRGB">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_Lab2RGB">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_Lab2RGB</h4>
        <pre>public static final&nbsp;int COLOR_Lab2RGB</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_Lab2RGB">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_LBGR2Lab">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_LBGR2Lab</h4>
        <pre>public static final&nbsp;int COLOR_LBGR2Lab</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_LBGR2Lab">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_LBGR2Luv">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_LBGR2Luv</h4>
        <pre>public static final&nbsp;int COLOR_LBGR2Luv</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_LBGR2Luv">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_LRGB2Lab">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_LRGB2Lab</h4>
        <pre>public static final&nbsp;int COLOR_LRGB2Lab</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_LRGB2Lab">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_LRGB2Luv">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_LRGB2Luv</h4>
        <pre>public static final&nbsp;int COLOR_LRGB2Luv</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_LRGB2Luv">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_Luv2BGR">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_Luv2BGR</h4>
        <pre>public static final&nbsp;int COLOR_Luv2BGR</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_Luv2BGR">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_Luv2LBGR">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_Luv2LBGR</h4>
        <pre>public static final&nbsp;int COLOR_Luv2LBGR</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_Luv2LBGR">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_Luv2LRGB">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_Luv2LRGB</h4>
        <pre>public static final&nbsp;int COLOR_Luv2LRGB</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_Luv2LRGB">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_Luv2RGB">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_Luv2RGB</h4>
        <pre>public static final&nbsp;int COLOR_Luv2RGB</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_Luv2RGB">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_mRGBA2RGBA">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_mRGBA2RGBA</h4>
        <pre>public static final&nbsp;int COLOR_mRGBA2RGBA</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_mRGBA2RGBA">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_RGB2BGR">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_RGB2BGR</h4>
        <pre>public static final&nbsp;int COLOR_RGB2BGR</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGB2BGR">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_RGB2BGR555">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_RGB2BGR555</h4>
        <pre>public static final&nbsp;int COLOR_RGB2BGR555</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGB2BGR555">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_RGB2BGR565">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_RGB2BGR565</h4>
        <pre>public static final&nbsp;int COLOR_RGB2BGR565</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGB2BGR565">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_RGB2BGRA">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_RGB2BGRA</h4>
        <pre>public static final&nbsp;int COLOR_RGB2BGRA</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGB2BGRA">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_RGB2GRAY">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_RGB2GRAY</h4>
        <pre>public static final&nbsp;int COLOR_RGB2GRAY</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGB2GRAY">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_RGB2HLS">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_RGB2HLS</h4>
        <pre>public static final&nbsp;int COLOR_RGB2HLS</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGB2HLS">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_RGB2HLS_FULL">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_RGB2HLS_FULL</h4>
        <pre>public static final&nbsp;int COLOR_RGB2HLS_FULL</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGB2HLS_FULL">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_RGB2HSV">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_RGB2HSV</h4>
        <pre>public static final&nbsp;int COLOR_RGB2HSV</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGB2HSV">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_RGB2HSV_FULL">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_RGB2HSV_FULL</h4>
        <pre>public static final&nbsp;int COLOR_RGB2HSV_FULL</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGB2HSV_FULL">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_RGB2Lab">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_RGB2Lab</h4>
        <pre>public static final&nbsp;int COLOR_RGB2Lab</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGB2Lab">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_RGB2Luv">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_RGB2Luv</h4>
        <pre>public static final&nbsp;int COLOR_RGB2Luv</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGB2Luv">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_RGB2RGBA">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_RGB2RGBA</h4>
        <pre>public static final&nbsp;int COLOR_RGB2RGBA</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGB2RGBA">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_RGB2XYZ">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_RGB2XYZ</h4>
        <pre>public static final&nbsp;int COLOR_RGB2XYZ</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGB2XYZ">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_RGB2YCrCb">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_RGB2YCrCb</h4>
        <pre>public static final&nbsp;int COLOR_RGB2YCrCb</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGB2YCrCb">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_RGB2YUV">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_RGB2YUV</h4>
        <pre>public static final&nbsp;int COLOR_RGB2YUV</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGB2YUV">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_RGB2YUV_I420">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_RGB2YUV_I420</h4>
        <pre>public static final&nbsp;int COLOR_RGB2YUV_I420</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGB2YUV_I420">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_RGB2YUV_IYUV">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_RGB2YUV_IYUV</h4>
        <pre>public static final&nbsp;int COLOR_RGB2YUV_IYUV</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGB2YUV_IYUV">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_RGB2YUV_YV12">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_RGB2YUV_YV12</h4>
        <pre>public static final&nbsp;int COLOR_RGB2YUV_YV12</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGB2YUV_YV12">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_RGBA2BGR">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_RGBA2BGR</h4>
        <pre>public static final&nbsp;int COLOR_RGBA2BGR</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGBA2BGR">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_RGBA2BGR555">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_RGBA2BGR555</h4>
        <pre>public static final&nbsp;int COLOR_RGBA2BGR555</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGBA2BGR555">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_RGBA2BGR565">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_RGBA2BGR565</h4>
        <pre>public static final&nbsp;int COLOR_RGBA2BGR565</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGBA2BGR565">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_RGBA2BGRA">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_RGBA2BGRA</h4>
        <pre>public static final&nbsp;int COLOR_RGBA2BGRA</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGBA2BGRA">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_RGBA2GRAY">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_RGBA2GRAY</h4>
        <pre>public static final&nbsp;int COLOR_RGBA2GRAY</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGBA2GRAY">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_RGBA2mRGBA">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_RGBA2mRGBA</h4>
        <pre>public static final&nbsp;int COLOR_RGBA2mRGBA</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGBA2mRGBA">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_RGBA2RGB">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_RGBA2RGB</h4>
        <pre>public static final&nbsp;int COLOR_RGBA2RGB</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGBA2RGB">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_RGBA2YUV_I420">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_RGBA2YUV_I420</h4>
        <pre>public static final&nbsp;int COLOR_RGBA2YUV_I420</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGBA2YUV_I420">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_RGBA2YUV_IYUV">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_RGBA2YUV_IYUV</h4>
        <pre>public static final&nbsp;int COLOR_RGBA2YUV_IYUV</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGBA2YUV_IYUV">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_RGBA2YUV_YV12">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_RGBA2YUV_YV12</h4>
        <pre>public static final&nbsp;int COLOR_RGBA2YUV_YV12</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGBA2YUV_YV12">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_XYZ2BGR">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_XYZ2BGR</h4>
        <pre>public static final&nbsp;int COLOR_XYZ2BGR</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_XYZ2BGR">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_XYZ2RGB">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_XYZ2RGB</h4>
        <pre>public static final&nbsp;int COLOR_XYZ2RGB</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_XYZ2RGB">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YCrCb2BGR">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YCrCb2BGR</h4>
        <pre>public static final&nbsp;int COLOR_YCrCb2BGR</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YCrCb2BGR">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YCrCb2RGB">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YCrCb2RGB</h4>
        <pre>public static final&nbsp;int COLOR_YCrCb2RGB</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YCrCb2RGB">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2BGR">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2BGR</h4>
        <pre>public static final&nbsp;int COLOR_YUV2BGR</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGR">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2BGR_I420">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2BGR_I420</h4>
        <pre>public static final&nbsp;int COLOR_YUV2BGR_I420</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGR_I420">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2BGR_IYUV">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2BGR_IYUV</h4>
        <pre>public static final&nbsp;int COLOR_YUV2BGR_IYUV</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGR_IYUV">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2BGR_NV12">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2BGR_NV12</h4>
        <pre>public static final&nbsp;int COLOR_YUV2BGR_NV12</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGR_NV12">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2BGR_NV21">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2BGR_NV21</h4>
        <pre>public static final&nbsp;int COLOR_YUV2BGR_NV21</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGR_NV21">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2BGR_UYNV">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2BGR_UYNV</h4>
        <pre>public static final&nbsp;int COLOR_YUV2BGR_UYNV</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGR_UYNV">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2BGR_UYVY">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2BGR_UYVY</h4>
        <pre>public static final&nbsp;int COLOR_YUV2BGR_UYVY</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGR_UYVY">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2BGR_Y422">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2BGR_Y422</h4>
        <pre>public static final&nbsp;int COLOR_YUV2BGR_Y422</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGR_Y422">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2BGR_YUNV">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2BGR_YUNV</h4>
        <pre>public static final&nbsp;int COLOR_YUV2BGR_YUNV</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGR_YUNV">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2BGR_YUY2">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2BGR_YUY2</h4>
        <pre>public static final&nbsp;int COLOR_YUV2BGR_YUY2</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGR_YUY2">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2BGR_YUYV">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2BGR_YUYV</h4>
        <pre>public static final&nbsp;int COLOR_YUV2BGR_YUYV</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGR_YUYV">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2BGR_YV12">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2BGR_YV12</h4>
        <pre>public static final&nbsp;int COLOR_YUV2BGR_YV12</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGR_YV12">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2BGR_YVYU">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2BGR_YVYU</h4>
        <pre>public static final&nbsp;int COLOR_YUV2BGR_YVYU</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGR_YVYU">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2BGRA_I420">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2BGRA_I420</h4>
        <pre>public static final&nbsp;int COLOR_YUV2BGRA_I420</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGRA_I420">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2BGRA_IYUV">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2BGRA_IYUV</h4>
        <pre>public static final&nbsp;int COLOR_YUV2BGRA_IYUV</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGRA_IYUV">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2BGRA_NV12">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2BGRA_NV12</h4>
        <pre>public static final&nbsp;int COLOR_YUV2BGRA_NV12</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGRA_NV12">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2BGRA_NV21">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2BGRA_NV21</h4>
        <pre>public static final&nbsp;int COLOR_YUV2BGRA_NV21</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGRA_NV21">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2BGRA_UYNV">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2BGRA_UYNV</h4>
        <pre>public static final&nbsp;int COLOR_YUV2BGRA_UYNV</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGRA_UYNV">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2BGRA_UYVY">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2BGRA_UYVY</h4>
        <pre>public static final&nbsp;int COLOR_YUV2BGRA_UYVY</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGRA_UYVY">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2BGRA_Y422">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2BGRA_Y422</h4>
        <pre>public static final&nbsp;int COLOR_YUV2BGRA_Y422</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGRA_Y422">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2BGRA_YUNV">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2BGRA_YUNV</h4>
        <pre>public static final&nbsp;int COLOR_YUV2BGRA_YUNV</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGRA_YUNV">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2BGRA_YUY2">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2BGRA_YUY2</h4>
        <pre>public static final&nbsp;int COLOR_YUV2BGRA_YUY2</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGRA_YUY2">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2BGRA_YUYV">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2BGRA_YUYV</h4>
        <pre>public static final&nbsp;int COLOR_YUV2BGRA_YUYV</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGRA_YUYV">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2BGRA_YV12">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2BGRA_YV12</h4>
        <pre>public static final&nbsp;int COLOR_YUV2BGRA_YV12</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGRA_YV12">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2BGRA_YVYU">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2BGRA_YVYU</h4>
        <pre>public static final&nbsp;int COLOR_YUV2BGRA_YVYU</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGRA_YVYU">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2GRAY_420">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2GRAY_420</h4>
        <pre>public static final&nbsp;int COLOR_YUV2GRAY_420</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2GRAY_420">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2GRAY_I420">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2GRAY_I420</h4>
        <pre>public static final&nbsp;int COLOR_YUV2GRAY_I420</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2GRAY_I420">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2GRAY_IYUV">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2GRAY_IYUV</h4>
        <pre>public static final&nbsp;int COLOR_YUV2GRAY_IYUV</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2GRAY_IYUV">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2GRAY_NV12">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2GRAY_NV12</h4>
        <pre>public static final&nbsp;int COLOR_YUV2GRAY_NV12</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2GRAY_NV12">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2GRAY_NV21">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2GRAY_NV21</h4>
        <pre>public static final&nbsp;int COLOR_YUV2GRAY_NV21</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2GRAY_NV21">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2GRAY_UYNV">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2GRAY_UYNV</h4>
        <pre>public static final&nbsp;int COLOR_YUV2GRAY_UYNV</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2GRAY_UYNV">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2GRAY_UYVY">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2GRAY_UYVY</h4>
        <pre>public static final&nbsp;int COLOR_YUV2GRAY_UYVY</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2GRAY_UYVY">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2GRAY_Y422">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2GRAY_Y422</h4>
        <pre>public static final&nbsp;int COLOR_YUV2GRAY_Y422</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2GRAY_Y422">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2GRAY_YUNV">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2GRAY_YUNV</h4>
        <pre>public static final&nbsp;int COLOR_YUV2GRAY_YUNV</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2GRAY_YUNV">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2GRAY_YUY2">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2GRAY_YUY2</h4>
        <pre>public static final&nbsp;int COLOR_YUV2GRAY_YUY2</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2GRAY_YUY2">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2GRAY_YUYV">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2GRAY_YUYV</h4>
        <pre>public static final&nbsp;int COLOR_YUV2GRAY_YUYV</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2GRAY_YUYV">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2GRAY_YV12">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2GRAY_YV12</h4>
        <pre>public static final&nbsp;int COLOR_YUV2GRAY_YV12</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2GRAY_YV12">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2GRAY_YVYU">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2GRAY_YVYU</h4>
        <pre>public static final&nbsp;int COLOR_YUV2GRAY_YVYU</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2GRAY_YVYU">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2RGB">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2RGB</h4>
        <pre>public static final&nbsp;int COLOR_YUV2RGB</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGB">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2RGB_I420">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2RGB_I420</h4>
        <pre>public static final&nbsp;int COLOR_YUV2RGB_I420</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGB_I420">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2RGB_IYUV">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2RGB_IYUV</h4>
        <pre>public static final&nbsp;int COLOR_YUV2RGB_IYUV</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGB_IYUV">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2RGB_NV12">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2RGB_NV12</h4>
        <pre>public static final&nbsp;int COLOR_YUV2RGB_NV12</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGB_NV12">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2RGB_NV21">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2RGB_NV21</h4>
        <pre>public static final&nbsp;int COLOR_YUV2RGB_NV21</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGB_NV21">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2RGB_UYNV">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2RGB_UYNV</h4>
        <pre>public static final&nbsp;int COLOR_YUV2RGB_UYNV</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGB_UYNV">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2RGB_UYVY">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2RGB_UYVY</h4>
        <pre>public static final&nbsp;int COLOR_YUV2RGB_UYVY</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGB_UYVY">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2RGB_Y422">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2RGB_Y422</h4>
        <pre>public static final&nbsp;int COLOR_YUV2RGB_Y422</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGB_Y422">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2RGB_YUNV">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2RGB_YUNV</h4>
        <pre>public static final&nbsp;int COLOR_YUV2RGB_YUNV</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGB_YUNV">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2RGB_YUY2">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2RGB_YUY2</h4>
        <pre>public static final&nbsp;int COLOR_YUV2RGB_YUY2</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGB_YUY2">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2RGB_YUYV">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2RGB_YUYV</h4>
        <pre>public static final&nbsp;int COLOR_YUV2RGB_YUYV</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGB_YUYV">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2RGB_YV12">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2RGB_YV12</h4>
        <pre>public static final&nbsp;int COLOR_YUV2RGB_YV12</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGB_YV12">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2RGB_YVYU">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2RGB_YVYU</h4>
        <pre>public static final&nbsp;int COLOR_YUV2RGB_YVYU</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGB_YVYU">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2RGBA_I420">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2RGBA_I420</h4>
        <pre>public static final&nbsp;int COLOR_YUV2RGBA_I420</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGBA_I420">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2RGBA_IYUV">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2RGBA_IYUV</h4>
        <pre>public static final&nbsp;int COLOR_YUV2RGBA_IYUV</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGBA_IYUV">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2RGBA_NV12">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2RGBA_NV12</h4>
        <pre>public static final&nbsp;int COLOR_YUV2RGBA_NV12</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGBA_NV12">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2RGBA_NV21">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2RGBA_NV21</h4>
        <pre>public static final&nbsp;int COLOR_YUV2RGBA_NV21</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGBA_NV21">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2RGBA_UYNV">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2RGBA_UYNV</h4>
        <pre>public static final&nbsp;int COLOR_YUV2RGBA_UYNV</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGBA_UYNV">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2RGBA_UYVY">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2RGBA_UYVY</h4>
        <pre>public static final&nbsp;int COLOR_YUV2RGBA_UYVY</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGBA_UYVY">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2RGBA_Y422">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2RGBA_Y422</h4>
        <pre>public static final&nbsp;int COLOR_YUV2RGBA_Y422</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGBA_Y422">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2RGBA_YUNV">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2RGBA_YUNV</h4>
        <pre>public static final&nbsp;int COLOR_YUV2RGBA_YUNV</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGBA_YUNV">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2RGBA_YUY2">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2RGBA_YUY2</h4>
        <pre>public static final&nbsp;int COLOR_YUV2RGBA_YUY2</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGBA_YUY2">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2RGBA_YUYV">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2RGBA_YUYV</h4>
        <pre>public static final&nbsp;int COLOR_YUV2RGBA_YUYV</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGBA_YUYV">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2RGBA_YV12">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2RGBA_YV12</h4>
        <pre>public static final&nbsp;int COLOR_YUV2RGBA_YV12</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGBA_YV12">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV2RGBA_YVYU">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV2RGBA_YVYU</h4>
        <pre>public static final&nbsp;int COLOR_YUV2RGBA_YVYU</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGBA_YVYU">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV420p2BGR">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV420p2BGR</h4>
        <pre>public static final&nbsp;int COLOR_YUV420p2BGR</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV420p2BGR">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV420p2BGRA">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV420p2BGRA</h4>
        <pre>public static final&nbsp;int COLOR_YUV420p2BGRA</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV420p2BGRA">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV420p2GRAY">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV420p2GRAY</h4>
        <pre>public static final&nbsp;int COLOR_YUV420p2GRAY</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV420p2GRAY">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV420p2RGB">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV420p2RGB</h4>
        <pre>public static final&nbsp;int COLOR_YUV420p2RGB</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV420p2RGB">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV420p2RGBA">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV420p2RGBA</h4>
        <pre>public static final&nbsp;int COLOR_YUV420p2RGBA</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV420p2RGBA">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV420sp2BGR">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV420sp2BGR</h4>
        <pre>public static final&nbsp;int COLOR_YUV420sp2BGR</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV420sp2BGR">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV420sp2BGRA">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV420sp2BGRA</h4>
        <pre>public static final&nbsp;int COLOR_YUV420sp2BGRA</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV420sp2BGRA">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV420sp2GRAY">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV420sp2GRAY</h4>
        <pre>public static final&nbsp;int COLOR_YUV420sp2GRAY</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV420sp2GRAY">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV420sp2RGB">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV420sp2RGB</h4>
        <pre>public static final&nbsp;int COLOR_YUV420sp2RGB</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV420sp2RGB">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="COLOR_YUV420sp2RGBA">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>COLOR_YUV420sp2RGBA</h4>
        <pre>public static final&nbsp;int COLOR_YUV420sp2RGBA</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV420sp2RGBA">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_BILATERAL">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_BILATERAL</h4>
        <pre>public static final&nbsp;int CV_BILATERAL</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_BILATERAL">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_BLUR">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_BLUR</h4>
        <pre>public static final&nbsp;int CV_BLUR</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_BLUR">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_BLUR_NO_SCALE">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_BLUR_NO_SCALE</h4>
        <pre>public static final&nbsp;int CV_BLUR_NO_SCALE</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_BLUR_NO_SCALE">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_CANNY_L2_GRADIENT">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_CANNY_L2_GRADIENT</h4>
        <pre>public static final&nbsp;int CV_CANNY_L2_GRADIENT</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_CANNY_L2_GRADIENT">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_CHAIN_CODE">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_CHAIN_CODE</h4>
        <pre>public static final&nbsp;int CV_CHAIN_CODE</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_CHAIN_CODE">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_CLOCKWISE">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_CLOCKWISE</h4>
        <pre>public static final&nbsp;int CV_CLOCKWISE</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_CLOCKWISE">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_COMP_BHATTACHARYYA">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_COMP_BHATTACHARYYA</h4>
        <pre>public static final&nbsp;int CV_COMP_BHATTACHARYYA</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_COMP_BHATTACHARYYA">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_COMP_CHISQR">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_COMP_CHISQR</h4>
        <pre>public static final&nbsp;int CV_COMP_CHISQR</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_COMP_CHISQR">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_COMP_CORREL">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_COMP_CORREL</h4>
        <pre>public static final&nbsp;int CV_COMP_CORREL</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_COMP_CORREL">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_COMP_HELLINGER">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_COMP_HELLINGER</h4>
        <pre>public static final&nbsp;int CV_COMP_HELLINGER</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_COMP_HELLINGER">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_COMP_INTERSECT">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_COMP_INTERSECT</h4>
        <pre>public static final&nbsp;int CV_COMP_INTERSECT</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_COMP_INTERSECT">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_CONTOURS_MATCH_I1">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_CONTOURS_MATCH_I1</h4>
        <pre>public static final&nbsp;int CV_CONTOURS_MATCH_I1</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_CONTOURS_MATCH_I1">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_CONTOURS_MATCH_I2">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_CONTOURS_MATCH_I2</h4>
        <pre>public static final&nbsp;int CV_CONTOURS_MATCH_I2</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_CONTOURS_MATCH_I2">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_CONTOURS_MATCH_I3">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_CONTOURS_MATCH_I3</h4>
        <pre>public static final&nbsp;int CV_CONTOURS_MATCH_I3</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_CONTOURS_MATCH_I3">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_COUNTER_CLOCKWISE">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_COUNTER_CLOCKWISE</h4>
        <pre>public static final&nbsp;int CV_COUNTER_CLOCKWISE</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_COUNTER_CLOCKWISE">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_DIST_C">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_DIST_C</h4>
        <pre>public static final&nbsp;int CV_DIST_C</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_DIST_C">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_DIST_FAIR">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_DIST_FAIR</h4>
        <pre>public static final&nbsp;int CV_DIST_FAIR</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_DIST_FAIR">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_DIST_HUBER">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_DIST_HUBER</h4>
        <pre>public static final&nbsp;int CV_DIST_HUBER</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_DIST_HUBER">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_DIST_L1">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_DIST_L1</h4>
        <pre>public static final&nbsp;int CV_DIST_L1</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_DIST_L1">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_DIST_L12">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_DIST_L12</h4>
        <pre>public static final&nbsp;int CV_DIST_L12</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_DIST_L12">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_DIST_L2">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_DIST_L2</h4>
        <pre>public static final&nbsp;int CV_DIST_L2</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_DIST_L2">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_DIST_LABEL_CCOMP">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_DIST_LABEL_CCOMP</h4>
        <pre>public static final&nbsp;int CV_DIST_LABEL_CCOMP</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_DIST_LABEL_CCOMP">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_DIST_LABEL_PIXEL">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_DIST_LABEL_PIXEL</h4>
        <pre>public static final&nbsp;int CV_DIST_LABEL_PIXEL</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_DIST_LABEL_PIXEL">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_DIST_MASK_3">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_DIST_MASK_3</h4>
        <pre>public static final&nbsp;int CV_DIST_MASK_3</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_DIST_MASK_3">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_DIST_MASK_5">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_DIST_MASK_5</h4>
        <pre>public static final&nbsp;int CV_DIST_MASK_5</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_DIST_MASK_5">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_DIST_MASK_PRECISE">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_DIST_MASK_PRECISE</h4>
        <pre>public static final&nbsp;int CV_DIST_MASK_PRECISE</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_DIST_MASK_PRECISE">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_DIST_USER">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_DIST_USER</h4>
        <pre>public static final&nbsp;int CV_DIST_USER</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_DIST_USER">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_DIST_WELSCH">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_DIST_WELSCH</h4>
        <pre>public static final&nbsp;int CV_DIST_WELSCH</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_DIST_WELSCH">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_GAUSSIAN">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_GAUSSIAN</h4>
        <pre>public static final&nbsp;int CV_GAUSSIAN</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_GAUSSIAN">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_GAUSSIAN_5x5">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_GAUSSIAN_5x5</h4>
        <pre>public static final&nbsp;int CV_GAUSSIAN_5x5</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_GAUSSIAN_5x5">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_HOUGH_GRADIENT">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_HOUGH_GRADIENT</h4>
        <pre>public static final&nbsp;int CV_HOUGH_GRADIENT</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_HOUGH_GRADIENT">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_HOUGH_MULTI_SCALE">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_HOUGH_MULTI_SCALE</h4>
        <pre>public static final&nbsp;int CV_HOUGH_MULTI_SCALE</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_HOUGH_MULTI_SCALE">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_HOUGH_PROBABILISTIC">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_HOUGH_PROBABILISTIC</h4>
        <pre>public static final&nbsp;int CV_HOUGH_PROBABILISTIC</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_HOUGH_PROBABILISTIC">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_HOUGH_STANDARD">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_HOUGH_STANDARD</h4>
        <pre>public static final&nbsp;int CV_HOUGH_STANDARD</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_HOUGH_STANDARD">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_LINK_RUNS">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_LINK_RUNS</h4>
        <pre>public static final&nbsp;int CV_LINK_RUNS</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_LINK_RUNS">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_MAX_SOBEL_KSIZE">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_MAX_SOBEL_KSIZE</h4>
        <pre>public static final&nbsp;int CV_MAX_SOBEL_KSIZE</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_MAX_SOBEL_KSIZE">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_MEDIAN">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_MEDIAN</h4>
        <pre>public static final&nbsp;int CV_MEDIAN</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_MEDIAN">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_mRGBA2RGBA">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_mRGBA2RGBA</h4>
        <pre>public static final&nbsp;int CV_mRGBA2RGBA</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_mRGBA2RGBA">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_POLY_APPROX_DP">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_POLY_APPROX_DP</h4>
        <pre>public static final&nbsp;int CV_POLY_APPROX_DP</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_POLY_APPROX_DP">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_RGBA2mRGBA">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_RGBA2mRGBA</h4>
        <pre>public static final&nbsp;int CV_RGBA2mRGBA</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_RGBA2mRGBA">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_SCHARR">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_SCHARR</h4>
        <pre>public static final&nbsp;int CV_SCHARR</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_SCHARR">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_SHAPE_CROSS">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_SHAPE_CROSS</h4>
        <pre>public static final&nbsp;int CV_SHAPE_CROSS</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_SHAPE_CROSS">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_SHAPE_CUSTOM">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_SHAPE_CUSTOM</h4>
        <pre>public static final&nbsp;int CV_SHAPE_CUSTOM</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_SHAPE_CUSTOM">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_SHAPE_ELLIPSE">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_SHAPE_ELLIPSE</h4>
        <pre>public static final&nbsp;int CV_SHAPE_ELLIPSE</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_SHAPE_ELLIPSE">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_SHAPE_RECT">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_SHAPE_RECT</h4>
        <pre>public static final&nbsp;int CV_SHAPE_RECT</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_SHAPE_RECT">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_WARP_FILL_OUTLIERS">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_WARP_FILL_OUTLIERS</h4>
        <pre>public static final&nbsp;int CV_WARP_FILL_OUTLIERS</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_WARP_FILL_OUTLIERS">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="CV_WARP_INVERSE_MAP">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>CV_WARP_INVERSE_MAP</h4>
        <pre>public static final&nbsp;int CV_WARP_INVERSE_MAP</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_WARP_INVERSE_MAP">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="DIST_LABEL_CCOMP">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>DIST_LABEL_CCOMP</h4>
        <pre>public static final&nbsp;int DIST_LABEL_CCOMP</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.DIST_LABEL_CCOMP">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="DIST_LABEL_PIXEL">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>DIST_LABEL_PIXEL</h4>
        <pre>public static final&nbsp;int DIST_LABEL_PIXEL</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.DIST_LABEL_PIXEL">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="FLOODFILL_FIXED_RANGE">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>FLOODFILL_FIXED_RANGE</h4>
        <pre>public static final&nbsp;int FLOODFILL_FIXED_RANGE</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.FLOODFILL_FIXED_RANGE">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="FLOODFILL_MASK_ONLY">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>FLOODFILL_MASK_ONLY</h4>
        <pre>public static final&nbsp;int FLOODFILL_MASK_ONLY</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.FLOODFILL_MASK_ONLY">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="GC_BGD">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>GC_BGD</h4>
        <pre>public static final&nbsp;int GC_BGD</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.GC_BGD">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="GC_EVAL">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>GC_EVAL</h4>
        <pre>public static final&nbsp;int GC_EVAL</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.GC_EVAL">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="GC_FGD">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>GC_FGD</h4>
        <pre>public static final&nbsp;int GC_FGD</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.GC_FGD">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="GC_INIT_WITH_MASK">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>GC_INIT_WITH_MASK</h4>
        <pre>public static final&nbsp;int GC_INIT_WITH_MASK</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.GC_INIT_WITH_MASK">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="GC_INIT_WITH_RECT">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>GC_INIT_WITH_RECT</h4>
        <pre>public static final&nbsp;int GC_INIT_WITH_RECT</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.GC_INIT_WITH_RECT">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="GC_PR_BGD">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>GC_PR_BGD</h4>
        <pre>public static final&nbsp;int GC_PR_BGD</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.GC_PR_BGD">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="GC_PR_FGD">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>GC_PR_FGD</h4>
        <pre>public static final&nbsp;int GC_PR_FGD</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.GC_PR_FGD">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="GHT_POSITION">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>GHT_POSITION</h4>
        <pre>public static final&nbsp;int GHT_POSITION</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.GHT_POSITION">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="GHT_ROTATION">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>GHT_ROTATION</h4>
        <pre>public static final&nbsp;int GHT_ROTATION</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.GHT_ROTATION">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="GHT_SCALE">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>GHT_SCALE</h4>
        <pre>public static final&nbsp;int GHT_SCALE</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.GHT_SCALE">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="INTER_AREA">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>INTER_AREA</h4>
        <pre>public static final&nbsp;int INTER_AREA</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.INTER_AREA">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="INTER_BITS">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>INTER_BITS</h4>
        <pre>public static final&nbsp;int INTER_BITS</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.INTER_BITS">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="INTER_BITS2">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>INTER_BITS2</h4>
        <pre>public static final&nbsp;int INTER_BITS2</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.INTER_BITS2">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="INTER_CUBIC">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>INTER_CUBIC</h4>
        <pre>public static final&nbsp;int INTER_CUBIC</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.INTER_CUBIC">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="INTER_LANCZOS4">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>INTER_LANCZOS4</h4>
        <pre>public static final&nbsp;int INTER_LANCZOS4</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.INTER_LANCZOS4">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="INTER_LINEAR">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>INTER_LINEAR</h4>
        <pre>public static final&nbsp;int INTER_LINEAR</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.INTER_LINEAR">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="INTER_MAX">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>INTER_MAX</h4>
        <pre>public static final&nbsp;int INTER_MAX</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.INTER_MAX">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="INTER_NEAREST">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>INTER_NEAREST</h4>
        <pre>public static final&nbsp;int INTER_NEAREST</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.INTER_NEAREST">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="INTER_TAB_SIZE">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>INTER_TAB_SIZE</h4>
        <pre>public static final&nbsp;int INTER_TAB_SIZE</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.INTER_TAB_SIZE">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="INTER_TAB_SIZE2">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>INTER_TAB_SIZE2</h4>
        <pre>public static final&nbsp;int INTER_TAB_SIZE2</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.INTER_TAB_SIZE2">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="KERNEL_ASYMMETRICAL">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>KERNEL_ASYMMETRICAL</h4>
        <pre>public static final&nbsp;int KERNEL_ASYMMETRICAL</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.KERNEL_ASYMMETRICAL">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="KERNEL_GENERAL">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>KERNEL_GENERAL</h4>
        <pre>public static final&nbsp;int KERNEL_GENERAL</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.KERNEL_GENERAL">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="KERNEL_INTEGER">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>KERNEL_INTEGER</h4>
        <pre>public static final&nbsp;int KERNEL_INTEGER</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.KERNEL_INTEGER">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="KERNEL_SMOOTH">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>KERNEL_SMOOTH</h4>
        <pre>public static final&nbsp;int KERNEL_SMOOTH</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.KERNEL_SMOOTH">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="KERNEL_SYMMETRICAL">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>KERNEL_SYMMETRICAL</h4>
        <pre>public static final&nbsp;int KERNEL_SYMMETRICAL</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.KERNEL_SYMMETRICAL">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="MORPH_BLACKHAT">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>MORPH_BLACKHAT</h4>
        <pre>public static final&nbsp;int MORPH_BLACKHAT</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.MORPH_BLACKHAT">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="MORPH_CLOSE">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>MORPH_CLOSE</h4>
        <pre>public static final&nbsp;int MORPH_CLOSE</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.MORPH_CLOSE">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="MORPH_CROSS">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>MORPH_CROSS</h4>
        <pre>public static final&nbsp;int MORPH_CROSS</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.MORPH_CROSS">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="MORPH_DILATE">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>MORPH_DILATE</h4>
        <pre>public static final&nbsp;int MORPH_DILATE</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.MORPH_DILATE">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="MORPH_ELLIPSE">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>MORPH_ELLIPSE</h4>
        <pre>public static final&nbsp;int MORPH_ELLIPSE</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.MORPH_ELLIPSE">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="MORPH_ERODE">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>MORPH_ERODE</h4>
        <pre>public static final&nbsp;int MORPH_ERODE</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.MORPH_ERODE">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="MORPH_GRADIENT">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>MORPH_GRADIENT</h4>
        <pre>public static final&nbsp;int MORPH_GRADIENT</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.MORPH_GRADIENT">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="MORPH_OPEN">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>MORPH_OPEN</h4>
        <pre>public static final&nbsp;int MORPH_OPEN</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.MORPH_OPEN">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="MORPH_RECT">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>MORPH_RECT</h4>
        <pre>public static final&nbsp;int MORPH_RECT</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.MORPH_RECT">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="MORPH_TOPHAT">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>MORPH_TOPHAT</h4>
        <pre>public static final&nbsp;int MORPH_TOPHAT</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.MORPH_TOPHAT">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="PROJ_SPHERICAL_EQRECT">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>PROJ_SPHERICAL_EQRECT</h4>
        <pre>public static final&nbsp;int PROJ_SPHERICAL_EQRECT</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.PROJ_SPHERICAL_EQRECT">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="PROJ_SPHERICAL_ORTHO">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>PROJ_SPHERICAL_ORTHO</h4>
        <pre>public static final&nbsp;int PROJ_SPHERICAL_ORTHO</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.PROJ_SPHERICAL_ORTHO">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="RETR_CCOMP">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>RETR_CCOMP</h4>
        <pre>public static final&nbsp;int RETR_CCOMP</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.RETR_CCOMP">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="RETR_EXTERNAL">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>RETR_EXTERNAL</h4>
        <pre>public static final&nbsp;int RETR_EXTERNAL</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.RETR_EXTERNAL">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="RETR_FLOODFILL">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>RETR_FLOODFILL</h4>
        <pre>public static final&nbsp;int RETR_FLOODFILL</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.RETR_FLOODFILL">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="RETR_LIST">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>RETR_LIST</h4>
        <pre>public static final&nbsp;int RETR_LIST</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.RETR_LIST">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="RETR_TREE">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>RETR_TREE</h4>
        <pre>public static final&nbsp;int RETR_TREE</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.RETR_TREE">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="THRESH_BINARY">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>THRESH_BINARY</h4>
        <pre>public static final&nbsp;int THRESH_BINARY</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.THRESH_BINARY">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="THRESH_BINARY_INV">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>THRESH_BINARY_INV</h4>
        <pre>public static final&nbsp;int THRESH_BINARY_INV</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.THRESH_BINARY_INV">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="THRESH_MASK">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>THRESH_MASK</h4>
        <pre>public static final&nbsp;int THRESH_MASK</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.THRESH_MASK">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="THRESH_OTSU">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>THRESH_OTSU</h4>
        <pre>public static final&nbsp;int THRESH_OTSU</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.THRESH_OTSU">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="THRESH_TOZERO">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>THRESH_TOZERO</h4>
        <pre>public static final&nbsp;int THRESH_TOZERO</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.THRESH_TOZERO">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="THRESH_TOZERO_INV">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>THRESH_TOZERO_INV</h4>
        <pre>public static final&nbsp;int THRESH_TOZERO_INV</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.THRESH_TOZERO_INV">Constant
                    Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="THRESH_TRUNC">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>THRESH_TRUNC</h4>
        <pre>public static final&nbsp;int THRESH_TRUNC</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.THRESH_TRUNC">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="TM_CCOEFF">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>TM_CCOEFF</h4>
        <pre>public static final&nbsp;int TM_CCOEFF</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.TM_CCOEFF">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="TM_CCOEFF_NORMED">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>TM_CCOEFF_NORMED</h4>
        <pre>public static final&nbsp;int TM_CCOEFF_NORMED</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.TM_CCOEFF_NORMED">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="TM_CCORR">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>TM_CCORR</h4>
        <pre>public static final&nbsp;int TM_CCORR</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.TM_CCORR">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="TM_CCORR_NORMED">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>TM_CCORR_NORMED</h4>
        <pre>public static final&nbsp;int TM_CCORR_NORMED</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.TM_CCORR_NORMED">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="TM_SQDIFF">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>TM_SQDIFF</h4>
        <pre>public static final&nbsp;int TM_SQDIFF</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.TM_SQDIFF">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="TM_SQDIFF_NORMED">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>TM_SQDIFF_NORMED</h4>
        <pre>public static final&nbsp;int TM_SQDIFF_NORMED</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.TM_SQDIFF_NORMED">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
<a name="WARP_INVERSE_MAP">
    <!--   -->
</a>
<ul class="blockListLast">
    <li class="blockList">
        <h4>WARP_INVERSE_MAP</h4>
        <pre>public static final&nbsp;int WARP_INVERSE_MAP</pre>
        <dl>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.WARP_INVERSE_MAP">Constant
                Field Values</a></dd>
        </dl>
    </li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
    <li class="blockList"><a name="constructor_detail">
        <!--   -->
    </a>

        <h3>Constructor Detail</h3>
        <a name="Imgproc()">
            <!--   -->
        </a>
        <ul class="blockListLast">
            <li class="blockList">
                <h4>Imgproc</h4>
                <pre>public&nbsp;Imgproc()</pre>
            </li>
        </ul>
    </li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
    <!--   -->
</a>

<h3>Method Detail</h3>
<a name="accumulate(org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>accumulate</h4>
<pre>public static&nbsp;void&nbsp;accumulate(<a href="../../../org/opencv/core/Mat.html"
                                                title="class in org.opencv.core">Mat</a>&nbsp;src,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Adds an image to the accumulator.</p>

            <p>The function adds <code>src</code> or some of its elements to
                <code>dst</code> :</p>

            <p><em>dst(x,y) <- dst(x,y) + src(x,y) if mask(x,y) != 0</em></p>

            <p>The function supports multi-channel images. Each channel is processed
                independently.</p>

            <p>The functions <code>accumulate*</code> can be used, for example, to collect
                statistics of a scene background viewed by a still camera and for the further
                foreground-background segmentation.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Input image as 1- or 3-channel, 8-bit or 32-bit floating point.
            </dd>
            <dd><code>dst</code> - Accumulator image with the same number of channels as input
                image,
                32-bit or 64-bit floating-point.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/motion_analysis_and_object_tracking.html#accumulate">org.opencv.imgproc.Imgproc.accumulate</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulateWeighted(org.opencv.core.Mat, org.opencv.core.Mat, double, org.opencv.core.Mat)"><code>accumulateWeighted(org.opencv.core.Mat,
                    org.opencv.core.Mat, double, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulateProduct(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>accumulateProduct(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulateSquare(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>accumulateSquare(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="accumulate(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>accumulate</h4>
<pre>public static&nbsp;void&nbsp;accumulate(<a href="../../../org/opencv/core/Mat.html"
                                                title="class in org.opencv.core">Mat</a>&nbsp;src,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
        <div class="block"><p>Adds an image to the accumulator.</p>

            <p>The function adds <code>src</code> or some of its elements to
                <code>dst</code> :</p>

            <p><em>dst(x,y) <- dst(x,y) + src(x,y) if mask(x,y) != 0</em></p>

            <p>The function supports multi-channel images. Each channel is processed
                independently.</p>

            <p>The functions <code>accumulate*</code> can be used, for example, to collect
                statistics of a scene background viewed by a still camera and for the further
                foreground-background segmentation.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Input image as 1- or 3-channel, 8-bit or 32-bit floating point.
            </dd>
            <dd><code>dst</code> - Accumulator image with the same number of channels as input
                image,
                32-bit or 64-bit floating-point.
            </dd>
            <dd><code>mask</code> - Optional operation mask.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/motion_analysis_and_object_tracking.html#accumulate">org.opencv.imgproc.Imgproc.accumulate</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulateWeighted(org.opencv.core.Mat, org.opencv.core.Mat, double, org.opencv.core.Mat)"><code>accumulateWeighted(org.opencv.core.Mat,
                    org.opencv.core.Mat, double, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulateProduct(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>accumulateProduct(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulateSquare(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>accumulateSquare(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="accumulateProduct(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>accumulateProduct</h4>
<pre>public static&nbsp;void&nbsp;accumulateProduct(<a href="../../../org/opencv/core/Mat.html"
                                                       title="class in org.opencv.core">Mat</a>&nbsp;src1,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Adds the per-element product of two input images to the
            accumulator.</p>

            <p>The function adds the product of two images or their selected regions to the
                accumulator <code>dst</code> :</p>

            <p><em>dst(x,y) <- dst(x,y) + src1(x,y) * src2(x,y) if mask(x,y) != 0</em></p>

            <p>The function supports multi-channel images. Each channel is processed
                independently.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - First input image, 1- or 3-channel, 8-bit or 32-bit floating
                point.
            </dd>
            <dd><code>src2</code> - Second input image of the same type and the same size as
                <code>src1</code>.
            </dd>
            <dd><code>dst</code> - Accumulator with the same number of channels as input images,
                32-bit or 64-bit floating-point.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/motion_analysis_and_object_tracking.html#accumulateproduct">org.opencv.imgproc.Imgproc.accumulateProduct</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulate(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>accumulate(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulateWeighted(org.opencv.core.Mat, org.opencv.core.Mat, double, org.opencv.core.Mat)"><code>accumulateWeighted(org.opencv.core.Mat,
                    org.opencv.core.Mat, double, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulateSquare(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>accumulateSquare(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="accumulateProduct(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>accumulateProduct</h4>
<pre>public static&nbsp;void&nbsp;accumulateProduct(<a href="../../../org/opencv/core/Mat.html"
                                                       title="class in org.opencv.core">Mat</a>&nbsp;src1,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
        <div class="block"><p>Adds the per-element product of two input images to the
            accumulator.</p>

            <p>The function adds the product of two images or their selected regions to the
                accumulator <code>dst</code> :</p>

            <p><em>dst(x,y) <- dst(x,y) + src1(x,y) * src2(x,y) if mask(x,y) != 0</em></p>

            <p>The function supports multi-channel images. Each channel is processed
                independently.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - First input image, 1- or 3-channel, 8-bit or 32-bit floating
                point.
            </dd>
            <dd><code>src2</code> - Second input image of the same type and the same size as
                <code>src1</code>.
            </dd>
            <dd><code>dst</code> - Accumulator with the same number of channels as input images,
                32-bit or 64-bit floating-point.
            </dd>
            <dd><code>mask</code> - Optional operation mask.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/motion_analysis_and_object_tracking.html#accumulateproduct">org.opencv.imgproc.Imgproc.accumulateProduct</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulate(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>accumulate(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulateWeighted(org.opencv.core.Mat, org.opencv.core.Mat, double, org.opencv.core.Mat)"><code>accumulateWeighted(org.opencv.core.Mat,
                    org.opencv.core.Mat, double, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulateSquare(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>accumulateSquare(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="accumulateSquare(org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>accumulateSquare</h4>
<pre>public static&nbsp;void&nbsp;accumulateSquare(<a href="../../../org/opencv/core/Mat.html"
                                                      title="class in org.opencv.core">Mat</a>&nbsp;src,
                    <a href="../../../org/opencv/core/Mat.html"
                       title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Adds the square of a source image to the accumulator.</p>

            <p>The function adds the input image <code>src</code> or its selected region,
                raised to a power of 2, to the accumulator <code>dst</code> :</p>

            <p><em>dst(x,y) <- dst(x,y) + src(x,y)^2 if mask(x,y) != 0</em></p>

            <p>The function supports multi-channel images. Each channel is processed
                independently.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Input image as 1- or 3-channel, 8-bit or 32-bit floating point.
            </dd>
            <dd><code>dst</code> - Accumulator image with the same number of channels as input
                image,
                32-bit or 64-bit floating-point.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/motion_analysis_and_object_tracking.html#accumulatesquare">org.opencv.imgproc.Imgproc.accumulateSquare</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulateWeighted(org.opencv.core.Mat, org.opencv.core.Mat, double, org.opencv.core.Mat)"><code>accumulateWeighted(org.opencv.core.Mat,
                    org.opencv.core.Mat, double, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulateProduct(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>accumulateProduct(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulateSquare(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>accumulateSquare(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="accumulateSquare(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>accumulateSquare</h4>
<pre>public static&nbsp;void&nbsp;accumulateSquare(<a href="../../../org/opencv/core/Mat.html"
                                                      title="class in org.opencv.core">Mat</a>&nbsp;src,
                    <a href="../../../org/opencv/core/Mat.html"
                       title="class in org.opencv.core">Mat</a>&nbsp;dst,
                    <a href="../../../org/opencv/core/Mat.html"
                       title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
        <div class="block"><p>Adds the square of a source image to the accumulator.</p>

            <p>The function adds the input image <code>src</code> or its selected region,
                raised to a power of 2, to the accumulator <code>dst</code> :</p>

            <p><em>dst(x,y) <- dst(x,y) + src(x,y)^2 if mask(x,y) != 0</em></p>

            <p>The function supports multi-channel images. Each channel is processed
                independently.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Input image as 1- or 3-channel, 8-bit or 32-bit floating point.
            </dd>
            <dd><code>dst</code> - Accumulator image with the same number of channels as input
                image,
                32-bit or 64-bit floating-point.
            </dd>
            <dd><code>mask</code> - Optional operation mask.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/motion_analysis_and_object_tracking.html#accumulatesquare">org.opencv.imgproc.Imgproc.accumulateSquare</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulateWeighted(org.opencv.core.Mat, org.opencv.core.Mat, double, org.opencv.core.Mat)"><code>accumulateWeighted(org.opencv.core.Mat,
                    org.opencv.core.Mat, double, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulateProduct(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>accumulateProduct(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulateSquare(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>accumulateSquare(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="accumulateWeighted(org.opencv.core.Mat, org.opencv.core.Mat, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>accumulateWeighted</h4>
<pre>public static&nbsp;void&nbsp;accumulateWeighted(<a href="../../../org/opencv/core/Mat.html"
                                                        title="class in org.opencv.core">Mat</a>&nbsp;src,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                      double&nbsp;alpha)</pre>
        <div class="block"><p>Updates a running average.</p>

            <p>The function calculates the weighted sum of the input image <code>src</code>
                and the accumulator <code>dst</code> so that <code>dst</code> becomes a
                running average of a frame sequence:</p>

            <p><em>dst(x,y) <- (1- alpha) * dst(x,y) + alpha * src(x,y) if mask(x,y) !=
                0</em></p>

            <p>That is, <code>alpha</code> regulates the update speed (how fast the
                accumulator "forgets" about earlier images).
                The function supports multi-channel images. Each channel is processed
                independently.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Input image as 1- or 3-channel, 8-bit or 32-bit floating point.
            </dd>
            <dd><code>dst</code> - Accumulator image with the same number of channels as input
                image,
                32-bit or 64-bit floating-point.
            </dd>
            <dd><code>alpha</code> - Weight of the input image.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/motion_analysis_and_object_tracking.html#accumulateweighted">org.opencv.imgproc.Imgproc.accumulateWeighted</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulate(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>accumulate(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulateProduct(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>accumulateProduct(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulateSquare(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>accumulateSquare(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="accumulateWeighted(org.opencv.core.Mat, org.opencv.core.Mat, double, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>accumulateWeighted</h4>
<pre>public static&nbsp;void&nbsp;accumulateWeighted(<a href="../../../org/opencv/core/Mat.html"
                                                        title="class in org.opencv.core">Mat</a>&nbsp;src,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                      double&nbsp;alpha,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
        <div class="block"><p>Updates a running average.</p>

            <p>The function calculates the weighted sum of the input image <code>src</code>
                and the accumulator <code>dst</code> so that <code>dst</code> becomes a
                running average of a frame sequence:</p>

            <p><em>dst(x,y) <- (1- alpha) * dst(x,y) + alpha * src(x,y) if mask(x,y) !=
                0</em></p>

            <p>That is, <code>alpha</code> regulates the update speed (how fast the
                accumulator "forgets" about earlier images).
                The function supports multi-channel images. Each channel is processed
                independently.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Input image as 1- or 3-channel, 8-bit or 32-bit floating point.
            </dd>
            <dd><code>dst</code> - Accumulator image with the same number of channels as input
                image,
                32-bit or 64-bit floating-point.
            </dd>
            <dd><code>alpha</code> - Weight of the input image.</dd>
            <dd><code>mask</code> - Optional operation mask.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/motion_analysis_and_object_tracking.html#accumulateweighted">org.opencv.imgproc.Imgproc.accumulateWeighted</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulate(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>accumulate(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulateProduct(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>accumulateProduct(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#accumulateSquare(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>accumulateSquare(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="adaptiveBilateralFilter(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>adaptiveBilateralFilter</h4>
<pre>public static&nbsp;void&nbsp;adaptiveBilateralFilter(<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                           <a href="../../../org/opencv/core/Mat.html"
                              title="class in org.opencv.core">Mat</a>&nbsp;dst,
                           <a href="../../../org/opencv/core/Size.html"
                              title="class in org.opencv.core">Size</a>&nbsp;ksize,
                           double&nbsp;sigmaSpace)</pre>
        <div class="block"><p>Applies the adaptive bilateral filter to an image.</p>

            <p>A main part of our strategy will be to load each raw pixel once, and reuse it
                to calculate all pixels in the output (filtered) image that need this pixel
                value. The math of the filter is that of the usual bilateral filter, except
                that the sigma color is calculated in the neighborhood, and clamped by the
                optional input value.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - The source image</dd>
            <dd><code>dst</code> - The destination image; will have the same size and the same type
                as src
            </dd>
            <dd><code>ksize</code> - The kernel size. This is the neighborhood where the local
                variance will be calculated, and where pixels will contribute (in a weighted
                manner).
            </dd>
            <dd><code>sigmaSpace</code> - Filter sigma in the coordinate space. Larger value of the
                parameter means that farther pixels will influence each other (as long as
                their colors are close enough; see sigmaColor). Then d>0, it specifies the
                neighborhood size regardless of sigmaSpace, otherwise d is proportional to
                sigmaSpace.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#adaptivebilateralfilter">org.opencv.imgproc.Imgproc.adaptiveBilateralFilter</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="adaptiveBilateralFilter(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double, double, org.opencv.core.Point)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>adaptiveBilateralFilter</h4>
<pre>public static&nbsp;void&nbsp;adaptiveBilateralFilter(<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                           <a href="../../../org/opencv/core/Mat.html"
                              title="class in org.opencv.core">Mat</a>&nbsp;dst,
                           <a href="../../../org/opencv/core/Size.html"
                              title="class in org.opencv.core">Size</a>&nbsp;ksize,
                           double&nbsp;sigmaSpace,
                           double&nbsp;maxSigmaColor,
                           <a href="../../../org/opencv/core/Point.html"
                              title="class in org.opencv.core">Point</a>&nbsp;anchor)</pre>
        <div class="block"><p>Applies the adaptive bilateral filter to an image.</p>

            <p>A main part of our strategy will be to load each raw pixel once, and reuse it
                to calculate all pixels in the output (filtered) image that need this pixel
                value. The math of the filter is that of the usual bilateral filter, except
                that the sigma color is calculated in the neighborhood, and clamped by the
                optional input value.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - The source image</dd>
            <dd><code>dst</code> - The destination image; will have the same size and the same type
                as src
            </dd>
            <dd><code>ksize</code> - The kernel size. This is the neighborhood where the local
                variance will be calculated, and where pixels will contribute (in a weighted
                manner).
            </dd>
            <dd><code>sigmaSpace</code> - Filter sigma in the coordinate space. Larger value of the
                parameter means that farther pixels will influence each other (as long as
                their colors are close enough; see sigmaColor). Then d>0, it specifies the
                neighborhood size regardless of sigmaSpace, otherwise d is proportional to
                sigmaSpace.
            </dd>
            <dd><code>maxSigmaColor</code> - Maximum allowed sigma color (will clamp the value
                calculated in the ksize neighborhood. Larger value of the parameter means
                that more dissimilar pixels will influence each other (as long as their
                colors are close enough; see sigmaColor). Then d>0, it specifies the
                neighborhood size regardless of sigmaSpace, otherwise d is proportional to
                sigmaSpace.
            </dd>
            <dd><code>anchor</code> - a anchor</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#adaptivebilateralfilter">org.opencv.imgproc.Imgproc.adaptiveBilateralFilter</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="adaptiveBilateralFilter(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double, double, org.opencv.core.Point, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>adaptiveBilateralFilter</h4>
<pre>public static&nbsp;void&nbsp;adaptiveBilateralFilter(<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                           <a href="../../../org/opencv/core/Mat.html"
                              title="class in org.opencv.core">Mat</a>&nbsp;dst,
                           <a href="../../../org/opencv/core/Size.html"
                              title="class in org.opencv.core">Size</a>&nbsp;ksize,
                           double&nbsp;sigmaSpace,
                           double&nbsp;maxSigmaColor,
                           <a href="../../../org/opencv/core/Point.html"
                              title="class in org.opencv.core">Point</a>&nbsp;anchor,
                           int&nbsp;borderType)</pre>
        <div class="block"><p>Applies the adaptive bilateral filter to an image.</p>

            <p>A main part of our strategy will be to load each raw pixel once, and reuse it
                to calculate all pixels in the output (filtered) image that need this pixel
                value. The math of the filter is that of the usual bilateral filter, except
                that the sigma color is calculated in the neighborhood, and clamped by the
                optional input value.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - The source image</dd>
            <dd><code>dst</code> - The destination image; will have the same size and the same type
                as src
            </dd>
            <dd><code>ksize</code> - The kernel size. This is the neighborhood where the local
                variance will be calculated, and where pixels will contribute (in a weighted
                manner).
            </dd>
            <dd><code>sigmaSpace</code> - Filter sigma in the coordinate space. Larger value of the
                parameter means that farther pixels will influence each other (as long as
                their colors are close enough; see sigmaColor). Then d>0, it specifies the
                neighborhood size regardless of sigmaSpace, otherwise d is proportional to
                sigmaSpace.
            </dd>
            <dd><code>maxSigmaColor</code> - Maximum allowed sigma color (will clamp the value
                calculated in the ksize neighborhood. Larger value of the parameter means
                that more dissimilar pixels will influence each other (as long as their
                colors are close enough; see sigmaColor). Then d>0, it specifies the
                neighborhood size regardless of sigmaSpace, otherwise d is proportional to
                sigmaSpace.
            </dd>
            <dd><code>anchor</code> - a anchor</dd>
            <dd><code>borderType</code> - Pixel extrapolation method.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#adaptivebilateralfilter">org.opencv.imgproc.Imgproc.adaptiveBilateralFilter</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="adaptiveThreshold(org.opencv.core.Mat, org.opencv.core.Mat, double, int, int, int, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>adaptiveThreshold</h4>
<pre>public static&nbsp;void&nbsp;adaptiveThreshold(<a href="../../../org/opencv/core/Mat.html"
                                                       title="class in org.opencv.core">Mat</a>&nbsp;src,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                     double&nbsp;maxValue,
                     int&nbsp;adaptiveMethod,
                     int&nbsp;thresholdType,
                     int&nbsp;blockSize,
                     double&nbsp;C)</pre>
        <div class="block"><p>Applies an adaptive threshold to an array.</p>

            <p>The function transforms a grayscale image to a binary image according to the
                formulae:</p>
            <ul>
                <li> THRESH_BINARY
            </ul>

            <p><em>dst(x,y) = maxValue if src(x,y) &gt T(x,y); 0 otherwise</em></p>

            <ul>
                <li> THRESH_BINARY_INV
            </ul>

            <p><em>dst(x,y) = 0 if src(x,y) &gt T(x,y); maxValue otherwise</em></p>

            <p>where <em>T(x,y)</em> is a threshold calculated individually for each pixel.</p>
            <ul>
                <li> For the method <code>ADAPTIVE_THRESH_MEAN_C</code>, the threshold
                    value <em>T(x,y)</em> is a mean of the <em>blockSize x blockSize</em>
                    neighborhood of <em>(x, y)</em> minus <code>C</code>.
                <li> For the method <code>ADAPTIVE_THRESH_GAUSSIAN_C</code>, the threshold
                    value <em>T(x, y)</em> is a weighted sum (cross-correlation with a Gaussian
                    window) of the <em>blockSize x blockSize</em> neighborhood of <em>(x, y)</em>
                    minus <code>C</code>. The default sigma (standard deviation) is used for the
                    specified <code>blockSize</code>. See "getGaussianKernel".
            </ul>

            <p>The function can process the image in-place.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Source 8-bit single-channel image.</dd>
            <dd><code>dst</code> - Destination image of the same size and the same type as
                <code>src</code>.
            </dd>
            <dd><code>maxValue</code> - Non-zero value assigned to the pixels for which the
                condition
                is satisfied. See the details below.
            </dd>
            <dd><code>adaptiveMethod</code> - Adaptive thresholding algorithm to use,
                <code>ADAPTIVE_THRESH_MEAN_C</code> or <code>ADAPTIVE_THRESH_GAUSSIAN_C</code>.
                See the details below.
            </dd>
            <dd><code>thresholdType</code> - Thresholding type that must be either <code>THRESH_BINARY</code>
                or <code>THRESH_BINARY_INV</code>.
            </dd>
            <dd><code>blockSize</code> - Size of a pixel neighborhood that is used to calculate a
                threshold value for the pixel: 3, 5, 7, and so on.
            </dd>
            <dd><code>C</code> - Constant subtracted from the mean or weighted mean (see the details
                below). Normally, it is positive but may be zero or negative as well.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#adaptivethreshold">org.opencv.imgproc.Imgproc.adaptiveThreshold</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#threshold(org.opencv.core.Mat, org.opencv.core.Mat, double, double, int)"><code>threshold(org.opencv.core.Mat,
                    org.opencv.core.Mat, double, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#GaussianBlur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double, double, int)"><code>GaussianBlur(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Size, double, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#blur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Point, int)"><code>blur(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Point,
                    int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="approxPolyDP(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, double, boolean)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>approxPolyDP</h4>
<pre>public static&nbsp;void&nbsp;approxPolyDP(<a href="../../../org/opencv/core/MatOfPoint2f.html"
                                                  title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;curve,
                <a href="../../../org/opencv/core/MatOfPoint2f.html"
                   title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;approxCurve,
                double&nbsp;epsilon,
                boolean&nbsp;closed)</pre>
        <div class="block"><p>Approximates a polygonal curve(s) with the specified precision.</p>

            <p>The functions <code>approxPolyDP</code> approximate a curve or a polygon with
                another curve/polygon with less vertices so that the distance between them is
                less or equal to the specified precision. It uses the Douglas-Peucker
                algorithm http://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm</p>

            <p>See https://github.com/Itseez/opencv/tree/master/samples/cpp/contours2.cpp
                for the function usage model.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>curve</code> - Input vector of a 2D point stored in:
                <ul>
                    <li><code>std.vector</code> or <code>Mat</code> (C++ interface)
                    <li><code>Nx2</code> numpy array (Python interface)
                    <li><code>CvSeq</code> or <code> </code>CvMat" (C interface)
                </ul>
            </dd>
            <dd><code>approxCurve</code> - Result of the approximation. The type should match the
                type of the input curve. In case of C interface the approximated curve is
                stored in the memory storage and pointer to it is returned.
            </dd>
            <dd><code>epsilon</code> - Parameter specifying the approximation accuracy. This is the
                maximum distance between the original curve and its approximation.
            </dd>
            <dd><code>closed</code> - If true, the approximated curve is closed (its first and last
                vertices are connected). Otherwise, it is not closed.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#approxpolydp">org.opencv.imgproc.Imgproc.approxPolyDP</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="arcLength(org.opencv.core.MatOfPoint2f, boolean)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>arcLength</h4>
<pre>public static&nbsp;double&nbsp;arcLength(<a href="../../../org/opencv/core/MatOfPoint2f.html"
                                                 title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;curve,
               boolean&nbsp;closed)</pre>
        <div class="block"><p>Calculates a contour perimeter or a curve length.</p>

            <p>The function computes a curve length or a closed contour perimeter.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>curve</code> - Input vector of 2D points, stored in <code>std.vector</code> or
                <code>Mat</code>.
            </dd>
            <dd><code>closed</code> - Flag indicating whether the curve is closed or not.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#arclength">org.opencv.imgproc.Imgproc.arcLength</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="bilateralFilter(org.opencv.core.Mat, org.opencv.core.Mat, int, double, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>bilateralFilter</h4>
<pre>public static&nbsp;void&nbsp;bilateralFilter(<a href="../../../org/opencv/core/Mat.html"
                                                     title="class in org.opencv.core">Mat</a>&nbsp;src,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;dst,
                   int&nbsp;d,
                   double&nbsp;sigmaColor,
                   double&nbsp;sigmaSpace)</pre>
        <div class="block"><p>Applies the bilateral filter to an image.</p>

            <p>The function applies bilateral filtering to the input image, as described in
                http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html
                <code>bilateralFilter</code> can reduce unwanted noise very well while
                keeping edges fairly sharp. However, it is very slow compared to most
                filters.</p>
            <ul>
                <li>Sigma values*: For simplicity, you can set the 2 sigma values to be the
                    same. If they are small (< 10), the filter will not have much effect, whereas
                    if they are large (> 150), they will have a very strong effect, making the
                    image look "cartoonish".
                <li>Filter size*: Large filters (d > 5) are very slow, so it is recommended
                    to use d=5 for real-time applications, and perhaps d=9 for offline
                    applications that need heavy noise filtering.
            </ul>

            <p>This filter does not work inplace.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Source 8-bit or floating-point, 1-channel or 3-channel image.
            </dd>
            <dd><code>dst</code> - Destination image of the same size and type as <code>src</code>.
            </dd>
            <dd><code>d</code> - Diameter of each pixel neighborhood that is used during filtering.
                If it is non-positive, it is computed from <code>sigmaSpace</code>.
            </dd>
            <dd><code>sigmaColor</code> - Filter sigma in the color space. A larger value of the
                parameter means that farther colors within the pixel neighborhood (see
                <code>sigmaSpace</code>) will be mixed together, resulting in larger areas of
                semi-equal color.
            </dd>
            <dd><code>sigmaSpace</code> - Filter sigma in the coordinate space. A larger value of
                the
                parameter means that farther pixels will influence each other as long as
                their colors are close enough (see <code>sigmaColor</code>). When
                <code>d>0</code>, it specifies the neighborhood size regardless of
                <code>sigmaSpace</code>. Otherwise, <code>d</code> is proportional to
                <code>sigmaSpace</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#bilateralfilter">org.opencv.imgproc.Imgproc.bilateralFilter</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="bilateralFilter(org.opencv.core.Mat, org.opencv.core.Mat, int, double, double, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>bilateralFilter</h4>
<pre>public static&nbsp;void&nbsp;bilateralFilter(<a href="../../../org/opencv/core/Mat.html"
                                                     title="class in org.opencv.core">Mat</a>&nbsp;src,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;dst,
                   int&nbsp;d,
                   double&nbsp;sigmaColor,
                   double&nbsp;sigmaSpace,
                   int&nbsp;borderType)</pre>
        <div class="block"><p>Applies the bilateral filter to an image.</p>

            <p>The function applies bilateral filtering to the input image, as described in
                http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html
                <code>bilateralFilter</code> can reduce unwanted noise very well while
                keeping edges fairly sharp. However, it is very slow compared to most
                filters.</p>
            <ul>
                <li>Sigma values*: For simplicity, you can set the 2 sigma values to be the
                    same. If they are small (< 10), the filter will not have much effect, whereas
                    if they are large (> 150), they will have a very strong effect, making the
                    image look "cartoonish".
                <li>Filter size*: Large filters (d > 5) are very slow, so it is recommended
                    to use d=5 for real-time applications, and perhaps d=9 for offline
                    applications that need heavy noise filtering.
            </ul>

            <p>This filter does not work inplace.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Source 8-bit or floating-point, 1-channel or 3-channel image.
            </dd>
            <dd><code>dst</code> - Destination image of the same size and type as <code>src</code>.
            </dd>
            <dd><code>d</code> - Diameter of each pixel neighborhood that is used during filtering.
                If it is non-positive, it is computed from <code>sigmaSpace</code>.
            </dd>
            <dd><code>sigmaColor</code> - Filter sigma in the color space. A larger value of the
                parameter means that farther colors within the pixel neighborhood (see
                <code>sigmaSpace</code>) will be mixed together, resulting in larger areas of
                semi-equal color.
            </dd>
            <dd><code>sigmaSpace</code> - Filter sigma in the coordinate space. A larger value of
                the
                parameter means that farther pixels will influence each other as long as
                their colors are close enough (see <code>sigmaColor</code>). When
                <code>d>0</code>, it specifies the neighborhood size regardless of
                <code>sigmaSpace</code>. Otherwise, <code>d</code> is proportional to
                <code>sigmaSpace</code>.
            </dd>
            <dd><code>borderType</code> - a borderType</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#bilateralfilter">org.opencv.imgproc.Imgproc.bilateralFilter</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="blur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>blur</h4>
<pre>public static&nbsp;void&nbsp;blur(<a href="../../../org/opencv/core/Mat.html"
                                          title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize)</pre>
        <div class="block"><p>Blurs an image using the normalized box filter.</p>

            <p>The function smoothes an image using the kernel:</p>

            <p><em>K = 1/(ksize.width*ksize.height) 1 1 1 *s 1 1
                1 1 1 *s 1 1..................
                1 1 1 *s 1 1
            </em></p>

            <p>The call <code>blur(src, dst, ksize, anchor, borderType)</code> is equivalent
                to <code>boxFilter(src, dst, src.type(), anchor, true, borderType)</code>.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image; it can have any number of channels, which are
                processed independently, but the depth should be <code>CV_8U</code>,
                <code>CV_16U</code>, <code>CV_16S</code>, <code>CV_32F</code> or
                <code>CV_64F</code>.
            </dd>
            <dd><code>dst</code> - output image of the same size and type as <code>src</code>.</dd>
            <dd><code>ksize</code> - blurring kernel size.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#blur">org.opencv.imgproc.Imgproc.blur</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#boxFilter(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Size, org.opencv.core.Point, boolean, int)"><code>boxFilter(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, org.opencv.core.Size, org.opencv.core.Point, boolean,
                    int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#GaussianBlur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double, double, int)"><code>GaussianBlur(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Size, double, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#bilateralFilter(org.opencv.core.Mat, org.opencv.core.Mat, int, double, double, int)"><code>bilateralFilter(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, double, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#medianBlur(org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>medianBlur(org.opencv.core.Mat,
                    org.opencv.core.Mat, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="blur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Point)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>blur</h4>
<pre>public static&nbsp;void&nbsp;blur(<a href="../../../org/opencv/core/Mat.html"
                                          title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor)</pre>
        <div class="block"><p>Blurs an image using the normalized box filter.</p>

            <p>The function smoothes an image using the kernel:</p>

            <p><em>K = 1/(ksize.width*ksize.height) 1 1 1 *s 1 1
                1 1 1 *s 1 1..................
                1 1 1 *s 1 1
            </em></p>

            <p>The call <code>blur(src, dst, ksize, anchor, borderType)</code> is equivalent
                to <code>boxFilter(src, dst, src.type(), anchor, true, borderType)</code>.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image; it can have any number of channels, which are
                processed independently, but the depth should be <code>CV_8U</code>,
                <code>CV_16U</code>, <code>CV_16S</code>, <code>CV_32F</code> or
                <code>CV_64F</code>.
            </dd>
            <dd><code>dst</code> - output image of the same size and type as <code>src</code>.</dd>
            <dd><code>ksize</code> - blurring kernel size.</dd>
            <dd><code>anchor</code> - anchor point; default value <code>Point(-1,-1)</code> means
                that the anchor is at the kernel center.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#blur">org.opencv.imgproc.Imgproc.blur</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#boxFilter(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Size, org.opencv.core.Point, boolean, int)"><code>boxFilter(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, org.opencv.core.Size, org.opencv.core.Point, boolean,
                    int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#GaussianBlur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double, double, int)"><code>GaussianBlur(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Size, double, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#bilateralFilter(org.opencv.core.Mat, org.opencv.core.Mat, int, double, double, int)"><code>bilateralFilter(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, double, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#medianBlur(org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>medianBlur(org.opencv.core.Mat,
                    org.opencv.core.Mat, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="blur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Point, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>blur</h4>
<pre>public static&nbsp;void&nbsp;blur(<a href="../../../org/opencv/core/Mat.html"
                                          title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
        int&nbsp;borderType)</pre>
        <div class="block"><p>Blurs an image using the normalized box filter.</p>

            <p>The function smoothes an image using the kernel:</p>

            <p><em>K = 1/(ksize.width*ksize.height) 1 1 1 *s 1 1
                1 1 1 *s 1 1..................
                1 1 1 *s 1 1
            </em></p>

            <p>The call <code>blur(src, dst, ksize, anchor, borderType)</code> is equivalent
                to <code>boxFilter(src, dst, src.type(), anchor, true, borderType)</code>.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image; it can have any number of channels, which are
                processed independently, but the depth should be <code>CV_8U</code>,
                <code>CV_16U</code>, <code>CV_16S</code>, <code>CV_32F</code> or
                <code>CV_64F</code>.
            </dd>
            <dd><code>dst</code> - output image of the same size and type as <code>src</code>.</dd>
            <dd><code>ksize</code> - blurring kernel size.</dd>
            <dd><code>anchor</code> - anchor point; default value <code>Point(-1,-1)</code> means
                that the anchor is at the kernel center.
            </dd>
            <dd><code>borderType</code> - border mode used to extrapolate pixels outside of the
                image.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#blur">org.opencv.imgproc.Imgproc.blur</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#boxFilter(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Size, org.opencv.core.Point, boolean, int)"><code>boxFilter(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, org.opencv.core.Size, org.opencv.core.Point, boolean,
                    int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#GaussianBlur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double, double, int)"><code>GaussianBlur(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Size, double, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#bilateralFilter(org.opencv.core.Mat, org.opencv.core.Mat, int, double, double, int)"><code>bilateralFilter(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, double, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#medianBlur(org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>medianBlur(org.opencv.core.Mat,
                    org.opencv.core.Mat, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="borderInterpolate(int, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>borderInterpolate</h4>
<pre>public static&nbsp;int&nbsp;borderInterpolate(int&nbsp;p,
                    int&nbsp;len,
                    int&nbsp;borderType)</pre>
        <div class="block"><p>Computes the source location of an extrapolated pixel.</p>

            <p>The function computes and returns the coordinate of a donor pixel
                corresponding to the specified extrapolated pixel when using the specified
                extrapolation border mode. For example, if you use <code>BORDER_WRAP</code>
                mode in the horizontal direction, <code>BORDER_REFLECT_101</code> in the
                vertical direction and want to compute value of the "virtual" pixel
                <code>Point(-5, 100)</code> in a floating-point image <code>img</code>, it
                looks like: <code></p>

            <p>// C++ code:</p>

            <p>float val = img.at
                <float>(borderInterpolate(100, img.rows, BORDER_REFLECT_101),
            </p>

            <p>borderInterpolate(-5, img.cols, BORDER_WRAP));</p>

            <p>Normally, the function is not called directly. It is used inside </code></p>

            <p>"FilterEngine" and "copyMakeBorder" to compute tables for quick
                extrapolation.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>p</code> - 0-based coordinate of the extrapolated pixel along one of the axes,
                likely <0 or >= <code>len</code>.
            </dd>
            <dd><code>len</code> - Length of the array along the corresponding axis.</dd>
            <dd><code>borderType</code> - Border type, one of the <code>BORDER_*</code>, except for
                <code>BORDER_TRANSPARENT</code> and <code>BORDER_ISOLATED</code>. When
                <code>borderType==BORDER_CONSTANT</code>, the function always returns -1,
                regardless of <code>p</code> and <code>len</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#borderinterpolate">org.opencv.imgproc.Imgproc.borderInterpolate</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#copyMakeBorder(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, int, int, org.opencv.core.Scalar)"><code>copyMakeBorder(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int, int, int, int, org.opencv.core.Scalar)</code></a>
            </dd>
        </dl>
    </li>
</ul>
<a name="boundingRect(org.opencv.core.MatOfPoint)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>boundingRect</h4>
        <pre>public static&nbsp;<a href="../../../org/opencv/core/Rect.html"
                                   title="class in org.opencv.core">Rect</a>&nbsp;boundingRect(<a
                href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;points)</pre>
        <div class="block"><p>Calculates the up-right bounding rectangle of a point set.</p>

            <p>The function calculates and returns the minimal up-right bounding rectangle
                for the specified point set.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>points</code> - Input 2D point set, stored in <code>std.vector</code> or
                <code>Mat</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#boundingrect">org.opencv.imgproc.Imgproc.boundingRect</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="boxFilter(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Size)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>boxFilter</h4>
<pre>public static&nbsp;void&nbsp;boxFilter(<a href="../../../org/opencv/core/Mat.html"
                                               title="class in org.opencv.core">Mat</a>&nbsp;src,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
             int&nbsp;ddepth,
             <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize)</pre>
        <div class="block"><p>Blurs an image using the box filter.</p>

            <p>The function smoothes an image using the kernel:</p>

            <p><em>K = alpha 1 1 1 *s 1 1
                1 1 1 *s 1 1..................
                1 1 1 *s 1 1 </em></p>

            <p>where</p>

            <p><em>alpha = 1/(ksize.width*ksize.height) when normalize=true; 1
                otherwise</em></p>

            <p>Unnormalized box filter is useful for computing various integral
                characteristics over each pixel neighborhood, such as covariance matrices of
                image derivatives (used in dense optical flow algorithms, and so on). If you
                need to compute pixel sums over variable-size windows, use "integral".</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image.</dd>
            <dd><code>dst</code> - output image of the same size and type as <code>src</code>.</dd>
            <dd><code>ddepth</code> - the output image depth (-1 to use <code>src.depth()</code>).
            </dd>
            <dd><code>ksize</code> - blurring kernel size.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#boxfilter">org.opencv.imgproc.Imgproc.boxFilter</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#GaussianBlur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double, double, int)"><code>GaussianBlur(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Size, double, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#medianBlur(org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>medianBlur(org.opencv.core.Mat,
                    org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#integral(org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>integral(org.opencv.core.Mat,
                    org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#bilateralFilter(org.opencv.core.Mat, org.opencv.core.Mat, int, double, double, int)"><code>bilateralFilter(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, double, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#blur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Point, int)"><code>blur(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Point,
                    int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="boxFilter(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Size, org.opencv.core.Point, boolean)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>boxFilter</h4>
<pre>public static&nbsp;void&nbsp;boxFilter(<a href="../../../org/opencv/core/Mat.html"
                                               title="class in org.opencv.core">Mat</a>&nbsp;src,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
             int&nbsp;ddepth,
             <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
             <a href="../../../org/opencv/core/Point.html"
                title="class in org.opencv.core">Point</a>&nbsp;anchor,
             boolean&nbsp;normalize)</pre>
        <div class="block"><p>Blurs an image using the box filter.</p>

            <p>The function smoothes an image using the kernel:</p>

            <p><em>K = alpha 1 1 1 *s 1 1
                1 1 1 *s 1 1..................
                1 1 1 *s 1 1 </em></p>

            <p>where</p>

            <p><em>alpha = 1/(ksize.width*ksize.height) when normalize=true; 1
                otherwise</em></p>

            <p>Unnormalized box filter is useful for computing various integral
                characteristics over each pixel neighborhood, such as covariance matrices of
                image derivatives (used in dense optical flow algorithms, and so on). If you
                need to compute pixel sums over variable-size windows, use "integral".</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image.</dd>
            <dd><code>dst</code> - output image of the same size and type as <code>src</code>.</dd>
            <dd><code>ddepth</code> - the output image depth (-1 to use <code>src.depth()</code>).
            </dd>
            <dd><code>ksize</code> - blurring kernel size.</dd>
            <dd><code>anchor</code> - anchor point; default value <code>Point(-1,-1)</code> means
                that the anchor is at the kernel center.
            </dd>
            <dd><code>normalize</code> - flag, specifying whether the kernel is normalized by its
                area or not.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#boxfilter">org.opencv.imgproc.Imgproc.boxFilter</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#GaussianBlur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double, double, int)"><code>GaussianBlur(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Size, double, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#medianBlur(org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>medianBlur(org.opencv.core.Mat,
                    org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#integral(org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>integral(org.opencv.core.Mat,
                    org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#bilateralFilter(org.opencv.core.Mat, org.opencv.core.Mat, int, double, double, int)"><code>bilateralFilter(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, double, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#blur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Point, int)"><code>blur(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Point,
                    int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="boxFilter(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Size, org.opencv.core.Point, boolean, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>boxFilter</h4>
<pre>public static&nbsp;void&nbsp;boxFilter(<a href="../../../org/opencv/core/Mat.html"
                                               title="class in org.opencv.core">Mat</a>&nbsp;src,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
             int&nbsp;ddepth,
             <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
             <a href="../../../org/opencv/core/Point.html"
                title="class in org.opencv.core">Point</a>&nbsp;anchor,
             boolean&nbsp;normalize,
             int&nbsp;borderType)</pre>
        <div class="block"><p>Blurs an image using the box filter.</p>

            <p>The function smoothes an image using the kernel:</p>

            <p><em>K = alpha 1 1 1 *s 1 1
                1 1 1 *s 1 1..................
                1 1 1 *s 1 1 </em></p>

            <p>where</p>

            <p><em>alpha = 1/(ksize.width*ksize.height) when normalize=true; 1
                otherwise</em></p>

            <p>Unnormalized box filter is useful for computing various integral
                characteristics over each pixel neighborhood, such as covariance matrices of
                image derivatives (used in dense optical flow algorithms, and so on). If you
                need to compute pixel sums over variable-size windows, use "integral".</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image.</dd>
            <dd><code>dst</code> - output image of the same size and type as <code>src</code>.</dd>
            <dd><code>ddepth</code> - the output image depth (-1 to use <code>src.depth()</code>).
            </dd>
            <dd><code>ksize</code> - blurring kernel size.</dd>
            <dd><code>anchor</code> - anchor point; default value <code>Point(-1,-1)</code> means
                that the anchor is at the kernel center.
            </dd>
            <dd><code>normalize</code> - flag, specifying whether the kernel is normalized by its
                area or not.
            </dd>
            <dd><code>borderType</code> - border mode used to extrapolate pixels outside of the
                image.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#boxfilter">org.opencv.imgproc.Imgproc.boxFilter</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#GaussianBlur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double, double, int)"><code>GaussianBlur(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Size, double, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#medianBlur(org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>medianBlur(org.opencv.core.Mat,
                    org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#integral(org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>integral(org.opencv.core.Mat,
                    org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#bilateralFilter(org.opencv.core.Mat, org.opencv.core.Mat, int, double, double, int)"><code>bilateralFilter(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, double, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#blur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Point, int)"><code>blur(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Point,
                    int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="calcBackProject(java.util.List, org.opencv.core.MatOfInt, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfFloat, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>calcBackProject</h4>
<pre>public static&nbsp;void&nbsp;calcBackProject(java.util.List&lt;<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;images,
                   <a href="../../../org/opencv/core/MatOfInt.html"
                      title="class in org.opencv.core">MatOfInt</a>&nbsp;channels,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;hist,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;dst,
                   <a href="../../../org/opencv/core/MatOfFloat.html"
                      title="class in org.opencv.core">MatOfFloat</a>&nbsp;ranges,
                   double&nbsp;scale)</pre>
        <div class="block"><p>Calculates the back projection of a histogram.</p>

            <p>The functions <code>calcBackProject</code> calculate the back project of the
                histogram. That is, similarly to <code>calcHist</code>, at each location
                <code>(x, y)</code> the function collects the values from the selected
                channels in the input images and finds the corresponding histogram bin. But
                instead of incrementing it, the function reads the bin value, scales it by
                <code>scale</code>, and stores in <code>backProject(x,y)</code>. In terms of
                statistics, the function computes probability of each element value in
                respect with the empirical probability distribution represented by the
                histogram. See how, for example, you can find and track a bright-colored
                object in a scene:</p>
            <ul>
                <li> Before tracking, show the object to the camera so that it covers
                    almost the whole frame. Calculate a hue histogram. The histogram may have
                    strong maximums, corresponding to the dominant colors in the object.
                <li> When tracking, calculate a back projection of a hue plane of each
                    input video frame using that pre-computed histogram. Threshold the back
                    projection to suppress weak colors. It may also make sense to suppress pixels
                    with non-sufficient color saturation and too dark or too bright pixels.
                <li> Find connected components in the resulting picture and choose, for
                    example, the largest component.
            </ul>

            <p>This is an approximate algorithm of the "CamShift" color object tracker.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>images</code> - Source arrays. They all should have the same depth,
                <code>CV_8U</code> or <code>CV_32F</code>, and the same size. Each of them
                can have an arbitrary number of channels.
            </dd>
            <dd><code>channels</code> - The list of channels used to compute the back projection.
                The
                number of channels must match the histogram dimensionality. The first array
                channels are numerated from 0 to <code>images[0].channels()-1</code>, the
                second array channels are counted from <code>images[0].channels()</code> to
                <code>images[0].channels() + images[1].channels()-1</code>, and so on.
            </dd>
            <dd><code>hist</code> - Input histogram that can be dense or sparse.</dd>
            <dd><code>dst</code> - a dst</dd>
            <dd><code>ranges</code> - Array of arrays of the histogram bin boundaries in each
                dimension. See "calcHist".
            </dd>
            <dd><code>scale</code> - Optional scale factor for the output back projection.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/histograms.html#calcbackproject">org.opencv.imgproc.Imgproc.calcBackProject</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#calcHist(java.util.List, org.opencv.core.MatOfInt, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfInt, org.opencv.core.MatOfFloat, boolean)"><code>calcHist(java.util.List
                    <org.opencv.core.Mat>, org.opencv.core.MatOfInt, org.opencv.core.Mat,
                        org.opencv.core.Mat, org.opencv.core.MatOfInt, org.opencv.core.MatOfFloat,
                        boolean)
                </code></a></dd>
        </dl>
    </li>
</ul>
<a name="calcHist(java.util.List, org.opencv.core.MatOfInt, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfInt, org.opencv.core.MatOfFloat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>calcHist</h4>
<pre>public static&nbsp;void&nbsp;calcHist(java.util.List&lt;<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;images,
            <a href="../../../org/opencv/core/MatOfInt.html" title="class in org.opencv.core">MatOfInt</a>&nbsp;channels,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;hist,
            <a href="../../../org/opencv/core/MatOfInt.html" title="class in org.opencv.core">MatOfInt</a>&nbsp;histSize,
            <a href="../../../org/opencv/core/MatOfFloat.html" title="class in org.opencv.core">MatOfFloat</a>&nbsp;ranges)</pre>
        <div class="block"><p>Calculates a histogram of a set of arrays.</p>

            <p>The functions <code>calcHist</code> calculate the histogram of one or more
                arrays. The elements of a tuple used to increment a histogram bin are taken
                from the correspondinginput arrays at the same location. The sample below
                shows how to compute a 2D Hue-Saturation histogram for a color image.
                <code></p>

            <p>// C++ code:</p>

            <p>#include
                <cv.h>
            </p>

            <p>#include
                <highgui.h>
            </p>

            <p>using namespace cv;</p>

            <p>int main(int argc, char argv)</p>


            <p>Mat src, hsv;</p>

            <p>if(argc != 2 || !(src=imread(argv[1], 1)).data)</p>

            <p>return -1;</p>

            <p>cvtColor(src, hsv, CV_BGR2HSV);</p>

            <p>// Quantize the hue to 30 levels</p>

            <p>// and the saturation to 32 levels</p>

            <p>int hbins = 30, sbins = 32;</p>

            <p>int histSize[] = {hbins, sbins};</p>

            <p>// hue varies from 0 to 179, see cvtColor</p>

            <p>float hranges[] = { 0, 180 };</p>

            <p>// saturation varies from 0 (black-gray-white) to</p>

            <p>// 255 (pure spectrum color)</p>

            <p>float sranges[] = { 0, 256 };</p>

            <p>const float* ranges[] = { hranges, sranges };</p>

            <p>MatND hist;</p>

            <p>// we compute the histogram from the 0-th and 1-st channels</p>

            <p>int channels[] = {0, 1};</p>

            <p>calcHist(&hsv, 1, channels, Mat(), // do not use mask</p>

            <p>hist, 2, histSize, ranges,</p>

            <p>true, // the histogram is uniform</p>

            <p>false);</p>

            <p>double maxVal=0;</p>

            <p>minMaxLoc(hist, 0, &maxVal, 0, 0);</p>

            <p>int scale = 10;</p>

            <p>Mat histImg = Mat.zeros(sbins*scale, hbins*10, CV_8UC3);</p>

            <p>for(int h = 0; h < hbins; h++)</p>

            <p>for(int s = 0; s < sbins; s++)</p>


            <p>float binVal = hist.at
                <float>(h, s);
            </p>

            <p>int intensity = cvRound(binVal*255/maxVal);</p>

            <p>rectangle(histImg, Point(h*scale, s*scale),</p>

            <p>Point((h+1)*scale - 1, (s+1)*scale - 1),</p>

            <p>Scalar.all(intensity),</p>

            <p>CV_FILLED);</p>


            <p>namedWindow("Source", 1);</p>

            <p>imshow("Source", src);</p>

            <p>namedWindow("H-S Histogram", 1);</p>

            <p>imshow("H-S Histogram", histImg);</p>

            <p>waitKey();</p>


            <p>Note: </code></p>
            <ul>
                <li> An example for creating histograms of an image can be found at
                    opencv_source_code/samples/cpp/demhist.cpp
                <li> (Python) An example for creating color histograms can be found at
                    opencv_source/samples/python2/color_histogram.py
                <li> (Python) An example illustrating RGB and grayscale histogram plotting
                    can be found at opencv_source/samples/python2/hist.py
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>images</code> - Source arrays. They all should have the same depth,
                <code>CV_8U</code> or <code>CV_32F</code>, and the same size. Each of them
                can have an arbitrary number of channels.
            </dd>
            <dd><code>channels</code> - List of the <code>dims</code> channels used to compute the
                histogram. The first array channels are numerated from 0 to <code>images[0].channels()-1</code>,
                the second array channels are counted from <code>images[0].channels()</code>
                to <code>images[0].channels() + images[1].channels()-1</code>, and so on.
            </dd>
            <dd><code>mask</code> - Optional mask. If the matrix is not empty, it must be an 8-bit
                array of the same size as <code>images[i]</code>. The non-zero mask elements
                mark the array elements counted in the histogram.
            </dd>
            <dd><code>hist</code> - Output histogram, which is a dense or sparse <code>dims</code>
                -dimensional array.
            </dd>
            <dd><code>histSize</code> - Array of histogram sizes in each dimension.</dd>
            <dd><code>ranges</code> - Array of the <code>dims</code> arrays of the histogram bin
                boundaries in each dimension. When the histogram is uniform (<code>uniform</code>
                =true), then for each dimension <code>i</code> it is enough to specify the
                lower (inclusive) boundary <em>L_0</em> of the 0-th histogram bin and the
                upper (exclusive) boundary <em>U_(histSize[i]-1)</em> for the last histogram
                bin <code>histSize[i]-1</code>. That is, in case of a uniform histogram each
                of <code>ranges[i]</code> is an array of 2 elements. When the histogram is
                not uniform (<code>uniform=false</code>), then each of <code>ranges[i]</code>
                contains <code>histSize[i]+1</code> elements: <em>L_0, U_0=L_1, U_1=L_2,...,
                    U_(histSize[i]-2)=L_(histSize[i]-1), U_(histSize[i]-1)</em>. The array
                elements, that are not between <em>L_0</em> and <em>U_(histSize[i]-1)</em>,
                are not counted in the histogram.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/histograms.html#calchist">org.opencv.imgproc.Imgproc.calcHist</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="calcHist(java.util.List, org.opencv.core.MatOfInt, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfInt, org.opencv.core.MatOfFloat, boolean)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>calcHist</h4>
<pre>public static&nbsp;void&nbsp;calcHist(java.util.List&lt;<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;images,
            <a href="../../../org/opencv/core/MatOfInt.html" title="class in org.opencv.core">MatOfInt</a>&nbsp;channels,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;hist,
            <a href="../../../org/opencv/core/MatOfInt.html" title="class in org.opencv.core">MatOfInt</a>&nbsp;histSize,
            <a href="../../../org/opencv/core/MatOfFloat.html" title="class in org.opencv.core">MatOfFloat</a>&nbsp;ranges,
            boolean&nbsp;accumulate)</pre>
        <div class="block"><p>Calculates a histogram of a set of arrays.</p>

            <p>The functions <code>calcHist</code> calculate the histogram of one or more
                arrays. The elements of a tuple used to increment a histogram bin are taken
                from the correspondinginput arrays at the same location. The sample below
                shows how to compute a 2D Hue-Saturation histogram for a color image.
                <code></p>

            <p>// C++ code:</p>

            <p>#include
                <cv.h>
            </p>

            <p>#include
                <highgui.h>
            </p>

            <p>using namespace cv;</p>

            <p>int main(int argc, char argv)</p>


            <p>Mat src, hsv;</p>

            <p>if(argc != 2 || !(src=imread(argv[1], 1)).data)</p>

            <p>return -1;</p>

            <p>cvtColor(src, hsv, CV_BGR2HSV);</p>

            <p>// Quantize the hue to 30 levels</p>

            <p>// and the saturation to 32 levels</p>

            <p>int hbins = 30, sbins = 32;</p>

            <p>int histSize[] = {hbins, sbins};</p>

            <p>// hue varies from 0 to 179, see cvtColor</p>

            <p>float hranges[] = { 0, 180 };</p>

            <p>// saturation varies from 0 (black-gray-white) to</p>

            <p>// 255 (pure spectrum color)</p>

            <p>float sranges[] = { 0, 256 };</p>

            <p>const float* ranges[] = { hranges, sranges };</p>

            <p>MatND hist;</p>

            <p>// we compute the histogram from the 0-th and 1-st channels</p>

            <p>int channels[] = {0, 1};</p>

            <p>calcHist(&hsv, 1, channels, Mat(), // do not use mask</p>

            <p>hist, 2, histSize, ranges,</p>

            <p>true, // the histogram is uniform</p>

            <p>false);</p>

            <p>double maxVal=0;</p>

            <p>minMaxLoc(hist, 0, &maxVal, 0, 0);</p>

            <p>int scale = 10;</p>

            <p>Mat histImg = Mat.zeros(sbins*scale, hbins*10, CV_8UC3);</p>

            <p>for(int h = 0; h < hbins; h++)</p>

            <p>for(int s = 0; s < sbins; s++)</p>


            <p>float binVal = hist.at
                <float>(h, s);
            </p>

            <p>int intensity = cvRound(binVal*255/maxVal);</p>

            <p>rectangle(histImg, Point(h*scale, s*scale),</p>

            <p>Point((h+1)*scale - 1, (s+1)*scale - 1),</p>

            <p>Scalar.all(intensity),</p>

            <p>CV_FILLED);</p>


            <p>namedWindow("Source", 1);</p>

            <p>imshow("Source", src);</p>

            <p>namedWindow("H-S Histogram", 1);</p>

            <p>imshow("H-S Histogram", histImg);</p>

            <p>waitKey();</p>


            <p>Note: </code></p>
            <ul>
                <li> An example for creating histograms of an image can be found at
                    opencv_source_code/samples/cpp/demhist.cpp
                <li> (Python) An example for creating color histograms can be found at
                    opencv_source/samples/python2/color_histogram.py
                <li> (Python) An example illustrating RGB and grayscale histogram plotting
                    can be found at opencv_source/samples/python2/hist.py
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>images</code> - Source arrays. They all should have the same depth,
                <code>CV_8U</code> or <code>CV_32F</code>, and the same size. Each of them
                can have an arbitrary number of channels.
            </dd>
            <dd><code>channels</code> - List of the <code>dims</code> channels used to compute the
                histogram. The first array channels are numerated from 0 to <code>images[0].channels()-1</code>,
                the second array channels are counted from <code>images[0].channels()</code>
                to <code>images[0].channels() + images[1].channels()-1</code>, and so on.
            </dd>
            <dd><code>mask</code> - Optional mask. If the matrix is not empty, it must be an 8-bit
                array of the same size as <code>images[i]</code>. The non-zero mask elements
                mark the array elements counted in the histogram.
            </dd>
            <dd><code>hist</code> - Output histogram, which is a dense or sparse <code>dims</code>
                -dimensional array.
            </dd>
            <dd><code>histSize</code> - Array of histogram sizes in each dimension.</dd>
            <dd><code>ranges</code> - Array of the <code>dims</code> arrays of the histogram bin
                boundaries in each dimension. When the histogram is uniform (<code>uniform</code>
                =true), then for each dimension <code>i</code> it is enough to specify the
                lower (inclusive) boundary <em>L_0</em> of the 0-th histogram bin and the
                upper (exclusive) boundary <em>U_(histSize[i]-1)</em> for the last histogram
                bin <code>histSize[i]-1</code>. That is, in case of a uniform histogram each
                of <code>ranges[i]</code> is an array of 2 elements. When the histogram is
                not uniform (<code>uniform=false</code>), then each of <code>ranges[i]</code>
                contains <code>histSize[i]+1</code> elements: <em>L_0, U_0=L_1, U_1=L_2,...,
                    U_(histSize[i]-2)=L_(histSize[i]-1), U_(histSize[i]-1)</em>. The array
                elements, that are not between <em>L_0</em> and <em>U_(histSize[i]-1)</em>,
                are not counted in the histogram.
            </dd>
            <dd><code>accumulate</code> - Accumulation flag. If it is set, the histogram is not
                cleared in the beginning when it is allocated. This feature enables you to
                compute a single histogram from several sets of arrays, or to update the
                histogram in time.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/histograms.html#calchist">org.opencv.imgproc.Imgproc.calcHist</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="Canny(org.opencv.core.Mat, org.opencv.core.Mat, double, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>Canny</h4>
<pre>public static&nbsp;void&nbsp;Canny(<a href="../../../org/opencv/core/Mat.html"
                                           title="class in org.opencv.core">Mat</a>&nbsp;image,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;edges,
         double&nbsp;threshold1,
         double&nbsp;threshold2)</pre>
        <div class="block"><p>Finds edges in an image using the [Canny86] algorithm.</p>

            <p>The function finds edges in the input image <code>image</code> and marks them
                in the output map <code>edges</code> using the Canny algorithm. The smallest
                value between <code>threshold1</code> and <code>threshold2</code> is used for
                edge linking. The largest value is used to find initial segments of strong
                edges. See http://en.wikipedia.org/wiki/Canny_edge_detector</p>

            <p>Note:</p>
            <ul>
                <li> An example on using the canny edge detector can be found at
                    opencv_source_code/samples/cpp/edge.cpp
                <li> (Python) An example on using the canny edge detector can be found at
                    opencv_source_code/samples/python/edge.py
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>image</code> - single-channel 8-bit input image.</dd>
            <dd><code>edges</code> - output edge map; it has the same size and type as
                <code>image</code>.
            </dd>
            <dd><code>threshold1</code> - first threshold for the hysteresis procedure.</dd>
            <dd><code>threshold2</code> - second threshold for the hysteresis procedure.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#canny">org.opencv.imgproc.Imgproc.Canny</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="Canny(org.opencv.core.Mat, org.opencv.core.Mat, double, double, int, boolean)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>Canny</h4>
<pre>public static&nbsp;void&nbsp;Canny(<a href="../../../org/opencv/core/Mat.html"
                                           title="class in org.opencv.core">Mat</a>&nbsp;image,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;edges,
         double&nbsp;threshold1,
         double&nbsp;threshold2,
         int&nbsp;apertureSize,
         boolean&nbsp;L2gradient)</pre>
        <div class="block"><p>Finds edges in an image using the [Canny86] algorithm.</p>

            <p>The function finds edges in the input image <code>image</code> and marks them
                in the output map <code>edges</code> using the Canny algorithm. The smallest
                value between <code>threshold1</code> and <code>threshold2</code> is used for
                edge linking. The largest value is used to find initial segments of strong
                edges. See http://en.wikipedia.org/wiki/Canny_edge_detector</p>

            <p>Note:</p>
            <ul>
                <li> An example on using the canny edge detector can be found at
                    opencv_source_code/samples/cpp/edge.cpp
                <li> (Python) An example on using the canny edge detector can be found at
                    opencv_source_code/samples/python/edge.py
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>image</code> - single-channel 8-bit input image.</dd>
            <dd><code>edges</code> - output edge map; it has the same size and type as
                <code>image</code>.
            </dd>
            <dd><code>threshold1</code> - first threshold for the hysteresis procedure.</dd>
            <dd><code>threshold2</code> - second threshold for the hysteresis procedure.</dd>
            <dd><code>apertureSize</code> - aperture size for the "Sobel" operator.</dd>
            <dd><code>L2gradient</code> - a flag, indicating whether a more accurate <em>L_2</em>
                norm <em>=sqrt((dI/dx)^2 + (dI/dy)^2)</em> should be used to calculate the
                image gradient magnitude (<code>L2gradient=true</code>), or whether the
                default <em>L_1</em> norm <em>=|dI/dx|+|dI/dy|</em> is enough
                (<code>L2gradient=false</code>).
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#canny">org.opencv.imgproc.Imgproc.Canny</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="compareHist(org.opencv.core.Mat, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>compareHist</h4>
<pre>public static&nbsp;double&nbsp;compareHist(<a href="../../../org/opencv/core/Mat.html"
                                                   title="class in org.opencv.core">Mat</a>&nbsp;H1,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;H2,
                 int&nbsp;method)</pre>
        <div class="block"><p>Compares two histograms.</p>

            <p>The functions <code>compareHist</code> compare two dense or two sparse
                histograms using the specified method:</p>
            <ul>
                <li> Correlation (<code>method=CV_COMP_CORREL</code>)
            </ul>

            <p><em>d(H_1,H_2) = (sum_I(H_1(I) - H_1")(H_2(I) - H_2"))/(sqrt(sum_I(H_1(I) -
                H_1")^2 sum_I(H_2(I) - H_2")^2))</em></p>

            <p>where</p>

            <p><em>H_k" = 1/(N) sum _J H_k(J)</em></p>

            <p>and <em>N</em> is a total number of histogram bins.</p>
            <ul>
                <li> Chi-Square (<code>method=CV_COMP_CHISQR</code>)
            </ul>

            <p><em>d(H_1,H_2) = sum _I((H_1(I)-H_2(I))^2)/(H_1(I))</em></p>

            <ul>
                <li> Intersection (<code>method=CV_COMP_INTERSECT</code>)
            </ul>

            <p><em>d(H_1,H_2) = sum _I min(H_1(I), H_2(I))</em></p>

            <ul>
                <li> Bhattacharyya distance (<code>method=CV_COMP_BHATTACHARYYA</code> or
                    <code>method=CV_COMP_HELLINGER</code>). In fact, OpenCV computes Hellinger
                    distance, which is related to Bhattacharyya coefficient.
            </ul>

            <p><em>d(H_1,H_2) = sqrt(1 - frac(1)(sqrt(H_1" H_2" N^2)) sum_I sqrt(H_1(I) *
                H_2(I)))</em></p>

            <p>The function returns <em>d(H_1, H_2)</em>.</p>

            <p>While the function works well with 1-, 2-, 3-dimensional dense histograms, it
                may not be suitable for high-dimensional sparse histograms. In such
                histograms, because of aliasing and sampling problems, the coordinates of
                non-zero histogram bins can slightly shift. To compare such histograms or
                more general sparse configurations of weighted points, consider using the
                "EMD" function.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>H1</code> - First compared histogram.</dd>
            <dd><code>H2</code> - Second compared histogram of the same size as <code>H1</code>.
            </dd>
            <dd><code>method</code> - Comparison method that could be one of the following:
                <ul>
                    <li> CV_COMP_CORREL Correlation
                    <li> CV_COMP_CHISQR Chi-Square
                    <li> CV_COMP_INTERSECT Intersection
                    <li> CV_COMP_BHATTACHARYYA Bhattacharyya distance
                    <li> CV_COMP_HELLINGER Synonym for <code>CV_COMP_BHATTACHARYYA</code>
                </ul>
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/histograms.html#comparehist">org.opencv.imgproc.Imgproc.compareHist</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="contourArea(org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>contourArea</h4>
        <pre>public static&nbsp;double&nbsp;contourArea(<a href="../../../org/opencv/core/Mat.html"
                                                           title="class in org.opencv.core">Mat</a>&nbsp;contour)</pre>
        <div class="block"><p>Calculates a contour area.</p>

            <p>The function computes a contour area. Similarly to "moments", the area is
                computed using the Green formula. Thus, the returned area and the number of
                non-zero pixels, if you draw the contour using "drawContours" or "fillPoly",
                can be different.
                Also, the function will most certainly give a wrong results for contours with
                self-intersections.
                Example: <code></p>

            <p>// C++ code:</p>

            <p>vector
                <Point> contour;
            </p>

            <p>contour.push_back(Point2f(0, 0));</p>

            <p>contour.push_back(Point2f(10, 0));</p>

            <p>contour.push_back(Point2f(10, 10));</p>

            <p>contour.push_back(Point2f(5, 4));</p>

            <p>double area0 = contourArea(contour);</p>

            <p>vector
                <Point> approx;
            </p>

            <p>approxPolyDP(contour, approx, 5, true);</p>

            <p>double area1 = contourArea(approx);</p>

            <p>cout << "area0 =" << area0 << endl <<</p>

            <p>"area1 =" << area1 << endl <<</p>

            <p>"approx poly vertices" << approx.size() << endl;</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>contour</code> - Input vector of 2D points (contour vertices), stored in
                <code>std.vector</code> or <code>Mat</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#contourarea">org.opencv.imgproc.Imgproc.contourArea</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="contourArea(org.opencv.core.Mat, boolean)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>contourArea</h4>
<pre>public static&nbsp;double&nbsp;contourArea(<a href="../../../org/opencv/core/Mat.html"
                                                   title="class in org.opencv.core">Mat</a>&nbsp;contour,
                 boolean&nbsp;oriented)</pre>
        <div class="block"><p>Calculates a contour area.</p>

            <p>The function computes a contour area. Similarly to "moments", the area is
                computed using the Green formula. Thus, the returned area and the number of
                non-zero pixels, if you draw the contour using "drawContours" or "fillPoly",
                can be different.
                Also, the function will most certainly give a wrong results for contours with
                self-intersections.
                Example: <code></p>

            <p>// C++ code:</p>

            <p>vector
                <Point> contour;
            </p>

            <p>contour.push_back(Point2f(0, 0));</p>

            <p>contour.push_back(Point2f(10, 0));</p>

            <p>contour.push_back(Point2f(10, 10));</p>

            <p>contour.push_back(Point2f(5, 4));</p>

            <p>double area0 = contourArea(contour);</p>

            <p>vector
                <Point> approx;
            </p>

            <p>approxPolyDP(contour, approx, 5, true);</p>

            <p>double area1 = contourArea(approx);</p>

            <p>cout << "area0 =" << area0 << endl <<</p>

            <p>"area1 =" << area1 << endl <<</p>

            <p>"approx poly vertices" << approx.size() << endl;</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>contour</code> - Input vector of 2D points (contour vertices), stored in
                <code>std.vector</code> or <code>Mat</code>.
            </dd>
            <dd><code>oriented</code> - Oriented area flag. If it is true, the function returns a
                signed area value, depending on the contour orientation (clockwise or
                counter-clockwise). Using this feature you can determine orientation of a
                contour by taking the sign of an area. By default, the parameter is
                <code>false</code>, which means that the absolute value is returned.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#contourarea">org.opencv.imgproc.Imgproc.contourArea</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="convertMaps(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>convertMaps</h4>
<pre>public static&nbsp;void&nbsp;convertMaps(<a href="../../../org/opencv/core/Mat.html"
                                                 title="class in org.opencv.core">Mat</a>&nbsp;map1,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map2,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dstmap1,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dstmap2,
               int&nbsp;dstmap1type)</pre>
        <div class="block"><p>Converts image transformation maps from one representation to
            another.</p>

            <p>The function converts a pair of maps for "remap" from one representation to
                another. The following options (<code>(map1.type(), map2.type())</code>
                <em>-></em> <code>(dstmap1.type(), dstmap2.type())</code>) are supported:</p>
            <ul>
                <li><em>(CV_32FC1, CV_32FC1) -> (CV_16SC2, CV_16UC1)</em>. This is the
                    most frequently used conversion operation, in which the original
                    floating-point maps (see "remap") are converted to a more compact and much
                    faster fixed-point representation. The first output array contains the
                    rounded coordinates and the second array (created only when <code>nninterpolation=false</code>)
                    contains indices in the interpolation tables.
                <li><em>(CV_32FC2) -> (CV_16SC2, CV_16UC1)</em>. The same as above but the
                    original maps are stored in one 2-channel matrix.
                <li> Reverse conversion. Obviously, the reconstructed floating-point maps
                    will not be exactly the same as the originals.
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>map1</code> - The first input map of type <code>CV_16SC2</code>,
                <code>CV_32FC1</code>, or <code>CV_32FC2</code>.
            </dd>
            <dd><code>map2</code> - The second input map of type <code>CV_16UC1</code>,
                <code>CV_32FC1</code>, or none (empty matrix), respectively.
            </dd>
            <dd><code>dstmap1</code> - The first output map that has the type
                <code>dstmap1type</code>
                and the same size as <code>src</code>.
            </dd>
            <dd><code>dstmap2</code> - The second output map.</dd>
            <dd><code>dstmap1type</code> - Type of the first output map that should be
                <code>CV_16SC2</code>, <code>CV_32FC1</code>, or <code>CV_32FC2</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#convertmaps">org.opencv.imgproc.Imgproc.convertMaps</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#remap(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int, org.opencv.core.Scalar)"><code>remap(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#initUndistortRectifyMap(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, org.opencv.core.Mat, org.opencv.core.Mat)"><code>initUndistortRectifyMap(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat,
                    org.opencv.core.Size, int, org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#undistort(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>undistort(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="convertMaps(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, boolean)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>convertMaps</h4>
<pre>public static&nbsp;void&nbsp;convertMaps(<a href="../../../org/opencv/core/Mat.html"
                                                 title="class in org.opencv.core">Mat</a>&nbsp;map1,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map2,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dstmap1,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dstmap2,
               int&nbsp;dstmap1type,
               boolean&nbsp;nninterpolation)</pre>
        <div class="block"><p>Converts image transformation maps from one representation to
            another.</p>

            <p>The function converts a pair of maps for "remap" from one representation to
                another. The following options (<code>(map1.type(), map2.type())</code>
                <em>-></em> <code>(dstmap1.type(), dstmap2.type())</code>) are supported:</p>
            <ul>
                <li><em>(CV_32FC1, CV_32FC1) -> (CV_16SC2, CV_16UC1)</em>. This is the
                    most frequently used conversion operation, in which the original
                    floating-point maps (see "remap") are converted to a more compact and much
                    faster fixed-point representation. The first output array contains the
                    rounded coordinates and the second array (created only when <code>nninterpolation=false</code>)
                    contains indices in the interpolation tables.
                <li><em>(CV_32FC2) -> (CV_16SC2, CV_16UC1)</em>. The same as above but the
                    original maps are stored in one 2-channel matrix.
                <li> Reverse conversion. Obviously, the reconstructed floating-point maps
                    will not be exactly the same as the originals.
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>map1</code> - The first input map of type <code>CV_16SC2</code>,
                <code>CV_32FC1</code>, or <code>CV_32FC2</code>.
            </dd>
            <dd><code>map2</code> - The second input map of type <code>CV_16UC1</code>,
                <code>CV_32FC1</code>, or none (empty matrix), respectively.
            </dd>
            <dd><code>dstmap1</code> - The first output map that has the type
                <code>dstmap1type</code>
                and the same size as <code>src</code>.
            </dd>
            <dd><code>dstmap2</code> - The second output map.</dd>
            <dd><code>dstmap1type</code> - Type of the first output map that should be
                <code>CV_16SC2</code>, <code>CV_32FC1</code>, or <code>CV_32FC2</code>.
            </dd>
            <dd><code>nninterpolation</code> - Flag indicating whether the fixed-point maps are used
                for the nearest-neighbor or for a more complex interpolation.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#convertmaps">org.opencv.imgproc.Imgproc.convertMaps</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#remap(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int, org.opencv.core.Scalar)"><code>remap(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#initUndistortRectifyMap(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, org.opencv.core.Mat, org.opencv.core.Mat)"><code>initUndistortRectifyMap(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat,
                    org.opencv.core.Size, int, org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#undistort(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>undistort(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat,
                    org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="convexHull(org.opencv.core.MatOfPoint, org.opencv.core.MatOfInt)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>convexHull</h4>
<pre>public static&nbsp;void&nbsp;convexHull(<a href="../../../org/opencv/core/MatOfPoint.html"
                                                title="class in org.opencv.core">MatOfPoint</a>&nbsp;points,
              <a href="../../../org/opencv/core/MatOfInt.html" title="class in org.opencv.core">MatOfInt</a>&nbsp;hull)</pre>
        <div class="block"><p>Finds the convex hull of a point set.</p>

            <p>The functions find the convex hull of a 2D point set using the Sklansky's
                algorithm [Sklansky82] that has *O(N logN)* complexity in the current
                implementation. See the OpenCV sample <code>convexhull.cpp</code> that
                demonstrates the usage of different function variants.</p>

            <p>Note:</p>
            <ul>
                <li> An example using the convexHull functionality can be found at
                    opencv_source_code/samples/cpp/convexhull.cpp
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>points</code> - Input 2D point set, stored in <code>std.vector</code> or
                <code>Mat</code>.
            </dd>
            <dd><code>hull</code> - Output convex hull. It is either an integer vector of indices or
                vector of points. In the first case, the <code>hull</code> elements are
                0-based indices of the convex hull points in the original array (since the
                set of convex hull points is a subset of the original point set). In the
                second case, <code>hull</code> elements are the convex hull points
                themselves.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#convexhull">org.opencv.imgproc.Imgproc.convexHull</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="convexHull(org.opencv.core.MatOfPoint, org.opencv.core.MatOfInt, boolean)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>convexHull</h4>
<pre>public static&nbsp;void&nbsp;convexHull(<a href="../../../org/opencv/core/MatOfPoint.html"
                                                title="class in org.opencv.core">MatOfPoint</a>&nbsp;points,
              <a href="../../../org/opencv/core/MatOfInt.html" title="class in org.opencv.core">MatOfInt</a>&nbsp;hull,
              boolean&nbsp;clockwise)</pre>
        <div class="block"><p>Finds the convex hull of a point set.</p>

            <p>The functions find the convex hull of a 2D point set using the Sklansky's
                algorithm [Sklansky82] that has *O(N logN)* complexity in the current
                implementation. See the OpenCV sample <code>convexhull.cpp</code> that
                demonstrates the usage of different function variants.</p>

            <p>Note:</p>
            <ul>
                <li> An example using the convexHull functionality can be found at
                    opencv_source_code/samples/cpp/convexhull.cpp
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>points</code> - Input 2D point set, stored in <code>std.vector</code> or
                <code>Mat</code>.
            </dd>
            <dd><code>hull</code> - Output convex hull. It is either an integer vector of indices or
                vector of points. In the first case, the <code>hull</code> elements are
                0-based indices of the convex hull points in the original array (since the
                set of convex hull points is a subset of the original point set). In the
                second case, <code>hull</code> elements are the convex hull points
                themselves.
            </dd>
            <dd><code>clockwise</code> - Orientation flag. If it is true, the output convex hull is
                oriented clockwise. Otherwise, it is oriented counter-clockwise. The assumed
                coordinate system has its X axis pointing to the right, and its Y axis
                pointing upwards.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#convexhull">org.opencv.imgproc.Imgproc.convexHull</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="convexityDefects(org.opencv.core.MatOfPoint, org.opencv.core.MatOfInt, org.opencv.core.MatOfInt4)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>convexityDefects</h4>
<pre>public static&nbsp;void&nbsp;convexityDefects(<a
        href="../../../org/opencv/core/MatOfPoint.html"
        title="class in org.opencv.core">MatOfPoint</a>&nbsp;contour,
                    <a href="../../../org/opencv/core/MatOfInt.html"
                       title="class in org.opencv.core">MatOfInt</a>&nbsp;convexhull,
                    <a href="../../../org/opencv/core/MatOfInt4.html"
                       title="class in org.opencv.core">MatOfInt4</a>&nbsp;convexityDefects)</pre>
        <div class="block"><p>Finds the convexity defects of a contour.</p>

            <p>The function finds all convexity defects of the input contour and returns a
                sequence of the <code>CvConvexityDefect</code> structures, where
                <code>CvConvexityDetect</code> is defined as: <code></p>

            <p>// C++ code:</p>

            <p>struct CvConvexityDefect</p>


            <p>CvPoint* start; // point of the contour where the defect begins</p>

            <p>CvPoint* end; // point of the contour where the defect ends</p>

            <p>CvPoint* depth_point; // the farthest from the convex hull point within the
                defect</p>

            <p>float depth; // distance between the farthest point and the convex hull</p>

            <p>};</p>

            <p>The figure below displays convexity defects of a hand contour: </code></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>contour</code> - Input contour.</dd>
            <dd><code>convexhull</code> - Convex hull obtained using "convexHull" that should
                contain
                indices of the contour points that make the hull.
            </dd>
            <dd><code>convexityDefects</code> - The output vector of convexity defects. In C++ and
                the new Python/Java interface each convexity defect is represented as
                4-element integer vector (a.k.a. <code>cv.Vec4i</code>): <code>(start_index,
                    end_index, farthest_pt_index, fixpt_depth)</code>, where indices are 0-based
                indices in the original contour of the convexity defect beginning, end and
                the farthest point, and <code>fixpt_depth</code> is fixed-point approximation
                (with 8 fractional bits) of the distance between the farthest contour point
                and the hull. That is, to get the floating-point value of the depth will be
                <code>fixpt_depth/256.0</code>. In C interface convexity defect is
                represented by <code>CvConvexityDefect</code> structure - see below.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#convexitydefects">org.opencv.imgproc.Imgproc.convexityDefects</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="copyMakeBorder(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>copyMakeBorder</h4>
<pre>public static&nbsp;void&nbsp;copyMakeBorder(<a href="../../../org/opencv/core/Mat.html"
                                                    title="class in org.opencv.core">Mat</a>&nbsp;src,
                  <a href="../../../org/opencv/core/Mat.html"
                     title="class in org.opencv.core">Mat</a>&nbsp;dst,
                  int&nbsp;top,
                  int&nbsp;bottom,
                  int&nbsp;left,
                  int&nbsp;right,
                  int&nbsp;borderType)</pre>
        <div class="block"><p>Forms a border around an image.</p>

            <p>The function copies the source image into the middle of the destination
                image. The areas to the left, to the right, above and below the copied source
                image will be filled with extrapolated pixels. This is not what
                "FilterEngine" or filtering functions based on it do (they extrapolate pixels
                on-fly), but what other more complex functions, including your own, may do to
                simplify image boundary handling.
                The function supports the mode when <code>src</code> is already in the middle
                of <code>dst</code>. In this case, the function does not copy
                <code>src</code> itself but simply constructs the border, for example: <code></p>

            <p>// C++ code:</p>

            <p>// let border be the same in all directions</p>

            <p>int border=2;</p>

            <p>// constructs a larger image to fit both the image and the border</p>

            <p>Mat gray_buf(rgb.rows + border*2, rgb.cols + border*2, rgb.depth());</p>

            <p>// select the middle part of it w/o copying data</p>

            <p>Mat gray(gray_canvas, Rect(border, border, rgb.cols, rgb.rows));</p>

            <p>// convert image from RGB to grayscale</p>

            <p>cvtColor(rgb, gray, CV_RGB2GRAY);</p>

            <p>// form a border in-place</p>

            <p>copyMakeBorder(gray, gray_buf, border, border,</p>

            <p>border, border, BORDER_REPLICATE);</p>

            <p>// now do some custom filtering......</p>

            <p>Note: </code></p>

            <p>When the source image is a part (ROI) of a bigger image, the function will
                try to use the pixels outside of the ROI to form a border. To disable this
                feature and always do extrapolation, as if <code>src</code> was not a ROI,
                use <code>borderType | BORDER_ISOLATED</code>.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Source image.</dd>
            <dd><code>dst</code> - Destination image of the same type as <code>src</code> and the
                size <code>Size(src.cols+left+right, src.rows+top+bottom)</code>.
            </dd>
            <dd><code>top</code> - a top</dd>
            <dd><code>bottom</code> - a bottom</dd>
            <dd><code>left</code> - a left</dd>
            <dd><code>right</code> - Parameter specifying how many pixels in each direction from the
                source image rectangle to extrapolate. For example, <code>top=1, bottom=1,
                    left=1, right=1</code> mean that 1 pixel-wide border needs to be built.
            </dd>
            <dd><code>borderType</code> - Border type. See "borderInterpolate" for details.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#copymakeborder">org.opencv.imgproc.Imgproc.copyMakeBorder</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#borderInterpolate(int, int, int)"><code>borderInterpolate(int,
                    int, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="copyMakeBorder(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, int, int, org.opencv.core.Scalar)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>copyMakeBorder</h4>
<pre>public static&nbsp;void&nbsp;copyMakeBorder(<a href="../../../org/opencv/core/Mat.html"
                                                    title="class in org.opencv.core">Mat</a>&nbsp;src,
                  <a href="../../../org/opencv/core/Mat.html"
                     title="class in org.opencv.core">Mat</a>&nbsp;dst,
                  int&nbsp;top,
                  int&nbsp;bottom,
                  int&nbsp;left,
                  int&nbsp;right,
                  int&nbsp;borderType,
                  <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;value)</pre>
        <div class="block"><p>Forms a border around an image.</p>

            <p>The function copies the source image into the middle of the destination
                image. The areas to the left, to the right, above and below the copied source
                image will be filled with extrapolated pixels. This is not what
                "FilterEngine" or filtering functions based on it do (they extrapolate pixels
                on-fly), but what other more complex functions, including your own, may do to
                simplify image boundary handling.
                The function supports the mode when <code>src</code> is already in the middle
                of <code>dst</code>. In this case, the function does not copy
                <code>src</code> itself but simply constructs the border, for example: <code></p>

            <p>// C++ code:</p>

            <p>// let border be the same in all directions</p>

            <p>int border=2;</p>

            <p>// constructs a larger image to fit both the image and the border</p>

            <p>Mat gray_buf(rgb.rows + border*2, rgb.cols + border*2, rgb.depth());</p>

            <p>// select the middle part of it w/o copying data</p>

            <p>Mat gray(gray_canvas, Rect(border, border, rgb.cols, rgb.rows));</p>

            <p>// convert image from RGB to grayscale</p>

            <p>cvtColor(rgb, gray, CV_RGB2GRAY);</p>

            <p>// form a border in-place</p>

            <p>copyMakeBorder(gray, gray_buf, border, border,</p>

            <p>border, border, BORDER_REPLICATE);</p>

            <p>// now do some custom filtering......</p>

            <p>Note: </code></p>

            <p>When the source image is a part (ROI) of a bigger image, the function will
                try to use the pixels outside of the ROI to form a border. To disable this
                feature and always do extrapolation, as if <code>src</code> was not a ROI,
                use <code>borderType | BORDER_ISOLATED</code>.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Source image.</dd>
            <dd><code>dst</code> - Destination image of the same type as <code>src</code> and the
                size <code>Size(src.cols+left+right, src.rows+top+bottom)</code>.
            </dd>
            <dd><code>top</code> - a top</dd>
            <dd><code>bottom</code> - a bottom</dd>
            <dd><code>left</code> - a left</dd>
            <dd><code>right</code> - Parameter specifying how many pixels in each direction from the
                source image rectangle to extrapolate. For example, <code>top=1, bottom=1,
                    left=1, right=1</code> mean that 1 pixel-wide border needs to be built.
            </dd>
            <dd><code>borderType</code> - Border type. See "borderInterpolate" for details.</dd>
            <dd><code>value</code> - Border value if <code>borderType==BORDER_CONSTANT</code>.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#copymakeborder">org.opencv.imgproc.Imgproc.copyMakeBorder</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#borderInterpolate(int, int, int)"><code>borderInterpolate(int,
                    int, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="cornerEigenValsAndVecs(org.opencv.core.Mat, org.opencv.core.Mat, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>cornerEigenValsAndVecs</h4>
<pre>public static&nbsp;void&nbsp;cornerEigenValsAndVecs(<a href="../../../org/opencv/core/Mat.html"
                                                            title="class in org.opencv.core">Mat</a>&nbsp;src,
                          <a href="../../../org/opencv/core/Mat.html"
                             title="class in org.opencv.core">Mat</a>&nbsp;dst,
                          int&nbsp;blockSize,
                          int&nbsp;ksize)</pre>
        <div class="block"><p>Calculates eigenvalues and eigenvectors of image blocks for corner
            detection.</p>

            <p>For every pixel <em>p</em>, the function <code>cornerEigenValsAndVecs</code>
                considers a <code>blockSize</code> <em>x</em> <code>blockSize</code>
                neighborhood <em>S(p)</em>. It calculates the covariation matrix of
                derivatives over the neighborhood as:</p>

            <p><em>M = sum(by: S(p))(dI/dx)^2 sum(by: S(p))(dI/dx dI/dy)^2
                sum(by: S(p))(dI/dx dI/dy)^2 sum(by: S(p))(dI/dy)^2 </em></p>

            <p>where the derivatives are computed using the "Sobel" operator.</p>

            <p>After that, it finds eigenvectors and eigenvalues of <em>M</em> and stores
                them in the destination image as <em>(lambda_1, lambda_2, x_1, y_1, x_2,
                    y_2)</em> where</p>
            <ul>
                <li><em>lambda_1, lambda_2</em> are the non-sorted eigenvalues of
                    <em>M</em>
                <li><em>x_1, y_1</em> are the eigenvectors corresponding to
                    <em>lambda_1</em>
                <li><em>x_2, y_2</em> are the eigenvectors corresponding to
                    <em>lambda_2</em>
            </ul>

            <p>The output of the function can be used for robust edge or corner detection.</p>

            <p>Note:</p>
            <ul>
                <li> (Python) An example on how to use eigenvectors and eigenvalues to
                    estimate image texture flow direction can be found at
                    opencv_source_code/samples/python2/texture_flow.py
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Input single-channel 8-bit or floating-point image.</dd>
            <dd><code>dst</code> - Image to store the results. It has the same size as
                <code>src</code> and the type <code>CV_32FC(6)</code>.
            </dd>
            <dd><code>blockSize</code> - Neighborhood size (see details below).</dd>
            <dd><code>ksize</code> - Aperture parameter for the "Sobel" operator.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#cornereigenvalsandvecs">org.opencv.imgproc.Imgproc.cornerEigenValsAndVecs</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#cornerHarris(org.opencv.core.Mat, org.opencv.core.Mat, int, int, double, int)"><code>cornerHarris(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#cornerMinEigenVal(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int)"><code>cornerMinEigenVal(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#preCornerDetect(org.opencv.core.Mat, org.opencv.core.Mat, int, int)"><code>preCornerDetect(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="cornerEigenValsAndVecs(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>cornerEigenValsAndVecs</h4>
<pre>public static&nbsp;void&nbsp;cornerEigenValsAndVecs(<a href="../../../org/opencv/core/Mat.html"
                                                            title="class in org.opencv.core">Mat</a>&nbsp;src,
                          <a href="../../../org/opencv/core/Mat.html"
                             title="class in org.opencv.core">Mat</a>&nbsp;dst,
                          int&nbsp;blockSize,
                          int&nbsp;ksize,
                          int&nbsp;borderType)</pre>
        <div class="block"><p>Calculates eigenvalues and eigenvectors of image blocks for corner
            detection.</p>

            <p>For every pixel <em>p</em>, the function <code>cornerEigenValsAndVecs</code>
                considers a <code>blockSize</code> <em>x</em> <code>blockSize</code>
                neighborhood <em>S(p)</em>. It calculates the covariation matrix of
                derivatives over the neighborhood as:</p>

            <p><em>M = sum(by: S(p))(dI/dx)^2 sum(by: S(p))(dI/dx dI/dy)^2
                sum(by: S(p))(dI/dx dI/dy)^2 sum(by: S(p))(dI/dy)^2 </em></p>

            <p>where the derivatives are computed using the "Sobel" operator.</p>

            <p>After that, it finds eigenvectors and eigenvalues of <em>M</em> and stores
                them in the destination image as <em>(lambda_1, lambda_2, x_1, y_1, x_2,
                    y_2)</em> where</p>
            <ul>
                <li><em>lambda_1, lambda_2</em> are the non-sorted eigenvalues of
                    <em>M</em>
                <li><em>x_1, y_1</em> are the eigenvectors corresponding to
                    <em>lambda_1</em>
                <li><em>x_2, y_2</em> are the eigenvectors corresponding to
                    <em>lambda_2</em>
            </ul>

            <p>The output of the function can be used for robust edge or corner detection.</p>

            <p>Note:</p>
            <ul>
                <li> (Python) An example on how to use eigenvectors and eigenvalues to
                    estimate image texture flow direction can be found at
                    opencv_source_code/samples/python2/texture_flow.py
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Input single-channel 8-bit or floating-point image.</dd>
            <dd><code>dst</code> - Image to store the results. It has the same size as
                <code>src</code> and the type <code>CV_32FC(6)</code>.
            </dd>
            <dd><code>blockSize</code> - Neighborhood size (see details below).</dd>
            <dd><code>ksize</code> - Aperture parameter for the "Sobel" operator.</dd>
            <dd><code>borderType</code> - Pixel extrapolation method. See "borderInterpolate".</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#cornereigenvalsandvecs">org.opencv.imgproc.Imgproc.cornerEigenValsAndVecs</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#cornerHarris(org.opencv.core.Mat, org.opencv.core.Mat, int, int, double, int)"><code>cornerHarris(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#cornerMinEigenVal(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int)"><code>cornerMinEigenVal(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#preCornerDetect(org.opencv.core.Mat, org.opencv.core.Mat, int, int)"><code>preCornerDetect(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="cornerHarris(org.opencv.core.Mat, org.opencv.core.Mat, int, int, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>cornerHarris</h4>
<pre>public static&nbsp;void&nbsp;cornerHarris(<a href="../../../org/opencv/core/Mat.html"
                                                  title="class in org.opencv.core">Mat</a>&nbsp;src,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                int&nbsp;blockSize,
                int&nbsp;ksize,
                double&nbsp;k)</pre>
        <div class="block"><p>Harris edge detector.</p>

            <p>The function runs the Harris edge detector on the image. Similarly to
                "cornerMinEigenVal" and "cornerEigenValsAndVecs", for each pixel <em>(x,
                    y)</em> it calculates a <em>2x2</em> gradient covariance matrix
                <em>M^((x,y))</em> over a <em>blockSize x blockSize</em> neighborhood. Then,
                it computes the following characteristic:</p>

            <p><em>dst(x,y) = det M^((x,y)) - k * (tr M^((x,y)))^2</em></p>

            <p>Corners in the image can be found as the local maxima of this response map.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Input single-channel 8-bit or floating-point image.</dd>
            <dd><code>dst</code> - Image to store the Harris detector responses. It has the type
                <code>CV_32FC1</code> and the same size as <code>src</code>.
            </dd>
            <dd><code>blockSize</code> - Neighborhood size (see the details on
                "cornerEigenValsAndVecs").
            </dd>
            <dd><code>ksize</code> - Aperture parameter for the "Sobel" operator.</dd>
            <dd><code>k</code> - Harris detector free parameter. See the formula below.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#cornerharris">org.opencv.imgproc.Imgproc.cornerHarris</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="cornerHarris(org.opencv.core.Mat, org.opencv.core.Mat, int, int, double, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>cornerHarris</h4>
<pre>public static&nbsp;void&nbsp;cornerHarris(<a href="../../../org/opencv/core/Mat.html"
                                                  title="class in org.opencv.core">Mat</a>&nbsp;src,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                int&nbsp;blockSize,
                int&nbsp;ksize,
                double&nbsp;k,
                int&nbsp;borderType)</pre>
        <div class="block"><p>Harris edge detector.</p>

            <p>The function runs the Harris edge detector on the image. Similarly to
                "cornerMinEigenVal" and "cornerEigenValsAndVecs", for each pixel <em>(x,
                    y)</em> it calculates a <em>2x2</em> gradient covariance matrix
                <em>M^((x,y))</em> over a <em>blockSize x blockSize</em> neighborhood. Then,
                it computes the following characteristic:</p>

            <p><em>dst(x,y) = det M^((x,y)) - k * (tr M^((x,y)))^2</em></p>

            <p>Corners in the image can be found as the local maxima of this response map.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Input single-channel 8-bit or floating-point image.</dd>
            <dd><code>dst</code> - Image to store the Harris detector responses. It has the type
                <code>CV_32FC1</code> and the same size as <code>src</code>.
            </dd>
            <dd><code>blockSize</code> - Neighborhood size (see the details on
                "cornerEigenValsAndVecs").
            </dd>
            <dd><code>ksize</code> - Aperture parameter for the "Sobel" operator.</dd>
            <dd><code>k</code> - Harris detector free parameter. See the formula below.</dd>
            <dd><code>borderType</code> - Pixel extrapolation method. See "borderInterpolate".</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#cornerharris">org.opencv.imgproc.Imgproc.cornerHarris</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="cornerMinEigenVal(org.opencv.core.Mat, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>cornerMinEigenVal</h4>
<pre>public static&nbsp;void&nbsp;cornerMinEigenVal(<a href="../../../org/opencv/core/Mat.html"
                                                       title="class in org.opencv.core">Mat</a>&nbsp;src,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                     int&nbsp;blockSize)</pre>
        <div class="block"><p>Calculates the minimal eigenvalue of gradient matrices for corner
            detection.</p>

            <p>The function is similar to "cornerEigenValsAndVecs" but it calculates and
                stores only the minimal eigenvalue of the covariance matrix of derivatives,
                that is, <em>min(lambda_1, lambda_2)</em> in terms of the formulae in the
                "cornerEigenValsAndVecs" description.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Input single-channel 8-bit or floating-point image.</dd>
            <dd><code>dst</code> - Image to store the minimal eigenvalues. It has the type
                <code>CV_32FC1</code> and the same size as <code>src</code>.
            </dd>
            <dd><code>blockSize</code> - Neighborhood size (see the details on
                "cornerEigenValsAndVecs").
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#cornermineigenval">org.opencv.imgproc.Imgproc.cornerMinEigenVal</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="cornerMinEigenVal(org.opencv.core.Mat, org.opencv.core.Mat, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>cornerMinEigenVal</h4>
<pre>public static&nbsp;void&nbsp;cornerMinEigenVal(<a href="../../../org/opencv/core/Mat.html"
                                                       title="class in org.opencv.core">Mat</a>&nbsp;src,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                     int&nbsp;blockSize,
                     int&nbsp;ksize)</pre>
        <div class="block"><p>Calculates the minimal eigenvalue of gradient matrices for corner
            detection.</p>

            <p>The function is similar to "cornerEigenValsAndVecs" but it calculates and
                stores only the minimal eigenvalue of the covariance matrix of derivatives,
                that is, <em>min(lambda_1, lambda_2)</em> in terms of the formulae in the
                "cornerEigenValsAndVecs" description.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Input single-channel 8-bit or floating-point image.</dd>
            <dd><code>dst</code> - Image to store the minimal eigenvalues. It has the type
                <code>CV_32FC1</code> and the same size as <code>src</code>.
            </dd>
            <dd><code>blockSize</code> - Neighborhood size (see the details on
                "cornerEigenValsAndVecs").
            </dd>
            <dd><code>ksize</code> - Aperture parameter for the "Sobel" operator.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#cornermineigenval">org.opencv.imgproc.Imgproc.cornerMinEigenVal</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="cornerMinEigenVal(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>cornerMinEigenVal</h4>
<pre>public static&nbsp;void&nbsp;cornerMinEigenVal(<a href="../../../org/opencv/core/Mat.html"
                                                       title="class in org.opencv.core">Mat</a>&nbsp;src,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                     int&nbsp;blockSize,
                     int&nbsp;ksize,
                     int&nbsp;borderType)</pre>
        <div class="block"><p>Calculates the minimal eigenvalue of gradient matrices for corner
            detection.</p>

            <p>The function is similar to "cornerEigenValsAndVecs" but it calculates and
                stores only the minimal eigenvalue of the covariance matrix of derivatives,
                that is, <em>min(lambda_1, lambda_2)</em> in terms of the formulae in the
                "cornerEigenValsAndVecs" description.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Input single-channel 8-bit or floating-point image.</dd>
            <dd><code>dst</code> - Image to store the minimal eigenvalues. It has the type
                <code>CV_32FC1</code> and the same size as <code>src</code>.
            </dd>
            <dd><code>blockSize</code> - Neighborhood size (see the details on
                "cornerEigenValsAndVecs").
            </dd>
            <dd><code>ksize</code> - Aperture parameter for the "Sobel" operator.</dd>
            <dd><code>borderType</code> - Pixel extrapolation method. See "borderInterpolate".</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#cornermineigenval">org.opencv.imgproc.Imgproc.cornerMinEigenVal</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="cornerSubPix(org.opencv.core.Mat, org.opencv.core.MatOfPoint2f, org.opencv.core.Size, org.opencv.core.Size, org.opencv.core.TermCriteria)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>cornerSubPix</h4>
<pre>public static&nbsp;void&nbsp;cornerSubPix(<a href="../../../org/opencv/core/Mat.html"
                                                  title="class in org.opencv.core">Mat</a>&nbsp;image,
                <a href="../../../org/opencv/core/MatOfPoint2f.html"
                   title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;corners,
                <a href="../../../org/opencv/core/Size.html"
                   title="class in org.opencv.core">Size</a>&nbsp;winSize,
                <a href="../../../org/opencv/core/Size.html"
                   title="class in org.opencv.core">Size</a>&nbsp;zeroZone,
                <a href="../../../org/opencv/core/TermCriteria.html"
                   title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria)</pre>
        <div class="block"><p>Refines the corner locations.</p>

            <p>The function iterates to find the sub-pixel accurate location of corners or
                radial saddle points, as shown on the figure below.</p>

            <p>Sub-pixel accurate corner locator is based on the observation that every
                vector from the center <em>q</em> to a point <em>p</em> located within a
                neighborhood of <em>q</em> is orthogonal to the image gradient at <em>p</em>
                subject to image and measurement noise. Consider the expression:</p>

            <p><em>epsilon _i = (DI_(p_i))^T * (q - p_i)</em></p>

            <p>where <em>(DI_(p_i))</em> is an image gradient at one of the points
                <em>p_i</em> in a neighborhood of <em>q</em>. The value of <em>q</em> is to
                be found so that <em>epsilon_i</em> is minimized. A system of equations may
                be set up with <em>epsilon_i</em> set to zero:</p>

            <p><em>sum _i(DI_(p_i) * (DI_(p_i))^T) - sum _i(DI_(p_i) * (DI_(p_i))^T *
                p_i)</em></p>

            <p>where the gradients are summed within a neighborhood ("search window") of
                <em>q</em>. Calling the first gradient term <em>G</em> and the second
                gradient term <em>b</em> gives:</p>

            <p><em>q = G^(-1) * b</em></p>

            <p>The algorithm sets the center of the neighborhood window at this new center
                <em>q</em> and then iterates until the center stays within a set threshold.</p>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>image</code> - Input image.</dd>
            <dd><code>corners</code> - Initial coordinates of the input corners and refined
                coordinates provided for output.
            </dd>
            <dd><code>winSize</code> - Half of the side length of the search window. For example, if
                <code>winSize=Size(5,5)</code>, then a <em>5*2+1 x 5*2+1 = 11 x 11</em>
                search window is used.
            </dd>
            <dd><code>zeroZone</code> - Half of the size of the dead region in the middle of the
                search zone over which the summation in the formula below is not done. It is
                used sometimes to avoid possible singularities of the autocorrelation matrix.
                The value of (-1,-1) indicates that there is no such a size.
            </dd>
            <dd><code>criteria</code> - Criteria for termination of the iterative process of corner
                refinement. That is, the process of corner position refinement stops either
                after <code>criteria.maxCount</code> iterations or when the corner position
                moves by less than <code>criteria.epsilon</code> on some iteration.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#cornersubpix">org.opencv.imgproc.Imgproc.cornerSubPix</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="createHanningWindow(org.opencv.core.Mat, org.opencv.core.Size, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>createHanningWindow</h4>
<pre>public static&nbsp;void&nbsp;createHanningWindow(<a href="../../../org/opencv/core/Mat.html"
                                                         title="class in org.opencv.core">Mat</a>&nbsp;dst,
                       <a href="../../../org/opencv/core/Size.html"
                          title="class in org.opencv.core">Size</a>&nbsp;winSize,
                       int&nbsp;type)</pre>
        <div class="block"><p>This function computes a Hanning window coefficients in two
            dimensions. See
            http://en.wikipedia.org/wiki/Hann_function and
            http://en.wikipedia.org/wiki/Window_function
            for more information.</p>

            <p>An example is shown below: <code></p>

            <p>// C++ code:</p>

            <p>// create hanning window of size 100x100 and type CV_32F</p>

            <p>Mat hann;</p>

            <p>createHanningWindow(hann, Size(100, 100), CV_32F);</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>dst</code> - Destination array to place Hann coefficients in</dd>
            <dd><code>winSize</code> - The window size specifications</dd>
            <dd><code>type</code> - Created array type</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/motion_analysis_and_object_tracking.html#createhanningwindow">org.opencv.imgproc.Imgproc.createHanningWindow</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#phaseCorrelate(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>phaseCorrelate(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="cvtColor(org.opencv.core.Mat, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cvtColor</h4>
<pre>public static&nbsp;void&nbsp;cvtColor(<a href="../../../org/opencv/core/Mat.html"
                                              title="class in org.opencv.core">Mat</a>&nbsp;src,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
            int&nbsp;code)</pre>
<div class="block"><p>Converts an image from one color space to another.</p>

<p>The function converts an input image from one color space to another. In case
    of a transformation to-from RGB color space, the order of the channels should
    be specified explicitly (RGB or BGR).
    Note that the default color format in OpenCV is often referred to as RGB but
    it is actually BGR (the bytes are reversed). So the first byte in a standard
    (24-bit) color image will be an 8-bit Blue component, the second byte will be
    Green, and the third byte will be Red. The fourth, fifth, and sixth bytes
    would then be the second pixel (Blue, then Green, then Red), and so on.</p>

<p>The conventional ranges for R, G, and B channel values are:</p>
<ul>
    <li> 0 to 255 for <code>CV_8U</code> images
    <li> 0 to 65535 for <code>CV_16U</code> images
    <li> 0 to 1 for <code>CV_32F</code> images
</ul>

<p>In case of linear transformations, the range does not matter.
    But in case of a non-linear transformation, an input RGB image should be
    normalized to the proper value range to get the correct results, for example,
    for RGB<em>-></em> L*u*v* transformation. For example, if you have a 32-bit
    floating-point image directly converted from an 8-bit image without any
    scaling, then it will have the 0..255 value range instead of 0..1 assumed by
    the function. So, before calling <code>cvtColor</code>, you need first to
    scale the image down: <code></p>

<p>// C++ code:</p>

<p>img *= 1./255;</p>

<p>cvtColor(img, img, CV_BGR2Luv);</p>

<p>If you use <code>cvtColor</code> with 8-bit images, the conversion will have
    some information lost. For many applications, this will not be noticeable but
    it is recommended to use 32-bit images in applications that need the full
    range of colors or that convert an image before an operation and then convert
    back.
    </code></p>

<p>If conversion adds the alpha channel, its value will set to the maximum of
    corresponding channel range: 255 for <code>CV_8U</code>, 65535 for
    <code>CV_16U</code>, 1 for <code>CV_32F</code>.</p>

<p>The function can do the following transformations:</p>
<ul>
    <li> RGB <em><-></em> GRAY (<code>CV_BGR2GRAY, CV_RGB2GRAY, CV_GRAY2BGR,
        CV_GRAY2RGB</code>) Transformations within RGB space like adding/removing the
        alpha channel, reversing the channel order, conversion to/from 16-bit RGB
        color (R5:G6:B5 or R5:G5:B5), as well as conversion to/from grayscale using:
</ul>

<p><em>RGB[A] to Gray: Y <- 0.299 * R + 0.587 * G + 0.114 * B</em></p>

<p>and</p>

<p><em>Gray to RGB[A]: R <- Y, G <- Y, B <- Y, A <- max(ChannelRange)</em></p>

<p>The conversion from a RGB image to gray is done with:</p>

<p><code></p>

<p>// C++ code:</p>

<p>cvtColor(src, bwsrc, CV_RGB2GRAY);</p>

<p></code></p>

<p>More advanced channel reordering can also be done with "mixChannels".</p>
<ul>
    <li> RGB <em><-></em> CIE XYZ.Rec 709 with D65 white point
        (<code>CV_BGR2XYZ, CV_RGB2XYZ, CV_XYZ2BGR, CV_XYZ2RGB</code>):
</ul>

<p><em>X
    Z ltBR gt <- 0.412453 0.357580 0.180423
    0.212671 0.715160 0.072169
    0.019334 0.119193 0.950227 ltBR gt * R
    B ltBR gt</em></p>


<p><em>R
    B ltBR gt <- 3.240479 -1.53715 -0.498535
    -0.969256 1.875991 0.041556
    0.055648 -0.204043 1.057311 ltBR gt * X
    Z ltBR gt</em></p>

<p><em>X</em>, <em>Y</em> and <em>Z</em> cover the whole value range (in case of
    floating-point images, <em>Z</em> may exceed 1).</p>
<ul>
    <li> RGB <em><-></em> YCrCb JPEG (or YCC) (<code>CV_BGR2YCrCb,
        CV_RGB2YCrCb, CV_YCrCb2BGR, CV_YCrCb2RGB</code>)
</ul>

<p><em>Y <- 0.299 * R + 0.587 * G + 0.114 * B</em></p>


<p><em>Cr <- (R-Y) * 0.713 + delta</em></p>


<p><em>Cb <- (B-Y) * 0.564 + delta</em></p>


<p><em>R <- Y + 1.403 * (Cr - delta)</em></p>


<p><em>G <- Y - 0.714 * (Cr - delta) - 0.344 * (Cb - delta)</em></p>


<p><em>B <- Y + 1.773 * (Cb - delta)</em></p>

<p>where</p>

<p><em>delta = <= ft (128 for 8-bit images
    32768 for 16-bit images
    0.5 for floating-point images right.</em></p>

<p>Y, Cr, and Cb cover the whole value range.</p>
<ul>
    <li> RGB <em><-></em> HSV (<code>CV_BGR2HSV, CV_RGB2HSV, CV_HSV2BGR,
        CV_HSV2RGB</code>) In case of 8-bit and 16-bit images, R, G, and B are
        converted to the floating-point format and scaled to fit the 0 to 1 range.
</ul>

<p><em>V <- max(R,G,B)</em></p>


<p><em>S <- (V-min(R,G,B))/(V) if V != 0; 0 otherwise</em></p>


<p><em>H <- (60(G - B))/((V-min(R,G,B))) if V=R; (120+60(B - R))/((V-min(R,G,B)))
    if V=G; (240+60(R - G))/((V-min(R,G,B))) if V=B</em></p>

<p>If <em>H&lt0</em> then <em>H <- H+360</em>. On output <em>0 <= V <= 1</em>,
    <em>0 <= S <= 1</em>, <em>0 <= H <= 360</em>.</p>

<p>The values are then converted to the destination data type:</p>
<ul>
    <li> 8-bit images
</ul>

<p><em>V <- 255 V, S <- 255 S, H <- H/2(to fit to 0 to 255)</em></p>

<ul>
    <li> 16-bit images (currently not supported)
</ul>

<p><em>V &lt- 65535 V, S &lt- 65535 S, H &lt- H</em></p>

<ul>
    <li> 32-bit images H, S, and V are left as is
    <li> RGB <em><-></em> HLS (<code>CV_BGR2HLS, CV_RGB2HLS, CV_HLS2BGR,
        CV_HLS2RGB</code>).
</ul>
<p>In case of 8-bit and 16-bit images, R, G, and B are converted to the
    floating-point format and scaled to fit the 0 to 1 range.</p>

<p><em>V_(max) <- (max)(R,G,B)</em></p>


<p><em>V_(min) <- (min)(R,G,B)</em></p>


<p><em>L <- (V_(max) + V_(min))/2</em></p>


<p><em>S <- fork ((V_(max) - V_(min))/(V_(max) + V_(min)))(if L &lt
    0.5)&ltBR&gt((V_(max) - V_(min))/(2 - (V_(max) + V_(min))))(if L >= 0.5)</em></p>


<p><em>H <- forkthree ((60(G - B))/(S))(if V_(max)=R)&ltBR&gt((120+60(B -
    R))/(S))(if V_(max)=G)&ltBR&gt((240+60(R - G))/(S))(if V_(max)=B)</em></p>

<p>If <em>H&lt0</em> then <em>H <- H+360</em>. On output <em>0 <= L <= 1</em>,
    <em>0 <= S <= 1</em>, <em>0 <= H <= 360</em>.</p>

<p>The values are then converted to the destination data type:</p>
<ul>
    <li> 8-bit images
</ul>

<p><em>V <- 255 * V, S <- 255 * S, H <- H/2(to fit to 0 to 255)</em></p>

<ul>
    <li> 16-bit images (currently not supported)
</ul>

<p><em>V &lt- 65535 * V, S &lt- 65535 * S, H &lt- H</em></p>

<ul>
    <li> 32-bit images H, S, V are left as is
    <li> RGB <em><-></em> CIE L*a*b* (<code>CV_BGR2Lab, CV_RGB2Lab, CV_Lab2BGR,
        CV_Lab2RGB</code>).
</ul>
<p>In case of 8-bit and 16-bit images, R, G, and B are converted to the
    floating-point format and scaled to fit the 0 to 1 range.</p>

<p><em>[X Y Z] <-
    |0.412453 0.357580 0.180423|
    |0.212671 0.715160 0.072169|
    |0.019334 0.119193 0.950227|</p>
<ul>
    <li> [R G B]</em>


</ul>

<p><em>X <- X/X_n, where X_n = 0.950456</em></p>


<p><em>Z <- Z/Z_n, where Z_n = 1.088754</em></p>


<p><em>L <- 116*Y^(1/3)-16 for Y&gt0.008856; 903.3*Y for Y <= 0.008856</em></p>


<p><em>a <- 500(f(X)-f(Y)) + delta</em></p>


<p><em>b <- 200(f(Y)-f(Z)) + delta</em></p>

<p>where</p>

<p><em>f(t)= t^(1/3) for t&gt0.008856; 7.787 t+16/116 for t <= 0.008856</em></p>

<p>and</p>

<p><em>delta = 128 for 8-bit images; 0 for floating-point images</em></p>

<p>This outputs <em>0 <= L <= 100</em>, <em>-127 <= a <= 127</em>, <em>-127 <= b
    <= 127</em>. The values are then converted to the destination data type:</p>
<ul>
    <li> 8-bit images
</ul>

<p><em>L <- L*255/100, a <- a + 128, b <- b + 128</em></p>

<ul>
    <li> 16-bit images (currently not supported)
    <li> 32-bit images L, a, and b are left as is
    <li> RGB <em><-></em> CIE L*u*v* (<code>CV_BGR2Luv, CV_RGB2Luv, CV_Luv2BGR,
        CV_Luv2RGB</code>).
</ul>
<p>In case of 8-bit and 16-bit images, R, G, and B are converted to the
    floating-point format and scaled to fit 0 to 1 range.</p>

<p><em>[X Y Z] <-
    |0.412453 0.357580 0.180423|
    |0.212671 0.715160 0.072169|
    |0.019334 0.119193 0.950227|</p>
<ul>
    <li> [R G B]</em>


</ul>

<p><em>L <- 116 Y^(1/3) for Y&gt0.008856; 903.3 Y for Y <= 0.008856</em></p>


<p><em>u' <- 4*X/(X + 15*Y + 3 Z)</em></p>


<p><em>v' <- 9*Y/(X + 15*Y + 3 Z)</em></p>


<p><em>u <- 13*L*(u' - u_n) where u_n=0.19793943</em></p>


<p><em>v <- 13*L*(v' - v_n) where v_n=0.46831096</em></p>

<p>This outputs <em>0 <= L <= 100</em>, <em>-134 <= u <= 220</em>, <em>-140 <= v
    <= 122</em>.</p>

<p>The values are then converted to the destination data type:</p>
<ul>
    <li> 8-bit images
</ul>

<p><em>L <- 255/100 L, u <- 255/354(u + 134), v <- 255/262(v + 140)</em></p>

<ul>
    <li> 16-bit images (currently not supported)
    <li> 32-bit images L, u, and v are left as is
</ul>

<p>The above formulae for converting RGB to/from various color spaces have been
    taken from multiple sources on the web, primarily from the Charles Poynton
    site http://www.poynton.com/ColorFAQ.html</p>
<ul>
    <li> Bayer <em>-></em> RGB (<code>CV_BayerBG2BGR, CV_BayerGB2BGR,
        CV_BayerRG2BGR, CV_BayerGR2BGR, CV_BayerBG2RGB, CV_BayerGB2RGB,
        CV_BayerRG2RGB, CV_BayerGR2RGB</code>). The Bayer pattern is widely used in
        CCD and CMOS cameras. It enables you to get color pictures from a single
        plane where R,G, and B pixels (sensors of a particular component) are
        interleaved as follows: The output RGB components of a pixel are interpolated
        from 1, 2, or <code>
</ul>

<p>// C++ code:</p>

<p>4 neighbors of the pixel having the same color. There are several</p>

<p>modifications of the above pattern that can be achieved by shifting</p>

<p>the pattern one pixel left and/or one pixel up. The two letters</p>

<p><em>C_1</em> and</p>

<p><em>C_2</em> in the conversion constants <code>CV_Bayer</code> <em>C_1
    C_2</em> <code>2BGR</code> and <code>CV_Bayer</code> <em>C_1 C_2</em>
    <code>2RGB</code> indicate the particular pattern</p>

<p>type. These are components from the second row, second and third</p>

<p>columns, respectively. For example, the above pattern has a very</p>

<p>popular "BG" type.</p></div>
<dl>
    <dt><span class="strong">Parameters:</span></dt>
    <dd><code>src</code> - input image: 8-bit unsigned, 16-bit unsigned (<code>CV_16UC...</code>),
        or single-precision floating-point.
    </dd>
    <dd><code>dst</code> - output image of the same size and depth as <code>src</code>.</dd>
    <dd><code>code</code> - color space conversion code (see the description below).</dd>
    <dt><span class="strong">See Also:</span></dt>
    <dd>
        <a href="http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#cvtcolor">org.opencv.imgproc.Imgproc.cvtColor</a>
    </dd>
</dl>
</li>
</ul>
<a name="cvtColor(org.opencv.core.Mat, org.opencv.core.Mat, int, int)">
    <!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cvtColor</h4>
<pre>public static&nbsp;void&nbsp;cvtColor(<a href="../../../org/opencv/core/Mat.html"
                                              title="class in org.opencv.core">Mat</a>&nbsp;src,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
            int&nbsp;code,
            int&nbsp;dstCn)</pre>
<div class="block"><p>Converts an image from one color space to another.</p>

<p>The function converts an input image from one color space to another. In case
    of a transformation to-from RGB color space, the order of the channels should
    be specified explicitly (RGB or BGR).
    Note that the default color format in OpenCV is often referred to as RGB but
    it is actually BGR (the bytes are reversed). So the first byte in a standard
    (24-bit) color image will be an 8-bit Blue component, the second byte will be
    Green, and the third byte will be Red. The fourth, fifth, and sixth bytes
    would then be the second pixel (Blue, then Green, then Red), and so on.</p>

<p>The conventional ranges for R, G, and B channel values are:</p>
<ul>
    <li> 0 to 255 for <code>CV_8U</code> images
    <li> 0 to 65535 for <code>CV_16U</code> images
    <li> 0 to 1 for <code>CV_32F</code> images
</ul>

<p>In case of linear transformations, the range does not matter.
    But in case of a non-linear transformation, an input RGB image should be
    normalized to the proper value range to get the correct results, for example,
    for RGB<em>-></em> L*u*v* transformation. For example, if you have a 32-bit
    floating-point image directly converted from an 8-bit image without any
    scaling, then it will have the 0..255 value range instead of 0..1 assumed by
    the function. So, before calling <code>cvtColor</code>, you need first to
    scale the image down: <code></p>

<p>// C++ code:</p>

<p>img *= 1./255;</p>

<p>cvtColor(img, img, CV_BGR2Luv);</p>

<p>If you use <code>cvtColor</code> with 8-bit images, the conversion will have
    some information lost. For many applications, this will not be noticeable but
    it is recommended to use 32-bit images in applications that need the full
    range of colors or that convert an image before an operation and then convert
    back.
    </code></p>

<p>If conversion adds the alpha channel, its value will set to the maximum of
    corresponding channel range: 255 for <code>CV_8U</code>, 65535 for
    <code>CV_16U</code>, 1 for <code>CV_32F</code>.</p>

<p>The function can do the following transformations:</p>
<ul>
    <li> RGB <em><-></em> GRAY (<code>CV_BGR2GRAY, CV_RGB2GRAY, CV_GRAY2BGR,
        CV_GRAY2RGB</code>) Transformations within RGB space like adding/removing the
        alpha channel, reversing the channel order, conversion to/from 16-bit RGB
        color (R5:G6:B5 or R5:G5:B5), as well as conversion to/from grayscale using:
</ul>

<p><em>RGB[A] to Gray: Y <- 0.299 * R + 0.587 * G + 0.114 * B</em></p>

<p>and</p>

<p><em>Gray to RGB[A]: R <- Y, G <- Y, B <- Y, A <- max(ChannelRange)</em></p>

<p>The conversion from a RGB image to gray is done with:</p>

<p><code></p>

<p>// C++ code:</p>

<p>cvtColor(src, bwsrc, CV_RGB2GRAY);</p>

<p></code></p>

<p>More advanced channel reordering can also be done with "mixChannels".</p>
<ul>
    <li> RGB <em><-></em> CIE XYZ.Rec 709 with D65 white point
        (<code>CV_BGR2XYZ, CV_RGB2XYZ, CV_XYZ2BGR, CV_XYZ2RGB</code>):
</ul>

<p><em>X
    Z ltBR gt <- 0.412453 0.357580 0.180423
    0.212671 0.715160 0.072169
    0.019334 0.119193 0.950227 ltBR gt * R
    B ltBR gt</em></p>


<p><em>R
    B ltBR gt <- 3.240479 -1.53715 -0.498535
    -0.969256 1.875991 0.041556
    0.055648 -0.204043 1.057311 ltBR gt * X
    Z ltBR gt</em></p>

<p><em>X</em>, <em>Y</em> and <em>Z</em> cover the whole value range (in case of
    floating-point images, <em>Z</em> may exceed 1).</p>
<ul>
    <li> RGB <em><-></em> YCrCb JPEG (or YCC) (<code>CV_BGR2YCrCb,
        CV_RGB2YCrCb, CV_YCrCb2BGR, CV_YCrCb2RGB</code>)
</ul>

<p><em>Y <- 0.299 * R + 0.587 * G + 0.114 * B</em></p>


<p><em>Cr <- (R-Y) * 0.713 + delta</em></p>


<p><em>Cb <- (B-Y) * 0.564 + delta</em></p>


<p><em>R <- Y + 1.403 * (Cr - delta)</em></p>


<p><em>G <- Y - 0.714 * (Cr - delta) - 0.344 * (Cb - delta)</em></p>


<p><em>B <- Y + 1.773 * (Cb - delta)</em></p>

<p>where</p>

<p><em>delta = <= ft (128 for 8-bit images
    32768 for 16-bit images
    0.5 for floating-point images right.</em></p>

<p>Y, Cr, and Cb cover the whole value range.</p>
<ul>
    <li> RGB <em><-></em> HSV (<code>CV_BGR2HSV, CV_RGB2HSV, CV_HSV2BGR,
        CV_HSV2RGB</code>) In case of 8-bit and 16-bit images, R, G, and B are
        converted to the floating-point format and scaled to fit the 0 to 1 range.
</ul>

<p><em>V <- max(R,G,B)</em></p>


<p><em>S <- (V-min(R,G,B))/(V) if V != 0; 0 otherwise</em></p>


<p><em>H <- (60(G - B))/((V-min(R,G,B))) if V=R; (120+60(B - R))/((V-min(R,G,B)))
    if V=G; (240+60(R - G))/((V-min(R,G,B))) if V=B</em></p>

<p>If <em>H&lt0</em> then <em>H <- H+360</em>. On output <em>0 <= V <= 1</em>,
    <em>0 <= S <= 1</em>, <em>0 <= H <= 360</em>.</p>

<p>The values are then converted to the destination data type:</p>
<ul>
    <li> 8-bit images
</ul>

<p><em>V <- 255 V, S <- 255 S, H <- H/2(to fit to 0 to 255)</em></p>

<ul>
    <li> 16-bit images (currently not supported)
</ul>

<p><em>V &lt- 65535 V, S &lt- 65535 S, H &lt- H</em></p>

<ul>
    <li> 32-bit images H, S, and V are left as is
    <li> RGB <em><-></em> HLS (<code>CV_BGR2HLS, CV_RGB2HLS, CV_HLS2BGR,
        CV_HLS2RGB</code>).
</ul>
<p>In case of 8-bit and 16-bit images, R, G, and B are converted to the
    floating-point format and scaled to fit the 0 to 1 range.</p>

<p><em>V_(max) <- (max)(R,G,B)</em></p>


<p><em>V_(min) <- (min)(R,G,B)</em></p>


<p><em>L <- (V_(max) + V_(min))/2</em></p>


<p><em>S <- fork ((V_(max) - V_(min))/(V_(max) + V_(min)))(if L &lt
    0.5)&ltBR&gt((V_(max) - V_(min))/(2 - (V_(max) + V_(min))))(if L >= 0.5)</em></p>


<p><em>H <- forkthree ((60(G - B))/(S))(if V_(max)=R)&ltBR&gt((120+60(B -
    R))/(S))(if V_(max)=G)&ltBR&gt((240+60(R - G))/(S))(if V_(max)=B)</em></p>

<p>If <em>H&lt0</em> then <em>H <- H+360</em>. On output <em>0 <= L <= 1</em>,
    <em>0 <= S <= 1</em>, <em>0 <= H <= 360</em>.</p>

<p>The values are then converted to the destination data type:</p>
<ul>
    <li> 8-bit images
</ul>

<p><em>V <- 255 * V, S <- 255 * S, H <- H/2(to fit to 0 to 255)</em></p>

<ul>
    <li> 16-bit images (currently not supported)
</ul>

<p><em>V &lt- 65535 * V, S &lt- 65535 * S, H &lt- H</em></p>

<ul>
    <li> 32-bit images H, S, V are left as is
    <li> RGB <em><-></em> CIE L*a*b* (<code>CV_BGR2Lab, CV_RGB2Lab, CV_Lab2BGR,
        CV_Lab2RGB</code>).
</ul>
<p>In case of 8-bit and 16-bit images, R, G, and B are converted to the
    floating-point format and scaled to fit the 0 to 1 range.</p>

<p><em>[X Y Z] <-
    |0.412453 0.357580 0.180423|
    |0.212671 0.715160 0.072169|
    |0.019334 0.119193 0.950227|</p>
<ul>
    <li> [R G B]</em>


</ul>

<p><em>X <- X/X_n, where X_n = 0.950456</em></p>


<p><em>Z <- Z/Z_n, where Z_n = 1.088754</em></p>


<p><em>L <- 116*Y^(1/3)-16 for Y&gt0.008856; 903.3*Y for Y <= 0.008856</em></p>


<p><em>a <- 500(f(X)-f(Y)) + delta</em></p>


<p><em>b <- 200(f(Y)-f(Z)) + delta</em></p>

<p>where</p>

<p><em>f(t)= t^(1/3) for t&gt0.008856; 7.787 t+16/116 for t <= 0.008856</em></p>

<p>and</p>

<p><em>delta = 128 for 8-bit images; 0 for floating-point images</em></p>

<p>This outputs <em>0 <= L <= 100</em>, <em>-127 <= a <= 127</em>, <em>-127 <= b
    <= 127</em>. The values are then converted to the destination data type:</p>
<ul>
    <li> 8-bit images
</ul>

<p><em>L <- L*255/100, a <- a + 128, b <- b + 128</em></p>

<ul>
    <li> 16-bit images (currently not supported)
    <li> 32-bit images L, a, and b are left as is
    <li> RGB <em><-></em> CIE L*u*v* (<code>CV_BGR2Luv, CV_RGB2Luv, CV_Luv2BGR,
        CV_Luv2RGB</code>).
</ul>
<p>In case of 8-bit and 16-bit images, R, G, and B are converted to the
    floating-point format and scaled to fit 0 to 1 range.</p>

<p><em>[X Y Z] <-
    |0.412453 0.357580 0.180423|
    |0.212671 0.715160 0.072169|
    |0.019334 0.119193 0.950227|</p>
<ul>
    <li> [R G B]</em>


</ul>

<p><em>L <- 116 Y^(1/3) for Y&gt0.008856; 903.3 Y for Y <= 0.008856</em></p>


<p><em>u' <- 4*X/(X + 15*Y + 3 Z)</em></p>


<p><em>v' <- 9*Y/(X + 15*Y + 3 Z)</em></p>


<p><em>u <- 13*L*(u' - u_n) where u_n=0.19793943</em></p>


<p><em>v <- 13*L*(v' - v_n) where v_n=0.46831096</em></p>

<p>This outputs <em>0 <= L <= 100</em>, <em>-134 <= u <= 220</em>, <em>-140 <= v
    <= 122</em>.</p>

<p>The values are then converted to the destination data type:</p>
<ul>
    <li> 8-bit images
</ul>

<p><em>L <- 255/100 L, u <- 255/354(u + 134), v <- 255/262(v + 140)</em></p>

<ul>
    <li> 16-bit images (currently not supported)
    <li> 32-bit images L, u, and v are left as is
</ul>

<p>The above formulae for converting RGB to/from various color spaces have been
    taken from multiple sources on the web, primarily from the Charles Poynton
    site http://www.poynton.com/ColorFAQ.html</p>
<ul>
    <li> Bayer <em>-></em> RGB (<code>CV_BayerBG2BGR, CV_BayerGB2BGR,
        CV_BayerRG2BGR, CV_BayerGR2BGR, CV_BayerBG2RGB, CV_BayerGB2RGB,
        CV_BayerRG2RGB, CV_BayerGR2RGB</code>). The Bayer pattern is widely used in
        CCD and CMOS cameras. It enables you to get color pictures from a single
        plane where R,G, and B pixels (sensors of a particular component) are
        interleaved as follows: The output RGB components of a pixel are interpolated
        from 1, 2, or <code>
</ul>

<p>// C++ code:</p>

<p>4 neighbors of the pixel having the same color. There are several</p>

<p>modifications of the above pattern that can be achieved by shifting</p>

<p>the pattern one pixel left and/or one pixel up. The two letters</p>

<p><em>C_1</em> and</p>

<p><em>C_2</em> in the conversion constants <code>CV_Bayer</code> <em>C_1
    C_2</em> <code>2BGR</code> and <code>CV_Bayer</code> <em>C_1 C_2</em>
    <code>2RGB</code> indicate the particular pattern</p>

<p>type. These are components from the second row, second and third</p>

<p>columns, respectively. For example, the above pattern has a very</p>

<p>popular "BG" type.</p></div>
<dl>
    <dt><span class="strong">Parameters:</span></dt>
    <dd><code>src</code> - input image: 8-bit unsigned, 16-bit unsigned (<code>CV_16UC...</code>),
        or single-precision floating-point.
    </dd>
    <dd><code>dst</code> - output image of the same size and depth as <code>src</code>.</dd>
    <dd><code>code</code> - color space conversion code (see the description below).</dd>
    <dd><code>dstCn</code> - number of channels in the destination image; if the parameter is
        0, the number of the channels is derived automatically from <code>src</code>
        and <code>code</code>.
    </dd>
    <dt><span class="strong">See Also:</span></dt>
    <dd>
        <a href="http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#cvtcolor">org.opencv.imgproc.Imgproc.cvtColor</a>
    </dd>
</dl>
</li>
</ul>
<a name="dilate(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>dilate</h4>
<pre>public static&nbsp;void&nbsp;dilate(<a href="../../../org/opencv/core/Mat.html"
                                            title="class in org.opencv.core">Mat</a>&nbsp;src,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel)</pre>
        <div class="block"><p>Dilates an image by using a specific structuring element.</p>

            <p>The function dilates the source image using the specified structuring element
                that determines the shape of a pixel neighborhood over which the maximum is
                taken:</p>

            <p><em>dst(x,y) = max _((x',y'): element(x',y') != 0) src(x+x',y+y')</em></p>

            <p>The function supports the in-place mode. Dilation can be applied several
                (<code>iterations</code>) times. In case of multi-channel images, each
                channel is processed independently.</p>

            <p>Note:</p>
            <ul>
                <li> An example using the morphological dilate operation can be found at
                    opencv_source_code/samples/cpp/morphology2.cpp
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image; the number of channels can be arbitrary, but the
                depth should be one of <code>CV_8U</code>, <code>CV_16U</code>,
                <code>CV_16S</code>, <code>CV_32F" or </code>CV_64F".
            </dd>
            <dd><code>dst</code> - output image of the same size and type as <code>src</code>.</dd>
            <dd><code>kernel</code> - a kernel</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#dilate">org.opencv.imgproc.Imgproc.dilate</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#erode(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, int, int, org.opencv.core.Scalar)"><code>erode(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#morphologyEx(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, int, int, org.opencv.core.Scalar)"><code>morphologyEx(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, int, int,
                    org.opencv.core.Scalar)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="dilate(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>dilate</h4>
<pre>public static&nbsp;void&nbsp;dilate(<a href="../../../org/opencv/core/Mat.html"
                                            title="class in org.opencv.core">Mat</a>&nbsp;src,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
          <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
          int&nbsp;iterations)</pre>
        <div class="block"><p>Dilates an image by using a specific structuring element.</p>

            <p>The function dilates the source image using the specified structuring element
                that determines the shape of a pixel neighborhood over which the maximum is
                taken:</p>

            <p><em>dst(x,y) = max _((x',y'): element(x',y') != 0) src(x+x',y+y')</em></p>

            <p>The function supports the in-place mode. Dilation can be applied several
                (<code>iterations</code>) times. In case of multi-channel images, each
                channel is processed independently.</p>

            <p>Note:</p>
            <ul>
                <li> An example using the morphological dilate operation can be found at
                    opencv_source_code/samples/cpp/morphology2.cpp
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image; the number of channels can be arbitrary, but the
                depth should be one of <code>CV_8U</code>, <code>CV_16U</code>,
                <code>CV_16S</code>, <code>CV_32F" or </code>CV_64F".
            </dd>
            <dd><code>dst</code> - output image of the same size and type as <code>src</code>.</dd>
            <dd><code>kernel</code> - a kernel</dd>
            <dd><code>anchor</code> - position of the anchor within the element; default value
                <code>(-1, -1)</code> means that the anchor is at the element center.
            </dd>
            <dd><code>iterations</code> - number of times dilation is applied.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#dilate">org.opencv.imgproc.Imgproc.dilate</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#erode(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, int, int, org.opencv.core.Scalar)"><code>erode(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#morphologyEx(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, int, int, org.opencv.core.Scalar)"><code>morphologyEx(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, int, int,
                    org.opencv.core.Scalar)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="dilate(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, int, int, org.opencv.core.Scalar)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>dilate</h4>
<pre>public static&nbsp;void&nbsp;dilate(<a href="../../../org/opencv/core/Mat.html"
                                            title="class in org.opencv.core">Mat</a>&nbsp;src,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
          <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
          int&nbsp;iterations,
          int&nbsp;borderType,
          <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;borderValue)</pre>
        <div class="block"><p>Dilates an image by using a specific structuring element.</p>

            <p>The function dilates the source image using the specified structuring element
                that determines the shape of a pixel neighborhood over which the maximum is
                taken:</p>

            <p><em>dst(x,y) = max _((x',y'): element(x',y') != 0) src(x+x',y+y')</em></p>

            <p>The function supports the in-place mode. Dilation can be applied several
                (<code>iterations</code>) times. In case of multi-channel images, each
                channel is processed independently.</p>

            <p>Note:</p>
            <ul>
                <li> An example using the morphological dilate operation can be found at
                    opencv_source_code/samples/cpp/morphology2.cpp
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image; the number of channels can be arbitrary, but the
                depth should be one of <code>CV_8U</code>, <code>CV_16U</code>,
                <code>CV_16S</code>, <code>CV_32F" or </code>CV_64F".
            </dd>
            <dd><code>dst</code> - output image of the same size and type as <code>src</code>.</dd>
            <dd><code>kernel</code> - a kernel</dd>
            <dd><code>anchor</code> - position of the anchor within the element; default value
                <code>(-1, -1)</code> means that the anchor is at the element center.
            </dd>
            <dd><code>iterations</code> - number of times dilation is applied.</dd>
            <dd><code>borderType</code> - pixel extrapolation method (see "borderInterpolate" for
                details).
            </dd>
            <dd><code>borderValue</code> - border value in case of a constant border (see
                "createMorphologyFilter" for details).
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#dilate">org.opencv.imgproc.Imgproc.dilate</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#erode(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, int, int, org.opencv.core.Scalar)"><code>erode(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#morphologyEx(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, int, int, org.opencv.core.Scalar)"><code>morphologyEx(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, int, int,
                    org.opencv.core.Scalar)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="distanceTransform(org.opencv.core.Mat, org.opencv.core.Mat, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>distanceTransform</h4>
<pre>public static&nbsp;void&nbsp;distanceTransform(<a href="../../../org/opencv/core/Mat.html"
                                                       title="class in org.opencv.core">Mat</a>&nbsp;src,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                     int&nbsp;distanceType,
                     int&nbsp;maskSize)</pre>
        <div class="block"><p>Calculates the distance to the closest zero pixel for each pixel of
            the
            source image.</p>

            <p>The functions <code>distanceTransform</code> calculate the approximate or
                precise distance from every binary image pixel to the nearest zero pixel.
                For zero image pixels, the distance will obviously be zero.</p>

            <p>When <code>maskSize == CV_DIST_MASK_PRECISE</code> and <code>distanceType ==
                CV_DIST_L2</code>, the function runs the algorithm described in
                [Felzenszwalb04]. This algorithm is parallelized with the TBB library.</p>

            <p>In other cases, the algorithm [Borgefors86] is used. This means that for a
                pixel the function finds the shortest path to the nearest zero pixel
                consisting of basic shifts: horizontal, vertical, diagonal, or knight's move
                (the latest is available for a <em>5x 5</em> mask). The overall distance is
                calculated as a sum of these basic distances. Since the distance function
                should be symmetric, all of the horizontal and vertical shifts must have the
                same cost (denoted as <code>a</code>), all the diagonal shifts must have the
                same cost (denoted as <code>b</code>), and all knight's moves must have the
                same cost (denoted as <code>c</code>). For the <code>CV_DIST_C</code> and
                <code>CV_DIST_L1</code> types, the distance is calculated precisely, whereas
                for <code>CV_DIST_L2</code> (Euclidean distance) the distance can be
                calculated only with a relative error (a <em>5x 5</em> mask gives more
                accurate results). For <code>a</code>,<code>b</code>, and <code>c</code>,
                OpenCV uses the values suggested in the original paper:</p>

            <p>============== =================== ======================
                <code>CV_DIST_C</code> <em>(3x 3)</em> a = 1, b = 1 \
                ============== =================== ======================
                <code>CV_DIST_L1</code> <em>(3x 3)</em> a = 1, b = 2 \
                <code>CV_DIST_L2</code> <em>(3x 3)</em> a=0.955, b=1.3693 \
                <code>CV_DIST_L2</code> <em>(5x 5)</em> a=1, b=1.4, c=2.1969 \
                ============== =================== ======================</p>

            <p>Typically, for a fast, coarse distance estimation <code>CV_DIST_L2</code>, a
                <em>3x 3</em> mask is used. For a more accurate distance estimation
                <code>CV_DIST_L2</code>, a <em>5x 5</em> mask or the precise algorithm is
                used.
                Note that both the precise and the approximate algorithms are linear on the
                number of pixels.</p>

            <p>The second variant of the function does not only compute the minimum distance
                for each pixel <em>(x, y)</em> but also identifies the nearest connected
                component consisting of zero pixels (<code>labelType==DIST_LABEL_CCOMP</code>)
                or the nearest zero pixel (<code>labelType==DIST_LABEL_PIXEL</code>). Index
                of the component/pixel is stored in <em>labels(x, y)</em>.
                When <code>labelType==DIST_LABEL_CCOMP</code>, the function automatically
                finds connected components of zero pixels in the input image and marks them
                with distinct labels. When <code>labelType==DIST_LABEL_CCOMP</code>, the
                function scans through the input image and marks all the zero pixels with
                distinct labels.</p>

            <p>In this mode, the complexity is still linear.
                That is, the function provides a very fast way to compute the Voronoi diagram
                for a binary image.
                Currently, the second variant can use only the approximate distance transform
                algorithm, i.e. <code>maskSize=CV_DIST_MASK_PRECISE</code> is not supported
                yet.</p>

            <p>Note:</p>
            <ul>
                <li> An example on using the distance transform can be found at
                    opencv_source_code/samples/cpp/distrans.cpp
                <li> (Python) An example on using the distance transform can be found at
                    opencv_source/samples/python2/distrans.py
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - 8-bit, single-channel (binary) source image.</dd>
            <dd><code>dst</code> - Output image with calculated distances. It is a 32-bit
                floating-point, single-channel image of the same size as <code>src</code>.
            </dd>
            <dd><code>distanceType</code> - Type of distance. It can be <code>CV_DIST_L1,
                CV_DIST_L2</code>, or <code>CV_DIST_C</code>.
            </dd>
            <dd><code>maskSize</code> - Size of the distance transform mask. It can be 3, 5, or
                <code>CV_DIST_MASK_PRECISE</code> (the latter option is only supported by the
                first function). In case of the <code>CV_DIST_L1</code> or <code>CV_DIST_C</code>
                distance type, the parameter is forced to 3 because a <em>3x 3</em> mask
                gives the same result as <em>5x 5</em> or any larger aperture.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#distancetransform">org.opencv.imgproc.Imgproc.distanceTransform</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="distanceTransformWithLabels(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>distanceTransformWithLabels</h4>
<pre>public static&nbsp;void&nbsp;distanceTransformWithLabels(<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                               <a href="../../../org/opencv/core/Mat.html"
                                  title="class in org.opencv.core">Mat</a>&nbsp;dst,
                               <a href="../../../org/opencv/core/Mat.html"
                                  title="class in org.opencv.core">Mat</a>&nbsp;labels,
                               int&nbsp;distanceType,
                               int&nbsp;maskSize)</pre>
        <div class="block"><p>Calculates the distance to the closest zero pixel for each pixel of
            the
            source image.</p>

            <p>The functions <code>distanceTransform</code> calculate the approximate or
                precise distance from every binary image pixel to the nearest zero pixel.
                For zero image pixels, the distance will obviously be zero.</p>

            <p>When <code>maskSize == CV_DIST_MASK_PRECISE</code> and <code>distanceType ==
                CV_DIST_L2</code>, the function runs the algorithm described in
                [Felzenszwalb04]. This algorithm is parallelized with the TBB library.</p>

            <p>In other cases, the algorithm [Borgefors86] is used. This means that for a
                pixel the function finds the shortest path to the nearest zero pixel
                consisting of basic shifts: horizontal, vertical, diagonal, or knight's move
                (the latest is available for a <em>5x 5</em> mask). The overall distance is
                calculated as a sum of these basic distances. Since the distance function
                should be symmetric, all of the horizontal and vertical shifts must have the
                same cost (denoted as <code>a</code>), all the diagonal shifts must have the
                same cost (denoted as <code>b</code>), and all knight's moves must have the
                same cost (denoted as <code>c</code>). For the <code>CV_DIST_C</code> and
                <code>CV_DIST_L1</code> types, the distance is calculated precisely, whereas
                for <code>CV_DIST_L2</code> (Euclidean distance) the distance can be
                calculated only with a relative error (a <em>5x 5</em> mask gives more
                accurate results). For <code>a</code>,<code>b</code>, and <code>c</code>,
                OpenCV uses the values suggested in the original paper:</p>

            <p>============== =================== ======================
                <code>CV_DIST_C</code> <em>(3x 3)</em> a = 1, b = 1 \
                ============== =================== ======================
                <code>CV_DIST_L1</code> <em>(3x 3)</em> a = 1, b = 2 \
                <code>CV_DIST_L2</code> <em>(3x 3)</em> a=0.955, b=1.3693 \
                <code>CV_DIST_L2</code> <em>(5x 5)</em> a=1, b=1.4, c=2.1969 \
                ============== =================== ======================</p>

            <p>Typically, for a fast, coarse distance estimation <code>CV_DIST_L2</code>, a
                <em>3x 3</em> mask is used. For a more accurate distance estimation
                <code>CV_DIST_L2</code>, a <em>5x 5</em> mask or the precise algorithm is
                used.
                Note that both the precise and the approximate algorithms are linear on the
                number of pixels.</p>

            <p>The second variant of the function does not only compute the minimum distance
                for each pixel <em>(x, y)</em> but also identifies the nearest connected
                component consisting of zero pixels (<code>labelType==DIST_LABEL_CCOMP</code>)
                or the nearest zero pixel (<code>labelType==DIST_LABEL_PIXEL</code>). Index
                of the component/pixel is stored in <em>labels(x, y)</em>.
                When <code>labelType==DIST_LABEL_CCOMP</code>, the function automatically
                finds connected components of zero pixels in the input image and marks them
                with distinct labels. When <code>labelType==DIST_LABEL_CCOMP</code>, the
                function scans through the input image and marks all the zero pixels with
                distinct labels.</p>

            <p>In this mode, the complexity is still linear.
                That is, the function provides a very fast way to compute the Voronoi diagram
                for a binary image.
                Currently, the second variant can use only the approximate distance transform
                algorithm, i.e. <code>maskSize=CV_DIST_MASK_PRECISE</code> is not supported
                yet.</p>

            <p>Note:</p>
            <ul>
                <li> An example on using the distance transform can be found at
                    opencv_source_code/samples/cpp/distrans.cpp
                <li> (Python) An example on using the distance transform can be found at
                    opencv_source/samples/python2/distrans.py
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - 8-bit, single-channel (binary) source image.</dd>
            <dd><code>dst</code> - Output image with calculated distances. It is a 32-bit
                floating-point, single-channel image of the same size as <code>src</code>.
            </dd>
            <dd><code>labels</code> - Optional output 2D array of labels (the discrete Voronoi
                diagram). It has the type <code>CV_32SC1</code> and the same size as
                <code>src</code>. See the details below.
            </dd>
            <dd><code>distanceType</code> - Type of distance. It can be <code>CV_DIST_L1,
                CV_DIST_L2</code>, or <code>CV_DIST_C</code>.
            </dd>
            <dd><code>maskSize</code> - Size of the distance transform mask. It can be 3, 5, or
                <code>CV_DIST_MASK_PRECISE</code> (the latter option is only supported by the
                first function). In case of the <code>CV_DIST_L1</code> or <code>CV_DIST_C</code>
                distance type, the parameter is forced to 3 because a <em>3x 3</em> mask
                gives the same result as <em>5x 5</em> or any larger aperture.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#distancetransform">org.opencv.imgproc.Imgproc.distanceTransform</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="distanceTransformWithLabels(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>distanceTransformWithLabels</h4>
<pre>public static&nbsp;void&nbsp;distanceTransformWithLabels(<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                               <a href="../../../org/opencv/core/Mat.html"
                                  title="class in org.opencv.core">Mat</a>&nbsp;dst,
                               <a href="../../../org/opencv/core/Mat.html"
                                  title="class in org.opencv.core">Mat</a>&nbsp;labels,
                               int&nbsp;distanceType,
                               int&nbsp;maskSize,
                               int&nbsp;labelType)</pre>
        <div class="block"><p>Calculates the distance to the closest zero pixel for each pixel of
            the
            source image.</p>

            <p>The functions <code>distanceTransform</code> calculate the approximate or
                precise distance from every binary image pixel to the nearest zero pixel.
                For zero image pixels, the distance will obviously be zero.</p>

            <p>When <code>maskSize == CV_DIST_MASK_PRECISE</code> and <code>distanceType ==
                CV_DIST_L2</code>, the function runs the algorithm described in
                [Felzenszwalb04]. This algorithm is parallelized with the TBB library.</p>

            <p>In other cases, the algorithm [Borgefors86] is used. This means that for a
                pixel the function finds the shortest path to the nearest zero pixel
                consisting of basic shifts: horizontal, vertical, diagonal, or knight's move
                (the latest is available for a <em>5x 5</em> mask). The overall distance is
                calculated as a sum of these basic distances. Since the distance function
                should be symmetric, all of the horizontal and vertical shifts must have the
                same cost (denoted as <code>a</code>), all the diagonal shifts must have the
                same cost (denoted as <code>b</code>), and all knight's moves must have the
                same cost (denoted as <code>c</code>). For the <code>CV_DIST_C</code> and
                <code>CV_DIST_L1</code> types, the distance is calculated precisely, whereas
                for <code>CV_DIST_L2</code> (Euclidean distance) the distance can be
                calculated only with a relative error (a <em>5x 5</em> mask gives more
                accurate results). For <code>a</code>,<code>b</code>, and <code>c</code>,
                OpenCV uses the values suggested in the original paper:</p>

            <p>============== =================== ======================
                <code>CV_DIST_C</code> <em>(3x 3)</em> a = 1, b = 1 \
                ============== =================== ======================
                <code>CV_DIST_L1</code> <em>(3x 3)</em> a = 1, b = 2 \
                <code>CV_DIST_L2</code> <em>(3x 3)</em> a=0.955, b=1.3693 \
                <code>CV_DIST_L2</code> <em>(5x 5)</em> a=1, b=1.4, c=2.1969 \
                ============== =================== ======================</p>

            <p>Typically, for a fast, coarse distance estimation <code>CV_DIST_L2</code>, a
                <em>3x 3</em> mask is used. For a more accurate distance estimation
                <code>CV_DIST_L2</code>, a <em>5x 5</em> mask or the precise algorithm is
                used.
                Note that both the precise and the approximate algorithms are linear on the
                number of pixels.</p>

            <p>The second variant of the function does not only compute the minimum distance
                for each pixel <em>(x, y)</em> but also identifies the nearest connected
                component consisting of zero pixels (<code>labelType==DIST_LABEL_CCOMP</code>)
                or the nearest zero pixel (<code>labelType==DIST_LABEL_PIXEL</code>). Index
                of the component/pixel is stored in <em>labels(x, y)</em>.
                When <code>labelType==DIST_LABEL_CCOMP</code>, the function automatically
                finds connected components of zero pixels in the input image and marks them
                with distinct labels. When <code>labelType==DIST_LABEL_CCOMP</code>, the
                function scans through the input image and marks all the zero pixels with
                distinct labels.</p>

            <p>In this mode, the complexity is still linear.
                That is, the function provides a very fast way to compute the Voronoi diagram
                for a binary image.
                Currently, the second variant can use only the approximate distance transform
                algorithm, i.e. <code>maskSize=CV_DIST_MASK_PRECISE</code> is not supported
                yet.</p>

            <p>Note:</p>
            <ul>
                <li> An example on using the distance transform can be found at
                    opencv_source_code/samples/cpp/distrans.cpp
                <li> (Python) An example on using the distance transform can be found at
                    opencv_source/samples/python2/distrans.py
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - 8-bit, single-channel (binary) source image.</dd>
            <dd><code>dst</code> - Output image with calculated distances. It is a 32-bit
                floating-point, single-channel image of the same size as <code>src</code>.
            </dd>
            <dd><code>labels</code> - Optional output 2D array of labels (the discrete Voronoi
                diagram). It has the type <code>CV_32SC1</code> and the same size as
                <code>src</code>. See the details below.
            </dd>
            <dd><code>distanceType</code> - Type of distance. It can be <code>CV_DIST_L1,
                CV_DIST_L2</code>, or <code>CV_DIST_C</code>.
            </dd>
            <dd><code>maskSize</code> - Size of the distance transform mask. It can be 3, 5, or
                <code>CV_DIST_MASK_PRECISE</code> (the latter option is only supported by the
                first function). In case of the <code>CV_DIST_L1</code> or <code>CV_DIST_C</code>
                distance type, the parameter is forced to 3 because a <em>3x 3</em> mask
                gives the same result as <em>5x 5</em> or any larger aperture.
            </dd>
            <dd><code>labelType</code> - Type of the label array to build. If <code>labelType==DIST_LABEL_CCOMP</code>
                then each connected component of zeros in <code>src</code> (as well as all
                the non-zero pixels closest to the connected component) will be assigned the
                same label. If <code>labelType==DIST_LABEL_PIXEL</code> then each zero pixel
                (and all the non-zero pixels closest to it) gets its own label.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#distancetransform">org.opencv.imgproc.Imgproc.distanceTransform</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="drawContours(org.opencv.core.Mat, java.util.List, int, org.opencv.core.Scalar)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>drawContours</h4>
<pre>public static&nbsp;void&nbsp;drawContours(<a href="../../../org/opencv/core/Mat.html"
                                                  title="class in org.opencv.core">Mat</a>&nbsp;image,
                java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html"
                                     title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;contours,
                int&nbsp;contourIdx,
                <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</pre>
        <div class="block"><p>Draws contours outlines or filled contours.</p>

            <p>The function draws contour outlines in the image if <em>thickness >= 0</em>
                or fills the area bounded by the contours if<em>thickness&lt0</em>. The
                example below shows how to retrieve connected components from the binary
                image and label them: <code></p>

            <p>// C++ code:</p>

            <p>#include "cv.h"</p>

            <p>#include "highgui.h"</p>

            <p>using namespace cv;</p>

            <p>int main(int argc, char argv)</p>


            <p>Mat src;</p>

            <p>// the first command-line parameter must be a filename of the binary</p>

            <p>// (black-n-white) image</p>

            <p>if(argc != 2 || !(src=imread(argv[1], 0)).data)</p>

            <p>return -1;</p>

            <p>Mat dst = Mat.zeros(src.rows, src.cols, CV_8UC3);</p>

            <p>src = src > 1;</p>

            <p>namedWindow("Source", 1);</p>

            <p>imshow("Source", src);</p>

            <p>vector
                <vector
                <Point> > contours;
            </p>

            <p>vector
                <Vec4i> hierarchy;
            </p>

            <p>findContours(src, contours, hierarchy,</p>

            <p>CV_RETR_CCOMP, CV_CHAIN_APPROX_SIMPLE);</p>

            <p>// iterate through all the top-level contours,</p>

            <p>// draw each connected component with its own random color</p>

            <p>int idx = 0;</p>

            <p>for(; idx >= 0; idx = hierarchy[idx][0])</p>


            <p>Scalar color(rand()&255, rand()&255, rand()&255);</p>

            <p>drawContours(dst, contours, idx, color, CV_FILLED, 8, hierarchy);</p>


            <p>namedWindow("Components", 1);</p>

            <p>imshow("Components", dst);</p>

            <p>waitKey(0);</p>


            <p>Note: </code></p>
            <ul>
                <li> An example using the drawContour functionality can be found at
                    opencv_source_code/samples/cpp/contours2.cpp
                <li> An example using drawContours to clean up a background segmentation
                    result at opencv_source_code/samples/cpp/segment_objects.cpp
                <li> (Python) An example using the drawContour functionality can be found
                    at opencv_source/samples/python2/contours.py
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>image</code> - Destination image.</dd>
            <dd><code>contours</code> - All the input contours. Each contour is stored as a point
                vector.
            </dd>
            <dd><code>contourIdx</code> - Parameter indicating a contour to draw. If it is negative,
                all the contours are drawn.
            </dd>
            <dd><code>color</code> - Color of the contours.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#drawcontours">org.opencv.imgproc.Imgproc.drawContours</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="drawContours(org.opencv.core.Mat, java.util.List, int, org.opencv.core.Scalar, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>drawContours</h4>
<pre>public static&nbsp;void&nbsp;drawContours(<a href="../../../org/opencv/core/Mat.html"
                                                  title="class in org.opencv.core">Mat</a>&nbsp;image,
                java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html"
                                     title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;contours,
                int&nbsp;contourIdx,
                <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                int&nbsp;thickness)</pre>
        <div class="block"><p>Draws contours outlines or filled contours.</p>

            <p>The function draws contour outlines in the image if <em>thickness >= 0</em>
                or fills the area bounded by the contours if<em>thickness&lt0</em>. The
                example below shows how to retrieve connected components from the binary
                image and label them: <code></p>

            <p>// C++ code:</p>

            <p>#include "cv.h"</p>

            <p>#include "highgui.h"</p>

            <p>using namespace cv;</p>

            <p>int main(int argc, char argv)</p>


            <p>Mat src;</p>

            <p>// the first command-line parameter must be a filename of the binary</p>

            <p>// (black-n-white) image</p>

            <p>if(argc != 2 || !(src=imread(argv[1], 0)).data)</p>

            <p>return -1;</p>

            <p>Mat dst = Mat.zeros(src.rows, src.cols, CV_8UC3);</p>

            <p>src = src > 1;</p>

            <p>namedWindow("Source", 1);</p>

            <p>imshow("Source", src);</p>

            <p>vector
                <vector
                <Point> > contours;
            </p>

            <p>vector
                <Vec4i> hierarchy;
            </p>

            <p>findContours(src, contours, hierarchy,</p>

            <p>CV_RETR_CCOMP, CV_CHAIN_APPROX_SIMPLE);</p>

            <p>// iterate through all the top-level contours,</p>

            <p>// draw each connected component with its own random color</p>

            <p>int idx = 0;</p>

            <p>for(; idx >= 0; idx = hierarchy[idx][0])</p>


            <p>Scalar color(rand()&255, rand()&255, rand()&255);</p>

            <p>drawContours(dst, contours, idx, color, CV_FILLED, 8, hierarchy);</p>


            <p>namedWindow("Components", 1);</p>

            <p>imshow("Components", dst);</p>

            <p>waitKey(0);</p>


            <p>Note: </code></p>
            <ul>
                <li> An example using the drawContour functionality can be found at
                    opencv_source_code/samples/cpp/contours2.cpp
                <li> An example using drawContours to clean up a background segmentation
                    result at opencv_source_code/samples/cpp/segment_objects.cpp
                <li> (Python) An example using the drawContour functionality can be found
                    at opencv_source/samples/python2/contours.py
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>image</code> - Destination image.</dd>
            <dd><code>contours</code> - All the input contours. Each contour is stored as a point
                vector.
            </dd>
            <dd><code>contourIdx</code> - Parameter indicating a contour to draw. If it is negative,
                all the contours are drawn.
            </dd>
            <dd><code>color</code> - Color of the contours.</dd>
            <dd><code>thickness</code> - Thickness of lines the contours are drawn with. If it is
                negative (for example, <code>thickness=CV_FILLED</code>), the contour
                interiors are drawn.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#drawcontours">org.opencv.imgproc.Imgproc.drawContours</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="drawContours(org.opencv.core.Mat, java.util.List, int, org.opencv.core.Scalar, int, int, org.opencv.core.Mat, int, org.opencv.core.Point)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>drawContours</h4>
<pre>public static&nbsp;void&nbsp;drawContours(<a href="../../../org/opencv/core/Mat.html"
                                                  title="class in org.opencv.core">Mat</a>&nbsp;image,
                java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html"
                                     title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;contours,
                int&nbsp;contourIdx,
                <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                int&nbsp;thickness,
                int&nbsp;lineType,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;hierarchy,
                int&nbsp;maxLevel,
                <a href="../../../org/opencv/core/Point.html"
                   title="class in org.opencv.core">Point</a>&nbsp;offset)</pre>
        <div class="block"><p>Draws contours outlines or filled contours.</p>

            <p>The function draws contour outlines in the image if <em>thickness >= 0</em>
                or fills the area bounded by the contours if<em>thickness&lt0</em>. The
                example below shows how to retrieve connected components from the binary
                image and label them: <code></p>

            <p>// C++ code:</p>

            <p>#include "cv.h"</p>

            <p>#include "highgui.h"</p>

            <p>using namespace cv;</p>

            <p>int main(int argc, char argv)</p>


            <p>Mat src;</p>

            <p>// the first command-line parameter must be a filename of the binary</p>

            <p>// (black-n-white) image</p>

            <p>if(argc != 2 || !(src=imread(argv[1], 0)).data)</p>

            <p>return -1;</p>

            <p>Mat dst = Mat.zeros(src.rows, src.cols, CV_8UC3);</p>

            <p>src = src > 1;</p>

            <p>namedWindow("Source", 1);</p>

            <p>imshow("Source", src);</p>

            <p>vector
                <vector
                <Point> > contours;
            </p>

            <p>vector
                <Vec4i> hierarchy;
            </p>

            <p>findContours(src, contours, hierarchy,</p>

            <p>CV_RETR_CCOMP, CV_CHAIN_APPROX_SIMPLE);</p>

            <p>// iterate through all the top-level contours,</p>

            <p>// draw each connected component with its own random color</p>

            <p>int idx = 0;</p>

            <p>for(; idx >= 0; idx = hierarchy[idx][0])</p>


            <p>Scalar color(rand()&255, rand()&255, rand()&255);</p>

            <p>drawContours(dst, contours, idx, color, CV_FILLED, 8, hierarchy);</p>


            <p>namedWindow("Components", 1);</p>

            <p>imshow("Components", dst);</p>

            <p>waitKey(0);</p>


            <p>Note: </code></p>
            <ul>
                <li> An example using the drawContour functionality can be found at
                    opencv_source_code/samples/cpp/contours2.cpp
                <li> An example using drawContours to clean up a background segmentation
                    result at opencv_source_code/samples/cpp/segment_objects.cpp
                <li> (Python) An example using the drawContour functionality can be found
                    at opencv_source/samples/python2/contours.py
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>image</code> - Destination image.</dd>
            <dd><code>contours</code> - All the input contours. Each contour is stored as a point
                vector.
            </dd>
            <dd><code>contourIdx</code> - Parameter indicating a contour to draw. If it is negative,
                all the contours are drawn.
            </dd>
            <dd><code>color</code> - Color of the contours.</dd>
            <dd><code>thickness</code> - Thickness of lines the contours are drawn with. If it is
                negative (for example, <code>thickness=CV_FILLED</code>), the contour
                interiors are drawn.
            </dd>
            <dd><code>lineType</code> - Line connectivity. See "line" for details.</dd>
            <dd><code>hierarchy</code> - Optional information about hierarchy. It is only needed if
                you want to draw only some of the contours (see <code>maxLevel</code>).
            </dd>
            <dd><code>maxLevel</code> - Maximal level for drawn contours. If it is 0, only the
                specified contour is drawn. If it is 1, the function draws the contour(s) and
                all the nested contours. If it is 2, the function draws the contours, all the
                nested contours, all the nested-to-nested contours, and so on. This parameter
                is only taken into account when there is <code>hierarchy</code> available.
            </dd>
            <dd><code>offset</code> - Optional contour shift parameter. Shift all the drawn contours
                by the specified <em>offset=(dx,dy)</em>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#drawcontours">org.opencv.imgproc.Imgproc.drawContours</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="equalizeHist(org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>equalizeHist</h4>
<pre>public static&nbsp;void&nbsp;equalizeHist(<a href="../../../org/opencv/core/Mat.html"
                                                  title="class in org.opencv.core">Mat</a>&nbsp;src,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Equalizes the histogram of a grayscale image.</p>

            <p>The function equalizes the histogram of the input image using the following
                algorithm:</p>
            <ul>
                <li> Calculate the histogram <em>H</em> for <code>src</code>.
                <li> Normalize the histogram so that the sum of histogram bins is 255.
                <li> Compute the integral of the histogram:
            </ul>

            <p><em>H'_i = sum(by: 0 <= j &lt i) H(j)</em></p>

            <ul>
                <li>
            </ul>
            <p>Transform the image using <em>H'</em> as a look-up table: <em>dst(x,y) =
                H'(src(x,y))</em></p>

            <p>The algorithm normalizes the brightness and increases the contrast of the
                image.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Source 8-bit single channel image.</dd>
            <dd><code>dst</code> - Destination image of the same size and type as <code>src</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/histograms.html#equalizehist">org.opencv.imgproc.Imgproc.equalizeHist</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="erode(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>erode</h4>
<pre>public static&nbsp;void&nbsp;erode(<a href="../../../org/opencv/core/Mat.html"
                                           title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel)</pre>
        <div class="block"><p>Erodes an image by using a specific structuring element.</p>

            <p>The function erodes the source image using the specified structuring element
                that determines the shape of a pixel neighborhood over which the minimum is
                taken:</p>

            <p><em>dst(x,y) = min _((x',y'): element(x',y') != 0) src(x+x',y+y')</em></p>

            <p>The function supports the in-place mode. Erosion can be applied several
                (<code>iterations</code>) times. In case of multi-channel images, each
                channel is processed independently.</p>

            <p>Note:</p>
            <ul>
                <li> An example using the morphological erode operation can be found at
                    opencv_source_code/samples/cpp/morphology2.cpp
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image; the number of channels can be arbitrary, but the
                depth should be one of <code>CV_8U</code>, <code>CV_16U</code>,
                <code>CV_16S</code>, <code>CV_32F" or </code>CV_64F".
            </dd>
            <dd><code>dst</code> - output image of the same size and type as <code>src</code>.</dd>
            <dd><code>kernel</code> - a kernel</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#erode">org.opencv.imgproc.Imgproc.erode</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#morphologyEx(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, int, int, org.opencv.core.Scalar)"><code>morphologyEx(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#dilate(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, int, int, org.opencv.core.Scalar)"><code>dilate(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, int, int,
                    org.opencv.core.Scalar)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="erode(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>erode</h4>
<pre>public static&nbsp;void&nbsp;erode(<a href="../../../org/opencv/core/Mat.html"
                                           title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
         <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
         int&nbsp;iterations)</pre>
        <div class="block"><p>Erodes an image by using a specific structuring element.</p>

            <p>The function erodes the source image using the specified structuring element
                that determines the shape of a pixel neighborhood over which the minimum is
                taken:</p>

            <p><em>dst(x,y) = min _((x',y'): element(x',y') != 0) src(x+x',y+y')</em></p>

            <p>The function supports the in-place mode. Erosion can be applied several
                (<code>iterations</code>) times. In case of multi-channel images, each
                channel is processed independently.</p>

            <p>Note:</p>
            <ul>
                <li> An example using the morphological erode operation can be found at
                    opencv_source_code/samples/cpp/morphology2.cpp
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image; the number of channels can be arbitrary, but the
                depth should be one of <code>CV_8U</code>, <code>CV_16U</code>,
                <code>CV_16S</code>, <code>CV_32F" or </code>CV_64F".
            </dd>
            <dd><code>dst</code> - output image of the same size and type as <code>src</code>.</dd>
            <dd><code>kernel</code> - a kernel</dd>
            <dd><code>anchor</code> - position of the anchor within the element; default value
                <code>(-1, -1)</code> means that the anchor is at the element center.
            </dd>
            <dd><code>iterations</code> - number of times erosion is applied.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#erode">org.opencv.imgproc.Imgproc.erode</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#morphologyEx(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, int, int, org.opencv.core.Scalar)"><code>morphologyEx(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#dilate(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, int, int, org.opencv.core.Scalar)"><code>dilate(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, int, int,
                    org.opencv.core.Scalar)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="erode(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, int, int, org.opencv.core.Scalar)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>erode</h4>
<pre>public static&nbsp;void&nbsp;erode(<a href="../../../org/opencv/core/Mat.html"
                                           title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
         <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
         int&nbsp;iterations,
         int&nbsp;borderType,
         <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;borderValue)</pre>
        <div class="block"><p>Erodes an image by using a specific structuring element.</p>

            <p>The function erodes the source image using the specified structuring element
                that determines the shape of a pixel neighborhood over which the minimum is
                taken:</p>

            <p><em>dst(x,y) = min _((x',y'): element(x',y') != 0) src(x+x',y+y')</em></p>

            <p>The function supports the in-place mode. Erosion can be applied several
                (<code>iterations</code>) times. In case of multi-channel images, each
                channel is processed independently.</p>

            <p>Note:</p>
            <ul>
                <li> An example using the morphological erode operation can be found at
                    opencv_source_code/samples/cpp/morphology2.cpp
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image; the number of channels can be arbitrary, but the
                depth should be one of <code>CV_8U</code>, <code>CV_16U</code>,
                <code>CV_16S</code>, <code>CV_32F" or </code>CV_64F".
            </dd>
            <dd><code>dst</code> - output image of the same size and type as <code>src</code>.</dd>
            <dd><code>kernel</code> - a kernel</dd>
            <dd><code>anchor</code> - position of the anchor within the element; default value
                <code>(-1, -1)</code> means that the anchor is at the element center.
            </dd>
            <dd><code>iterations</code> - number of times erosion is applied.</dd>
            <dd><code>borderType</code> - pixel extrapolation method (see "borderInterpolate" for
                details).
            </dd>
            <dd><code>borderValue</code> - border value in case of a constant border (see
                "createMorphologyFilter" for details).
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#erode">org.opencv.imgproc.Imgproc.erode</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#morphologyEx(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, int, int, org.opencv.core.Scalar)"><code>morphologyEx(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#dilate(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, int, int, org.opencv.core.Scalar)"><code>dilate(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, int, int,
                    org.opencv.core.Scalar)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="filter2D(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>filter2D</h4>
<pre>public static&nbsp;void&nbsp;filter2D(<a href="../../../org/opencv/core/Mat.html"
                                              title="class in org.opencv.core">Mat</a>&nbsp;src,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
            int&nbsp;ddepth,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel)</pre>
        <div class="block"><p>Convolves an image with the kernel.</p>

            <p>The function applies an arbitrary linear filter to an image. In-place
                operation is supported. When the aperture is partially outside the image, the
                function interpolates outlier pixel values according to the specified border
                mode.</p>

            <p>The function does actually compute correlation, not the convolution:</p>

            <p><em>dst(x,y) = sum(by: 0 <= x' &lt kernel.cols, 0 <= y' &lt kernel.rows)
                kernel(x',y')* src(x+x'- anchor.x,y+y'- anchor.y)</em></p>

            <p>That is, the kernel is not mirrored around the anchor point. If you need a
                real convolution, flip the kernel using "flip" and set the new anchor to
                <code>(kernel.cols - anchor.x - 1, kernel.rows - anchor.y - 1)</code>.</p>

            <p>The function uses the DFT-based algorithm in case of sufficiently large
                kernels (~<code>11 x 11</code> or larger) and the direct algorithm (that uses
                the engine retrieved by "createLinearFilter") for small kernels.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image.</dd>
            <dd><code>dst</code> - output image of the same size and the same number of channels as
                <code>src</code>.
            </dd>
            <dd><code>ddepth</code> - desired depth of the destination image; if it is negative, it
                will be the same as <code>src.depth()</code>; the following combinations of
                <code>src.depth()</code> and <code>ddepth</code> are supported:
                <ul>
                    <li><code>src.depth()</code> = <code>CV_8U</code>, <code>ddepth</code> =
                        -1/<code>CV_16S</code>/<code>CV_32F</code>/<code>CV_64F</code>
                    <li><code>src.depth()</code> = <code>CV_16U</code>/<code>CV_16S</code>,
                        <code>ddepth</code> = -1/<code>CV_32F</code>/<code>CV_64F</code>
                    <li><code>src.depth()</code> = <code>CV_32F</code>, <code>ddepth</code> =
                        -1/<code>CV_32F</code>/<code>CV_64F</code>
                    <li><code>src.depth()</code> = <code>CV_64F</code>, <code>ddepth</code> =
                        -1/<code>CV_64F</code>
                </ul>

                <p>when <code>ddepth=-1</code>, the output image will have the same depth as the
                    source.</p></dd>
            <dd><code>kernel</code> - convolution kernel (or rather a correlation kernel), a
                single-channel floating point matrix; if you want to apply different kernels
                to different channels, split the image into separate color planes using
                "split" and process them individually.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#filter2d">org.opencv.imgproc.Imgproc.filter2D</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#matchTemplate(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>matchTemplate(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#dft(org.opencv.core.Mat, org.opencv.core.Mat, int, int)"><code>Core.dft(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#sepFilter2D(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, double, int)"><code>sepFilter2D(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Mat,
                    org.opencv.core.Point, double, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="filter2D(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>filter2D</h4>
<pre>public static&nbsp;void&nbsp;filter2D(<a href="../../../org/opencv/core/Mat.html"
                                              title="class in org.opencv.core">Mat</a>&nbsp;src,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
            int&nbsp;ddepth,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
            <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
            double&nbsp;delta)</pre>
        <div class="block"><p>Convolves an image with the kernel.</p>

            <p>The function applies an arbitrary linear filter to an image. In-place
                operation is supported. When the aperture is partially outside the image, the
                function interpolates outlier pixel values according to the specified border
                mode.</p>

            <p>The function does actually compute correlation, not the convolution:</p>

            <p><em>dst(x,y) = sum(by: 0 <= x' &lt kernel.cols, 0 <= y' &lt kernel.rows)
                kernel(x',y')* src(x+x'- anchor.x,y+y'- anchor.y)</em></p>

            <p>That is, the kernel is not mirrored around the anchor point. If you need a
                real convolution, flip the kernel using "flip" and set the new anchor to
                <code>(kernel.cols - anchor.x - 1, kernel.rows - anchor.y - 1)</code>.</p>

            <p>The function uses the DFT-based algorithm in case of sufficiently large
                kernels (~<code>11 x 11</code> or larger) and the direct algorithm (that uses
                the engine retrieved by "createLinearFilter") for small kernels.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image.</dd>
            <dd><code>dst</code> - output image of the same size and the same number of channels as
                <code>src</code>.
            </dd>
            <dd><code>ddepth</code> - desired depth of the destination image; if it is negative, it
                will be the same as <code>src.depth()</code>; the following combinations of
                <code>src.depth()</code> and <code>ddepth</code> are supported:
                <ul>
                    <li><code>src.depth()</code> = <code>CV_8U</code>, <code>ddepth</code> =
                        -1/<code>CV_16S</code>/<code>CV_32F</code>/<code>CV_64F</code>
                    <li><code>src.depth()</code> = <code>CV_16U</code>/<code>CV_16S</code>,
                        <code>ddepth</code> = -1/<code>CV_32F</code>/<code>CV_64F</code>
                    <li><code>src.depth()</code> = <code>CV_32F</code>, <code>ddepth</code> =
                        -1/<code>CV_32F</code>/<code>CV_64F</code>
                    <li><code>src.depth()</code> = <code>CV_64F</code>, <code>ddepth</code> =
                        -1/<code>CV_64F</code>
                </ul>

                <p>when <code>ddepth=-1</code>, the output image will have the same depth as the
                    source.</p></dd>
            <dd><code>kernel</code> - convolution kernel (or rather a correlation kernel), a
                single-channel floating point matrix; if you want to apply different kernels
                to different channels, split the image into separate color planes using
                "split" and process them individually.
            </dd>
            <dd><code>anchor</code> - anchor of the kernel that indicates the relative position of a
                filtered point within the kernel; the anchor should lie within the kernel;
                default value (-1,-1) means that the anchor is at the kernel center.
            </dd>
            <dd><code>delta</code> - optional value added to the filtered pixels before storing them
                in <code>dst</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#filter2d">org.opencv.imgproc.Imgproc.filter2D</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#matchTemplate(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>matchTemplate(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#dft(org.opencv.core.Mat, org.opencv.core.Mat, int, int)"><code>Core.dft(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#sepFilter2D(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, double, int)"><code>sepFilter2D(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Mat,
                    org.opencv.core.Point, double, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="filter2D(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, double, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>filter2D</h4>
<pre>public static&nbsp;void&nbsp;filter2D(<a href="../../../org/opencv/core/Mat.html"
                                              title="class in org.opencv.core">Mat</a>&nbsp;src,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
            int&nbsp;ddepth,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
            <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
            double&nbsp;delta,
            int&nbsp;borderType)</pre>
        <div class="block"><p>Convolves an image with the kernel.</p>

            <p>The function applies an arbitrary linear filter to an image. In-place
                operation is supported. When the aperture is partially outside the image, the
                function interpolates outlier pixel values according to the specified border
                mode.</p>

            <p>The function does actually compute correlation, not the convolution:</p>

            <p><em>dst(x,y) = sum(by: 0 <= x' &lt kernel.cols, 0 <= y' &lt kernel.rows)
                kernel(x',y')* src(x+x'- anchor.x,y+y'- anchor.y)</em></p>

            <p>That is, the kernel is not mirrored around the anchor point. If you need a
                real convolution, flip the kernel using "flip" and set the new anchor to
                <code>(kernel.cols - anchor.x - 1, kernel.rows - anchor.y - 1)</code>.</p>

            <p>The function uses the DFT-based algorithm in case of sufficiently large
                kernels (~<code>11 x 11</code> or larger) and the direct algorithm (that uses
                the engine retrieved by "createLinearFilter") for small kernels.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image.</dd>
            <dd><code>dst</code> - output image of the same size and the same number of channels as
                <code>src</code>.
            </dd>
            <dd><code>ddepth</code> - desired depth of the destination image; if it is negative, it
                will be the same as <code>src.depth()</code>; the following combinations of
                <code>src.depth()</code> and <code>ddepth</code> are supported:
                <ul>
                    <li><code>src.depth()</code> = <code>CV_8U</code>, <code>ddepth</code> =
                        -1/<code>CV_16S</code>/<code>CV_32F</code>/<code>CV_64F</code>
                    <li><code>src.depth()</code> = <code>CV_16U</code>/<code>CV_16S</code>,
                        <code>ddepth</code> = -1/<code>CV_32F</code>/<code>CV_64F</code>
                    <li><code>src.depth()</code> = <code>CV_32F</code>, <code>ddepth</code> =
                        -1/<code>CV_32F</code>/<code>CV_64F</code>
                    <li><code>src.depth()</code> = <code>CV_64F</code>, <code>ddepth</code> =
                        -1/<code>CV_64F</code>
                </ul>

                <p>when <code>ddepth=-1</code>, the output image will have the same depth as the
                    source.</p></dd>
            <dd><code>kernel</code> - convolution kernel (or rather a correlation kernel), a
                single-channel floating point matrix; if you want to apply different kernels
                to different channels, split the image into separate color planes using
                "split" and process them individually.
            </dd>
            <dd><code>anchor</code> - anchor of the kernel that indicates the relative position of a
                filtered point within the kernel; the anchor should lie within the kernel;
                default value (-1,-1) means that the anchor is at the kernel center.
            </dd>
            <dd><code>delta</code> - optional value added to the filtered pixels before storing them
                in <code>dst</code>.
            </dd>
            <dd><code>borderType</code> - pixel extrapolation method (see "borderInterpolate" for
                details).
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#filter2d">org.opencv.imgproc.Imgproc.filter2D</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#matchTemplate(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>matchTemplate(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#dft(org.opencv.core.Mat, org.opencv.core.Mat, int, int)"><code>Core.dft(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#sepFilter2D(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, double, int)"><code>sepFilter2D(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Mat,
                    org.opencv.core.Point, double, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="findContours(org.opencv.core.Mat, java.util.List, org.opencv.core.Mat, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>findContours</h4>
<pre>public static&nbsp;void&nbsp;findContours(<a href="../../../org/opencv/core/Mat.html"
                                                  title="class in org.opencv.core">Mat</a>&nbsp;image,
                java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html"
                                     title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;contours,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;hierarchy,
                int&nbsp;mode,
                int&nbsp;method)</pre>
        <div class="block"><p>Finds contours in a binary image.</p>

            <p>The function retrieves contours from the binary image using the algorithm
                [Suzuki85]. The contours are a useful tool for shape analysis and object
                detection and recognition. See <code>squares.c</code> in the OpenCV sample
                directory.</p>

            <p>Note: Source <code>image</code> is modified by this function. Also, the
                function does not take into account 1-pixel border of the image (it's filled
                with 0's and used for neighbor analysis in the algorithm), therefore the
                contours touching the image border will be clipped.</p>

            <p>Note: If you use the new Python interface then the <code>CV_</code> prefix
                has to be omitted in contour retrieval mode and contour approximation method
                parameters (for example, use <code>cv2.RETR_LIST</code> and <code>cv2.CHAIN_APPROX_NONE</code>
                parameters). If you use the old Python interface then these parameters have
                the <code>CV_</code> prefix (for example, use <code>cv.CV_RETR_LIST</code>
                and <code>cv.CV_CHAIN_APPROX_NONE</code>).</p>

            <p>Note:</p>
            <ul>
                <li> An example using the findContour functionality can be found at
                    opencv_source_code/samples/cpp/contours2.cpp
                <li> An example using findContours to clean up a background segmentation
                    result at opencv_source_code/samples/cpp/segment_objects.cpp
                <li> (Python) An example using the findContour functionality can be found
                    at opencv_source/samples/python2/contours.py
                <li> (Python) An example of detecting squares in an image can be found at
                    opencv_source/samples/python2/squares.py
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>image</code> - Source, an 8-bit single-channel image. Non-zero pixels are
                treated as 1's. Zero pixels remain 0's, so the image is treated as
                <code>binary</code>. You can use "compare", "inRange", "threshold",
                "adaptiveThreshold", "Canny", and others to create a binary image out of a
                grayscale or color one. The function modifies the <code>image</code> while
                extracting the contours. If mode equals to <code>CV_RETR_CCOMP</code> or
                <code>CV_RETR_FLOODFILL</code>, the input can also be a 32-bit integer image
                of labels (<code>CV_32SC1</code>).
            </dd>
            <dd><code>contours</code> - Detected contours. Each contour is stored as a vector of
                points.
            </dd>
            <dd><code>hierarchy</code> - Optional output vector, containing information about the
                image topology. It has as many elements as the number of contours. For each
                i-th contour <code>contours[i]</code>, the elements <code>hierarchy[i][0]</code>,
                <code>hiearchy[i][1]</code>, <code>hiearchy[i][2]</code>, and
                <code>hiearchy[i][3]</code> are set to 0-based indices in <code>contours</code>
                of the next and previous contours at the same hierarchical level, the first
                child contour and the parent contour, respectively. If for the contour
                <code>i</code> there are no next, previous, parent, or nested contours, the
                corresponding elements of <code>hierarchy[i]</code> will be negative.
            </dd>
            <dd><code>mode</code> - Contour retrieval mode (if you use Python see also a note
                below).
                <ul>
                    <li> CV_RETR_EXTERNAL retrieves only the extreme outer contours. It sets
                        <code>hierarchy[i][2]=hierarchy[i][3]=-1</code> for all the contours.
                    <li> CV_RETR_LIST retrieves all of the contours without establishing any
                        hierarchical relationships.
                    <li> CV_RETR_CCOMP retrieves all of the contours and organizes them into a
                        two-level hierarchy. At the top level, there are external boundaries of the
                        components. At the second level, there are boundaries of the holes. If there
                        is another contour inside a hole of a connected component, it is still put
                        at
                        the top level.
                    <li> CV_RETR_TREE retrieves all of the contours and reconstructs a full
                        hierarchy of nested contours. This full hierarchy is built and shown in the
                        OpenCV <code>contours.c</code> demo.
                </ul>
            </dd>
            <dd><code>method</code> - Contour approximation method (if you use Python see also a
                note
                below).
                <ul>
                    <li> CV_CHAIN_APPROX_NONE stores absolutely all the contour points. That
                        is, any 2 subsequent points <code>(x1,y1)</code> and <code>(x2,y2)</code> of
                        the contour will be either horizontal, vertical or diagonal neighbors, that
                        is, <code>max(abs(x1-x2),abs(y2-y1))==1</code>.
                    <li> CV_CHAIN_APPROX_SIMPLE compresses horizontal, vertical, and diagonal
                        segments and leaves only their end points. For example, an up-right
                        rectangular contour is encoded with 4 points.
                    <li> CV_CHAIN_APPROX_TC89_L1,CV_CHAIN_APPROX_TC89_KCOS applies one of the
                        flavors of the Teh-Chin chain approximation algorithm. See [TehChin89] for
                        details.
                </ul>
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#findcontours">org.opencv.imgproc.Imgproc.findContours</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="findContours(org.opencv.core.Mat, java.util.List, org.opencv.core.Mat, int, int, org.opencv.core.Point)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>findContours</h4>
<pre>public static&nbsp;void&nbsp;findContours(<a href="../../../org/opencv/core/Mat.html"
                                                  title="class in org.opencv.core">Mat</a>&nbsp;image,
                java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html"
                                     title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;contours,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;hierarchy,
                int&nbsp;mode,
                int&nbsp;method,
                <a href="../../../org/opencv/core/Point.html"
                   title="class in org.opencv.core">Point</a>&nbsp;offset)</pre>
        <div class="block"><p>Finds contours in a binary image.</p>

            <p>The function retrieves contours from the binary image using the algorithm
                [Suzuki85]. The contours are a useful tool for shape analysis and object
                detection and recognition. See <code>squares.c</code> in the OpenCV sample
                directory.</p>

            <p>Note: Source <code>image</code> is modified by this function. Also, the
                function does not take into account 1-pixel border of the image (it's filled
                with 0's and used for neighbor analysis in the algorithm), therefore the
                contours touching the image border will be clipped.</p>

            <p>Note: If you use the new Python interface then the <code>CV_</code> prefix
                has to be omitted in contour retrieval mode and contour approximation method
                parameters (for example, use <code>cv2.RETR_LIST</code> and <code>cv2.CHAIN_APPROX_NONE</code>
                parameters). If you use the old Python interface then these parameters have
                the <code>CV_</code> prefix (for example, use <code>cv.CV_RETR_LIST</code>
                and <code>cv.CV_CHAIN_APPROX_NONE</code>).</p>

            <p>Note:</p>
            <ul>
                <li> An example using the findContour functionality can be found at
                    opencv_source_code/samples/cpp/contours2.cpp
                <li> An example using findContours to clean up a background segmentation
                    result at opencv_source_code/samples/cpp/segment_objects.cpp
                <li> (Python) An example using the findContour functionality can be found
                    at opencv_source/samples/python2/contours.py
                <li> (Python) An example of detecting squares in an image can be found at
                    opencv_source/samples/python2/squares.py
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>image</code> - Source, an 8-bit single-channel image. Non-zero pixels are
                treated as 1's. Zero pixels remain 0's, so the image is treated as
                <code>binary</code>. You can use "compare", "inRange", "threshold",
                "adaptiveThreshold", "Canny", and others to create a binary image out of a
                grayscale or color one. The function modifies the <code>image</code> while
                extracting the contours. If mode equals to <code>CV_RETR_CCOMP</code> or
                <code>CV_RETR_FLOODFILL</code>, the input can also be a 32-bit integer image
                of labels (<code>CV_32SC1</code>).
            </dd>
            <dd><code>contours</code> - Detected contours. Each contour is stored as a vector of
                points.
            </dd>
            <dd><code>hierarchy</code> - Optional output vector, containing information about the
                image topology. It has as many elements as the number of contours. For each
                i-th contour <code>contours[i]</code>, the elements <code>hierarchy[i][0]</code>,
                <code>hiearchy[i][1]</code>, <code>hiearchy[i][2]</code>, and
                <code>hiearchy[i][3]</code> are set to 0-based indices in <code>contours</code>
                of the next and previous contours at the same hierarchical level, the first
                child contour and the parent contour, respectively. If for the contour
                <code>i</code> there are no next, previous, parent, or nested contours, the
                corresponding elements of <code>hierarchy[i]</code> will be negative.
            </dd>
            <dd><code>mode</code> - Contour retrieval mode (if you use Python see also a note
                below).
                <ul>
                    <li> CV_RETR_EXTERNAL retrieves only the extreme outer contours. It sets
                        <code>hierarchy[i][2]=hierarchy[i][3]=-1</code> for all the contours.
                    <li> CV_RETR_LIST retrieves all of the contours without establishing any
                        hierarchical relationships.
                    <li> CV_RETR_CCOMP retrieves all of the contours and organizes them into a
                        two-level hierarchy. At the top level, there are external boundaries of the
                        components. At the second level, there are boundaries of the holes. If there
                        is another contour inside a hole of a connected component, it is still put
                        at
                        the top level.
                    <li> CV_RETR_TREE retrieves all of the contours and reconstructs a full
                        hierarchy of nested contours. This full hierarchy is built and shown in the
                        OpenCV <code>contours.c</code> demo.
                </ul>
            </dd>
            <dd><code>method</code> - Contour approximation method (if you use Python see also a
                note
                below).
                <ul>
                    <li> CV_CHAIN_APPROX_NONE stores absolutely all the contour points. That
                        is, any 2 subsequent points <code>(x1,y1)</code> and <code>(x2,y2)</code> of
                        the contour will be either horizontal, vertical or diagonal neighbors, that
                        is, <code>max(abs(x1-x2),abs(y2-y1))==1</code>.
                    <li> CV_CHAIN_APPROX_SIMPLE compresses horizontal, vertical, and diagonal
                        segments and leaves only their end points. For example, an up-right
                        rectangular contour is encoded with 4 points.
                    <li> CV_CHAIN_APPROX_TC89_L1,CV_CHAIN_APPROX_TC89_KCOS applies one of the
                        flavors of the Teh-Chin chain approximation algorithm. See [TehChin89] for
                        details.
                </ul>
            </dd>
            <dd><code>offset</code> - Optional offset by which every contour point is shifted. This
                is useful if the contours are extracted from the image ROI and then they
                should be analyzed in the whole image context.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#findcontours">org.opencv.imgproc.Imgproc.findContours</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="fitEllipse(org.opencv.core.MatOfPoint2f)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>fitEllipse</h4>
        <pre>public static&nbsp;<a href="../../../org/opencv/core/RotatedRect.html"
                                   title="class in org.opencv.core">RotatedRect</a>&nbsp;fitEllipse(<a
                href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points)</pre>
        <div class="block"><p>Fits an ellipse around a set of 2D points.</p>

            <p>The function calculates the ellipse that fits (in a least-squares sense) a
                set of 2D points best of all. It returns the rotated rectangle in which the
                ellipse is inscribed. The algorithm [Fitzgibbon95] is used.
                Developer should keep in mind that it is possible that the returned
                ellipse/rotatedRect data contains negative indices, due to the data points
                being close to the border of the containing Mat element.</p>

            <p>Note:</p>
            <ul>
                <li> An example using the fitEllipse technique can be found at
                    opencv_source_code/samples/cpp/fitellipse.cpp
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>points</code> - Input 2D point set, stored in:
                <ul>
                    <li><code>std.vector<></code> or <code>Mat</code> (C++ interface)
                    <li><code>CvSeq*</code> or <code>CvMat*</code> (C interface)
                    <li> Nx2 numpy array (Python interface)
                </ul>
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#fitellipse">org.opencv.imgproc.Imgproc.fitEllipse</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="fitLine(org.opencv.core.Mat, org.opencv.core.Mat, int, double, double, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>fitLine</h4>
<pre>public static&nbsp;void&nbsp;fitLine(<a href="../../../org/opencv/core/Mat.html"
                                             title="class in org.opencv.core">Mat</a>&nbsp;points,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;line,
           int&nbsp;distType,
           double&nbsp;param,
           double&nbsp;reps,
           double&nbsp;aeps)</pre>
        <div class="block"><p>Fits a line to a 2D or 3D point set.</p>

            <p>The function <code>fitLine</code> fits a line to a 2D or 3D point set by
                minimizing <em>sum_i rho(r_i)</em> where <em>r_i</em> is a distance between
                the <em>i^(th)</em> point, the line and <em>rho(r)</em> is a distance
                function, one of the following:</p>
            <ul>
                <li> distType=CV_DIST_L2
            </ul>

            <p><em>rho(r) = r^2/2(the simplest and the fastest least-squares method)</em></p>

            <ul>
                <li> distType=CV_DIST_L1
            </ul>

            <p><em>rho(r) = r</em></p>

            <ul>
                <li> distType=CV_DIST_L12
            </ul>

            <p><em>rho(r) = 2 * (sqrt(1 + frac(r^2)2) - 1)</em></p>

            <ul>
                <li> distType=CV_DIST_FAIR
            </ul>

            <p><em>rho(r) = C^2 * ((r)/(C) - log((1 + (r)/(C)))) where C=1.3998</em></p>

            <ul>
                <li> distType=CV_DIST_WELSCH
            </ul>

            <p><em>rho(r) = (C^2)/2 * (1 - exp((-((r)/(C))^2))) where C=2.9846</em></p>

            <ul>
                <li> distType=CV_DIST_HUBER
            </ul>

            <p><em>rho(r) = r^2/2 if r &lt C; C * (r-C/2) otherwise where C=1.345</em></p>

            <p>The algorithm is based on the M-estimator (http://en.wikipedia.org/wiki/M-estimator)
                technique that iteratively fits the line using the weighted least-squares
                algorithm. After each iteration the weights <em>w_i</em> are adjusted to be
                inversely proportional to <em>rho(r_i)</em>... Sample code:</p>
            <ul>
                <li> (Python) An example of robust line fitting can be found at
                    opencv_source_code/samples/python2/fitline.py
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>points</code> - Input vector of 2D or 3D points, stored in
                <code>std.vector<></code>
                or <code>Mat</code>.
            </dd>
            <dd><code>line</code> - Output line parameters. In case of 2D fitting, it should be a
                vector of 4 elements (like <code>Vec4f</code>) - <code>(vx, vy, x0,
                    y0)</code>, where <code>(vx, vy)</code> is a normalized vector collinear to
                the line and <code>(x0, y0)</code> is a point on the line. In case of 3D
                fitting, it should be a vector of 6 elements (like <code>Vec6f</code>) -
                <code>(vx, vy, vz, x0, y0, z0)</code>, where <code>(vx, vy, vz)</code> is a
                normalized vector collinear to the line and <code>(x0, y0, z0)</code> is a
                point on the line.
            </dd>
            <dd><code>distType</code> - Distance used by the M-estimator (see the discussion below).
            </dd>
            <dd><code>param</code> - Numerical parameter (<code>C</code>) for some types of
                distances. If it is 0, an optimal value is chosen.
            </dd>
            <dd><code>reps</code> - Sufficient accuracy for the radius (distance between the
                coordinate origin and the line).
            </dd>
            <dd><code>aeps</code> - Sufficient accuracy for the angle. 0.01 would be a good default
                value for <code>reps</code> and <code>aeps</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#fitline">org.opencv.imgproc.Imgproc.fitLine</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="floodFill(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, org.opencv.core.Scalar)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>floodFill</h4>
<pre>public static&nbsp;int&nbsp;floodFill(<a href="../../../org/opencv/core/Mat.html"
                                              title="class in org.opencv.core">Mat</a>&nbsp;image,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
            <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;seedPoint,
            <a href="../../../org/opencv/core/Scalar.html"
               title="class in org.opencv.core">Scalar</a>&nbsp;newVal)</pre>
        <div class="block"><p>Fills a connected component with the given color.</p>

            <p>The functions <code>floodFill</code> fill a connected component starting from
                the seed point with the specified color. The connectivity is determined by
                the color/brightness closeness of the neighbor pixels. The pixel at
                <em>(x,y)</em> is considered to belong to the repainted domain if:</p>
            <ul>
                <li><em>src(x',y')- loDiff <= src(x,y) <= src(x',y')+ upDiff</em>
            </ul>

            <p>in case of a grayscale image and floating range</p>
            <ul>
                <li><em>src(seedPoint.x, seedPoint.y)- loDiff <= src(x,y) <=
                    src(seedPoint.x, seedPoint.y)+ upDiff</em>
            </ul>

            <p>in case of a grayscale image and fixed range</p>
            <ul>
                <li><em>src(x',y')_r- loDiff _r <= src(x,y)_r <= src(x',y')_r+ upDiff
                    _r,</em>


            </ul>

            <p><em>src(x',y')_g- loDiff _g <= src(x,y)_g <= src(x',y')_g+ upDiff _g</em></p>

            <p>and</p>

            <p><em>src(x',y')_b- loDiff _b <= src(x,y)_b <= src(x',y')_b+ upDiff _b</em></p>

            <p>in case of a color image and floating range</p>
            <ul>
                <li><em>src(seedPoint.x, seedPoint.y)_r- loDiff _r <= src(x,y)_r <=
                    src(seedPoint.x, seedPoint.y)_r+ upDiff _r,</em>


            </ul>

            <p><em>src(seedPoint.x, seedPoint.y)_g- loDiff _g <= src(x,y)_g <=
                src(seedPoint.x, seedPoint.y)_g+ upDiff _g</em></p>

            <p>and</p>

            <p><em>src(seedPoint.x, seedPoint.y)_b- loDiff _b <= src(x,y)_b <=
                src(seedPoint.x, seedPoint.y)_b+ upDiff _b</em></p>

            <p>in case of a color image and fixed range</p>

            <p>where <em>src(x',y')</em> is the value of one of pixel neighbors that is
                already known to belong to the component. That is, to be added to the
                connected component, a color/brightness of the pixel should be close enough
                to:</p>
            <ul>
                <li> Color/brightness of one of its neighbors that already belong to the
                    connected component in case of a floating range.
                <li> Color/brightness of the seed point in case of a fixed range.
            </ul>

            <p>Use these functions to either mark a connected component with the specified
                color in-place, or build a mask and then extract the contour, or copy the
                region to another image, and so on.</p>

            <p>Note:</p>
            <ul>
                <li> An example using the FloodFill technique can be found at
                    opencv_source_code/samples/cpp/ffilldemo.cpp
                <li> (Python) An example using the FloodFill technique can be found at
                    opencv_source_code/samples/python2/floodfill.cpp
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>image</code> - Input/output 1- or 3-channel, 8-bit, or floating-point image.
                It
                is modified by the function unless the <code>FLOODFILL_MASK_ONLY</code> flag
                is set in the second variant of the function. See the details below.
            </dd>
            <dd><code>mask</code> - Operation mask that should be a single-channel 8-bit image, 2
                pixels wider and 2 pixels taller than <code>image</code>. Since this is both
                an input and output parameter, you must take responsibility of initializing
                it. Flood-filling cannot go across non-zero pixels in the input mask. For
                example, an edge detector output can be used as a mask to stop filling at
                edges. On output, pixels in the mask corresponding to filled pixels in the
                image are set to 1 or to the a value specified in <code>flags</code> as
                described below. It is therefore possible to use the same mask in multiple
                calls to the function to make sure the filled areas do not overlap.

                <p>Note: Since the mask is larger than the filled image, a pixel <em>(x, y)</em>
                    in <code>image</code> corresponds to the pixel <em>(x+1, y+1)</em> in the
                    <code>mask</code>.</p></dd>
            <dd><code>seedPoint</code> - Starting point.</dd>
            <dd><code>newVal</code> - New value of the repainted domain pixels.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#floodfill">org.opencv.imgproc.Imgproc.floodFill</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#findContours(org.opencv.core.Mat, java.util.List, org.opencv.core.Mat, int, int, org.opencv.core.Point)"><code>findContours(org.opencv.core.Mat,
                    java.util.List
                    <org.opencv.core.MatOfPoint>, org.opencv.core.Mat, int, int,
                        org.opencv.core.Point)
                </code></a></dd>
        </dl>
    </li>
</ul>
<a name="floodFill(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, org.opencv.core.Scalar, org.opencv.core.Rect, org.opencv.core.Scalar, org.opencv.core.Scalar, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>floodFill</h4>
<pre>public static&nbsp;int&nbsp;floodFill(<a href="../../../org/opencv/core/Mat.html"
                                              title="class in org.opencv.core">Mat</a>&nbsp;image,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
            <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;seedPoint,
            <a href="../../../org/opencv/core/Scalar.html"
               title="class in org.opencv.core">Scalar</a>&nbsp;newVal,
            <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;rect,
            <a href="../../../org/opencv/core/Scalar.html"
               title="class in org.opencv.core">Scalar</a>&nbsp;loDiff,
            <a href="../../../org/opencv/core/Scalar.html"
               title="class in org.opencv.core">Scalar</a>&nbsp;upDiff,
            int&nbsp;flags)</pre>
        <div class="block"><p>Fills a connected component with the given color.</p>

            <p>The functions <code>floodFill</code> fill a connected component starting from
                the seed point with the specified color. The connectivity is determined by
                the color/brightness closeness of the neighbor pixels. The pixel at
                <em>(x,y)</em> is considered to belong to the repainted domain if:</p>
            <ul>
                <li><em>src(x',y')- loDiff <= src(x,y) <= src(x',y')+ upDiff</em>
            </ul>

            <p>in case of a grayscale image and floating range</p>
            <ul>
                <li><em>src(seedPoint.x, seedPoint.y)- loDiff <= src(x,y) <=
                    src(seedPoint.x, seedPoint.y)+ upDiff</em>
            </ul>

            <p>in case of a grayscale image and fixed range</p>
            <ul>
                <li><em>src(x',y')_r- loDiff _r <= src(x,y)_r <= src(x',y')_r+ upDiff
                    _r,</em>


            </ul>

            <p><em>src(x',y')_g- loDiff _g <= src(x,y)_g <= src(x',y')_g+ upDiff _g</em></p>

            <p>and</p>

            <p><em>src(x',y')_b- loDiff _b <= src(x,y)_b <= src(x',y')_b+ upDiff _b</em></p>

            <p>in case of a color image and floating range</p>
            <ul>
                <li><em>src(seedPoint.x, seedPoint.y)_r- loDiff _r <= src(x,y)_r <=
                    src(seedPoint.x, seedPoint.y)_r+ upDiff _r,</em>


            </ul>

            <p><em>src(seedPoint.x, seedPoint.y)_g- loDiff _g <= src(x,y)_g <=
                src(seedPoint.x, seedPoint.y)_g+ upDiff _g</em></p>

            <p>and</p>

            <p><em>src(seedPoint.x, seedPoint.y)_b- loDiff _b <= src(x,y)_b <=
                src(seedPoint.x, seedPoint.y)_b+ upDiff _b</em></p>

            <p>in case of a color image and fixed range</p>

            <p>where <em>src(x',y')</em> is the value of one of pixel neighbors that is
                already known to belong to the component. That is, to be added to the
                connected component, a color/brightness of the pixel should be close enough
                to:</p>
            <ul>
                <li> Color/brightness of one of its neighbors that already belong to the
                    connected component in case of a floating range.
                <li> Color/brightness of the seed point in case of a fixed range.
            </ul>

            <p>Use these functions to either mark a connected component with the specified
                color in-place, or build a mask and then extract the contour, or copy the
                region to another image, and so on.</p>

            <p>Note:</p>
            <ul>
                <li> An example using the FloodFill technique can be found at
                    opencv_source_code/samples/cpp/ffilldemo.cpp
                <li> (Python) An example using the FloodFill technique can be found at
                    opencv_source_code/samples/python2/floodfill.cpp
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>image</code> - Input/output 1- or 3-channel, 8-bit, or floating-point image.
                It
                is modified by the function unless the <code>FLOODFILL_MASK_ONLY</code> flag
                is set in the second variant of the function. See the details below.
            </dd>
            <dd><code>mask</code> - Operation mask that should be a single-channel 8-bit image, 2
                pixels wider and 2 pixels taller than <code>image</code>. Since this is both
                an input and output parameter, you must take responsibility of initializing
                it. Flood-filling cannot go across non-zero pixels in the input mask. For
                example, an edge detector output can be used as a mask to stop filling at
                edges. On output, pixels in the mask corresponding to filled pixels in the
                image are set to 1 or to the a value specified in <code>flags</code> as
                described below. It is therefore possible to use the same mask in multiple
                calls to the function to make sure the filled areas do not overlap.

                <p>Note: Since the mask is larger than the filled image, a pixel <em>(x, y)</em>
                    in <code>image</code> corresponds to the pixel <em>(x+1, y+1)</em> in the
                    <code>mask</code>.</p></dd>
            <dd><code>seedPoint</code> - Starting point.</dd>
            <dd><code>newVal</code> - New value of the repainted domain pixels.</dd>
            <dd><code>rect</code> - Optional output parameter set by the function to the minimum
                bounding rectangle of the repainted domain.
            </dd>
            <dd><code>loDiff</code> - Maximal lower brightness/color difference between the
                currently
                observed pixel and one of its neighbors belonging to the component, or a seed
                pixel being added to the component.
            </dd>
            <dd><code>upDiff</code> - Maximal upper brightness/color difference between the
                currently
                observed pixel and one of its neighbors belonging to the component, or a seed
                pixel being added to the component.
            </dd>
            <dd><code>flags</code> - Operation flags. The first 8 bits contain a connectivity value.
                The default value of 4 means that only the four nearest neighbor pixels
                (those that share an edge) are considered. A connectivity value of 8 means
                that the eight nearest neighbor pixels (those that share a corner) will be
                considered. The next 8 bits (8-16) contain a value between 1 and 255 with
                which to fill the <code>mask</code> (the default value is 1). For example,
                <code>4 | (255 << 8)</code> will consider 4 nearest neighbours and fill the
                mask with a value of 255. The following additional options occupy higher bits
                and therefore may be further combined with the connectivity and mask fill
                values using bit-wise or (<code>|</code>):
                <ul>
                    <li> FLOODFILL_FIXED_RANGE If set, the difference between the current pixel
                        and seed pixel is considered. Otherwise, the difference between neighbor
                        pixels is considered (that is, the range is floating).
                    <li> FLOODFILL_MASK_ONLY If set, the function does not change the image
                        (<code>newVal</code> is ignored), and only fills the mask with the value
                        specified in bits 8-16 of <code>flags</code> as described above. This option
                        only make sense in function variants that have the <code>mask</code>
                        parameter.
                </ul>
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#floodfill">org.opencv.imgproc.Imgproc.floodFill</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#findContours(org.opencv.core.Mat, java.util.List, org.opencv.core.Mat, int, int, org.opencv.core.Point)"><code>findContours(org.opencv.core.Mat,
                    java.util.List
                    <org.opencv.core.MatOfPoint>, org.opencv.core.Mat, int, int,
                        org.opencv.core.Point)
                </code></a></dd>
        </dl>
    </li>
</ul>
<a name="GaussianBlur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>GaussianBlur</h4>
<pre>public static&nbsp;void&nbsp;GaussianBlur(<a href="../../../org/opencv/core/Mat.html"
                                                  title="class in org.opencv.core">Mat</a>&nbsp;src,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                <a href="../../../org/opencv/core/Size.html"
                   title="class in org.opencv.core">Size</a>&nbsp;ksize,
                double&nbsp;sigmaX)</pre>
        <div class="block"><p>Blurs an image using a Gaussian filter.</p>

            <p>The function convolves the source image with the specified Gaussian kernel.
                In-place filtering is supported.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image; the image can have any number of channels, which are
                processed independently, but the depth should be <code>CV_8U</code>,
                <code>CV_16U</code>, <code>CV_16S</code>, <code>CV_32F</code> or
                <code>CV_64F</code>.
            </dd>
            <dd><code>dst</code> - output image of the same size and type as <code>src</code>.</dd>
            <dd><code>ksize</code> - Gaussian kernel size. <code>ksize.width</code> and
                <code>ksize.height</code> can differ but they both must be positive and odd.
                Or, they can be zero's and then they are computed from <code>sigma*</code>.
            </dd>
            <dd><code>sigmaX</code> - Gaussian kernel standard deviation in X direction.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#gaussianblur">org.opencv.imgproc.Imgproc.GaussianBlur</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#sepFilter2D(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, double, int)"><code>sepFilter2D(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Mat,
                    org.opencv.core.Point, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#medianBlur(org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>medianBlur(org.opencv.core.Mat,
                    org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#boxFilter(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Size, org.opencv.core.Point, boolean, int)"><code>boxFilter(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, org.opencv.core.Size, org.opencv.core.Point, boolean,
                    int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#blur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Point, int)"><code>blur(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Point,
                    int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#filter2D(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, double, int)"><code>filter2D(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, double,
                    int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#bilateralFilter(org.opencv.core.Mat, org.opencv.core.Mat, int, double, double, int)"><code>bilateralFilter(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, double, double, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="GaussianBlur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>GaussianBlur</h4>
<pre>public static&nbsp;void&nbsp;GaussianBlur(<a href="../../../org/opencv/core/Mat.html"
                                                  title="class in org.opencv.core">Mat</a>&nbsp;src,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                <a href="../../../org/opencv/core/Size.html"
                   title="class in org.opencv.core">Size</a>&nbsp;ksize,
                double&nbsp;sigmaX,
                double&nbsp;sigmaY)</pre>
        <div class="block"><p>Blurs an image using a Gaussian filter.</p>

            <p>The function convolves the source image with the specified Gaussian kernel.
                In-place filtering is supported.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image; the image can have any number of channels, which are
                processed independently, but the depth should be <code>CV_8U</code>,
                <code>CV_16U</code>, <code>CV_16S</code>, <code>CV_32F</code> or
                <code>CV_64F</code>.
            </dd>
            <dd><code>dst</code> - output image of the same size and type as <code>src</code>.</dd>
            <dd><code>ksize</code> - Gaussian kernel size. <code>ksize.width</code> and
                <code>ksize.height</code> can differ but they both must be positive and odd.
                Or, they can be zero's and then they are computed from <code>sigma*</code>.
            </dd>
            <dd><code>sigmaX</code> - Gaussian kernel standard deviation in X direction.</dd>
            <dd><code>sigmaY</code> - Gaussian kernel standard deviation in Y direction; if
                <code>sigmaY</code> is zero, it is set to be equal to <code>sigmaX</code>, if
                both sigmas are zeros, they are computed from <code>ksize.width</code> and
                <code>ksize.height</code>, respectively (see "getGaussianKernel" for
                details); to fully control the result regardless of possible future
                modifications of all this semantics, it is recommended to specify all of
                <code>ksize</code>, <code>sigmaX</code>, and <code>sigmaY</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#gaussianblur">org.opencv.imgproc.Imgproc.GaussianBlur</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#sepFilter2D(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, double, int)"><code>sepFilter2D(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Mat,
                    org.opencv.core.Point, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#medianBlur(org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>medianBlur(org.opencv.core.Mat,
                    org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#boxFilter(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Size, org.opencv.core.Point, boolean, int)"><code>boxFilter(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, org.opencv.core.Size, org.opencv.core.Point, boolean,
                    int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#blur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Point, int)"><code>blur(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Point,
                    int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#filter2D(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, double, int)"><code>filter2D(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, double,
                    int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#bilateralFilter(org.opencv.core.Mat, org.opencv.core.Mat, int, double, double, int)"><code>bilateralFilter(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, double, double, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="GaussianBlur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double, double, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>GaussianBlur</h4>
<pre>public static&nbsp;void&nbsp;GaussianBlur(<a href="../../../org/opencv/core/Mat.html"
                                                  title="class in org.opencv.core">Mat</a>&nbsp;src,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                <a href="../../../org/opencv/core/Size.html"
                   title="class in org.opencv.core">Size</a>&nbsp;ksize,
                double&nbsp;sigmaX,
                double&nbsp;sigmaY,
                int&nbsp;borderType)</pre>
        <div class="block"><p>Blurs an image using a Gaussian filter.</p>

            <p>The function convolves the source image with the specified Gaussian kernel.
                In-place filtering is supported.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image; the image can have any number of channels, which are
                processed independently, but the depth should be <code>CV_8U</code>,
                <code>CV_16U</code>, <code>CV_16S</code>, <code>CV_32F</code> or
                <code>CV_64F</code>.
            </dd>
            <dd><code>dst</code> - output image of the same size and type as <code>src</code>.</dd>
            <dd><code>ksize</code> - Gaussian kernel size. <code>ksize.width</code> and
                <code>ksize.height</code> can differ but they both must be positive and odd.
                Or, they can be zero's and then they are computed from <code>sigma*</code>.
            </dd>
            <dd><code>sigmaX</code> - Gaussian kernel standard deviation in X direction.</dd>
            <dd><code>sigmaY</code> - Gaussian kernel standard deviation in Y direction; if
                <code>sigmaY</code> is zero, it is set to be equal to <code>sigmaX</code>, if
                both sigmas are zeros, they are computed from <code>ksize.width</code> and
                <code>ksize.height</code>, respectively (see "getGaussianKernel" for
                details); to fully control the result regardless of possible future
                modifications of all this semantics, it is recommended to specify all of
                <code>ksize</code>, <code>sigmaX</code>, and <code>sigmaY</code>.
            </dd>
            <dd><code>borderType</code> - pixel extrapolation method (see "borderInterpolate" for
                details).
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#gaussianblur">org.opencv.imgproc.Imgproc.GaussianBlur</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#sepFilter2D(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, double, int)"><code>sepFilter2D(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Mat,
                    org.opencv.core.Point, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#medianBlur(org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>medianBlur(org.opencv.core.Mat,
                    org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#boxFilter(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Size, org.opencv.core.Point, boolean, int)"><code>boxFilter(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, org.opencv.core.Size, org.opencv.core.Point, boolean,
                    int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#blur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Point, int)"><code>blur(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Point,
                    int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#filter2D(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, double, int)"><code>filter2D(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, double,
                    int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#bilateralFilter(org.opencv.core.Mat, org.opencv.core.Mat, int, double, double, int)"><code>bilateralFilter(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, double, double, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="getAffineTransform(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>getAffineTransform</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html"
                           title="class in org.opencv.core">Mat</a>&nbsp;getAffineTransform(<a
        href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;src,
                     <a href="../../../org/opencv/core/MatOfPoint2f.html"
                        title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;dst)</pre>
        <div class="block"><p>Calculates an affine transform from three pairs of the corresponding
            points.</p>

            <p>The function calculates the <em>2 x 3</em> matrix of an affine transform so
                that:</p>

            <p><em>x'_i
                y'_i = map_matrix * x_i
                y_i
                1 </em></p>

            <p>where</p>

            <p><em>dst(i)=(x'_i,y'_i),&ltBR&gtsrc(i)=(x_i, y_i),&ltBR&gti=0,1,2</em></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Coordinates of triangle vertices in the source image.</dd>
            <dd><code>dst</code> - Coordinates of the corresponding triangle vertices in the
                destination image.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#getaffinetransform">org.opencv.imgproc.Imgproc.getAffineTransform</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#warpAffine(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int, org.opencv.core.Scalar)"><code>warpAffine(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/core/Core.html#transform(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Core.transform(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="getDefaultNewCameraMatrix(org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>getDefaultNewCameraMatrix</h4>
        <pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html"
                                   title="class in org.opencv.core">Mat</a>&nbsp;getDefaultNewCameraMatrix(<a
                href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix)</pre>
        <div class="block"><p>Returns the default new camera matrix.</p>

            <p>The function returns the camera matrix that is either an exact copy of the
                input <code>cameraMatrix</code> (when <code>centerPrinicipalPoint=false</code>),
                or the modified one (when <code>centerPrincipalPoint=true</code>).</p>

            <p>In the latter case, the new camera matrix will be:</p>

            <p><em>f_x 0(imgSize.width -1)*0.5
                0 f_y(imgSize.height -1)*0.5
                0 0 1,</em></p>

            <p>where <em>f_x</em> and <em>f_y</em> are <em>(0,0)</em> and <em>(1,1)</em>
                elements of <code>cameraMatrix</code>, respectively.</p>

            <p>By default, the undistortion functions in OpenCV (see "initUndistortRectifyMap",
                "undistort") do not move the principal point. However, when you work with
                stereo, it is important to move the principal points in both views to the
                same y-coordinate (which is required by most of stereo correspondence
                algorithms), and may be to the same x-coordinate too. So, you can form the
                new camera matrix for each view where the principal points are located at the
                center.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>cameraMatrix</code> - Input camera matrix.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#getdefaultnewcameramatrix">org.opencv.imgproc.Imgproc.getDefaultNewCameraMatrix</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="getDefaultNewCameraMatrix(org.opencv.core.Mat, org.opencv.core.Size, boolean)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>getDefaultNewCameraMatrix</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html"
                           title="class in org.opencv.core">Mat</a>&nbsp;getDefaultNewCameraMatrix(<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                            <a href="../../../org/opencv/core/Size.html"
                               title="class in org.opencv.core">Size</a>&nbsp;imgsize,
                            boolean&nbsp;centerPrincipalPoint)</pre>
        <div class="block"><p>Returns the default new camera matrix.</p>

            <p>The function returns the camera matrix that is either an exact copy of the
                input <code>cameraMatrix</code> (when <code>centerPrinicipalPoint=false</code>),
                or the modified one (when <code>centerPrincipalPoint=true</code>).</p>

            <p>In the latter case, the new camera matrix will be:</p>

            <p><em>f_x 0(imgSize.width -1)*0.5
                0 f_y(imgSize.height -1)*0.5
                0 0 1,</em></p>

            <p>where <em>f_x</em> and <em>f_y</em> are <em>(0,0)</em> and <em>(1,1)</em>
                elements of <code>cameraMatrix</code>, respectively.</p>

            <p>By default, the undistortion functions in OpenCV (see "initUndistortRectifyMap",
                "undistort") do not move the principal point. However, when you work with
                stereo, it is important to move the principal points in both views to the
                same y-coordinate (which is required by most of stereo correspondence
                algorithms), and may be to the same x-coordinate too. So, you can form the
                new camera matrix for each view where the principal points are located at the
                center.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>cameraMatrix</code> - Input camera matrix.</dd>
            <dd><code>imgsize</code> - Camera view image size in pixels.</dd>
            <dd><code>centerPrincipalPoint</code> - Location of the principal point in the new
                camera
                matrix. The parameter indicates whether this location should be at the image
                center or not.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#getdefaultnewcameramatrix">org.opencv.imgproc.Imgproc.getDefaultNewCameraMatrix</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="getDerivKernels(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>getDerivKernels</h4>
<pre>public static&nbsp;void&nbsp;getDerivKernels(<a href="../../../org/opencv/core/Mat.html"
                                                     title="class in org.opencv.core">Mat</a>&nbsp;kx,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;ky,
                   int&nbsp;dx,
                   int&nbsp;dy,
                   int&nbsp;ksize)</pre>
        <div class="block"><p>Returns filter coefficients for computing spatial image
            derivatives.</p>

            <p>The function computes and returns the filter coefficients for spatial image
                derivatives. When <code>ksize=CV_SCHARR</code>, the Scharr <em>3 x 3</em>
                kernels are generated (see "Scharr"). Otherwise, Sobel kernels are generated
                (see "Sobel"). The filters are normally passed to "sepFilter2D" or to
                "createSeparableLinearFilter".</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>kx</code> - Output matrix of row filter coefficients. It has the type
                <code>ktype</code>.
            </dd>
            <dd><code>ky</code> - Output matrix of column filter coefficients. It has the type
                <code>ktype</code>.
            </dd>
            <dd><code>dx</code> - Derivative order in respect of x.</dd>
            <dd><code>dy</code> - Derivative order in respect of y.</dd>
            <dd><code>ksize</code> - Aperture size. It can be <code>CV_SCHARR</code>, 1, 3, 5, or 7.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#getderivkernels">org.opencv.imgproc.Imgproc.getDerivKernels</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="getDerivKernels(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, boolean, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>getDerivKernels</h4>
<pre>public static&nbsp;void&nbsp;getDerivKernels(<a href="../../../org/opencv/core/Mat.html"
                                                     title="class in org.opencv.core">Mat</a>&nbsp;kx,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;ky,
                   int&nbsp;dx,
                   int&nbsp;dy,
                   int&nbsp;ksize,
                   boolean&nbsp;normalize,
                   int&nbsp;ktype)</pre>
        <div class="block"><p>Returns filter coefficients for computing spatial image
            derivatives.</p>

            <p>The function computes and returns the filter coefficients for spatial image
                derivatives. When <code>ksize=CV_SCHARR</code>, the Scharr <em>3 x 3</em>
                kernels are generated (see "Scharr"). Otherwise, Sobel kernels are generated
                (see "Sobel"). The filters are normally passed to "sepFilter2D" or to
                "createSeparableLinearFilter".</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>kx</code> - Output matrix of row filter coefficients. It has the type
                <code>ktype</code>.
            </dd>
            <dd><code>ky</code> - Output matrix of column filter coefficients. It has the type
                <code>ktype</code>.
            </dd>
            <dd><code>dx</code> - Derivative order in respect of x.</dd>
            <dd><code>dy</code> - Derivative order in respect of y.</dd>
            <dd><code>ksize</code> - Aperture size. It can be <code>CV_SCHARR</code>, 1, 3, 5, or 7.
            </dd>
            <dd><code>normalize</code> - Flag indicating whether to normalize (scale down) the
                filter
                coefficients or not. Theoretically, the coefficients should have the
                denominator <em>=2^(ksize*2-dx-dy-2)</em>. If you are going to filter
                floating-point images, you are likely to use the normalized kernels. But if
                you compute derivatives of an 8-bit image, store the results in a 16-bit
                image, and wish to preserve all the fractional bits, you may want to set
                <code>normalize=false</code>.
            </dd>
            <dd><code>ktype</code> - Type of filter coefficients. It can be <code>CV_32f</code> or
                <code>CV_64F</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#getderivkernels">org.opencv.imgproc.Imgproc.getDerivKernels</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="getGaborKernel(org.opencv.core.Size, double, double, double, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>getGaborKernel</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html"
                           title="class in org.opencv.core">Mat</a>&nbsp;getGaborKernel(<a
        href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
                 double&nbsp;sigma,
                 double&nbsp;theta,
                 double&nbsp;lambd,
                 double&nbsp;gamma)</pre>
    </li>
</ul>
<a name="getGaborKernel(org.opencv.core.Size, double, double, double, double, double, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>getGaborKernel</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html"
                           title="class in org.opencv.core">Mat</a>&nbsp;getGaborKernel(<a
        href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
                 double&nbsp;sigma,
                 double&nbsp;theta,
                 double&nbsp;lambd,
                 double&nbsp;gamma,
                 double&nbsp;psi,
                 int&nbsp;ktype)</pre>
    </li>
</ul>
<a name="getGaussianKernel(int, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>getGaussianKernel</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html"
                           title="class in org.opencv.core">Mat</a>&nbsp;getGaussianKernel(int&nbsp;ksize,
                    double&nbsp;sigma)</pre>
        <div class="block"><p>Returns Gaussian filter coefficients.</p>

            <p>The function computes and returns the <em>ksize x 1</em> matrix of Gaussian
                filter coefficients:</p>

            <p><em>G_i= alpha *e^(-(i-(ksize -1)/2)^2/(2* sigma^2)),</em></p>

            <p>where <em>i=0..ksize-1</em> and <em>alpha</em> is the scale factor chosen so
                that <em>sum_i G_i=1</em>.</p>

            <p>Two of such generated kernels can be passed to "sepFilter2D" or to
                "createSeparableLinearFilter". Those functions automatically recognize
                smoothing kernels (a symmetrical kernel with sum of weights equal to 1) and
                handle them accordingly. You may also use the higher-level "GaussianBlur".</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>ksize</code> - Aperture size. It should be odd (<em>ksize mod 2 = 1</em>) and
                positive.
            </dd>
            <dd><code>sigma</code> - Gaussian standard deviation. If it is non-positive, it is
                computed from <code>ksize</code> as <code>sigma = 0.3*((ksize-1)*0.5 - 1) +
                    0.8</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#getgaussiankernel">org.opencv.imgproc.Imgproc.getGaussianKernel</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#GaussianBlur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double, double, int)"><code>GaussianBlur(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Size, double, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#sepFilter2D(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, double, int)"><code>sepFilter2D(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Mat,
                    org.opencv.core.Point, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#getStructuringElement(int, org.opencv.core.Size, org.opencv.core.Point)"><code>getStructuringElement(int,
                    org.opencv.core.Size, org.opencv.core.Point)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#getDerivKernels(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, boolean, int)"><code>getDerivKernels(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int, int, boolean, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="getGaussianKernel(int, double, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>getGaussianKernel</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html"
                           title="class in org.opencv.core">Mat</a>&nbsp;getGaussianKernel(int&nbsp;ksize,
                    double&nbsp;sigma,
                    int&nbsp;ktype)</pre>
        <div class="block"><p>Returns Gaussian filter coefficients.</p>

            <p>The function computes and returns the <em>ksize x 1</em> matrix of Gaussian
                filter coefficients:</p>

            <p><em>G_i= alpha *e^(-(i-(ksize -1)/2)^2/(2* sigma^2)),</em></p>

            <p>where <em>i=0..ksize-1</em> and <em>alpha</em> is the scale factor chosen so
                that <em>sum_i G_i=1</em>.</p>

            <p>Two of such generated kernels can be passed to "sepFilter2D" or to
                "createSeparableLinearFilter". Those functions automatically recognize
                smoothing kernels (a symmetrical kernel with sum of weights equal to 1) and
                handle them accordingly. You may also use the higher-level "GaussianBlur".</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>ksize</code> - Aperture size. It should be odd (<em>ksize mod 2 = 1</em>) and
                positive.
            </dd>
            <dd><code>sigma</code> - Gaussian standard deviation. If it is non-positive, it is
                computed from <code>ksize</code> as <code>sigma = 0.3*((ksize-1)*0.5 - 1) +
                    0.8</code>.
            </dd>
            <dd><code>ktype</code> - Type of filter coefficients. It can be <code>CV_32f</code> or
                <code>CV_64F</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#getgaussiankernel">org.opencv.imgproc.Imgproc.getGaussianKernel</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#GaussianBlur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double, double, int)"><code>GaussianBlur(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Size, double, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#sepFilter2D(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, double, int)"><code>sepFilter2D(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Mat,
                    org.opencv.core.Point, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#getStructuringElement(int, org.opencv.core.Size, org.opencv.core.Point)"><code>getStructuringElement(int,
                    org.opencv.core.Size, org.opencv.core.Point)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#getDerivKernels(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, boolean, int)"><code>getDerivKernels(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int, int, boolean, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="getPerspectiveTransform(org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>getPerspectiveTransform</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html"
                           title="class in org.opencv.core">Mat</a>&nbsp;getPerspectiveTransform(<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                          <a href="../../../org/opencv/core/Mat.html"
                             title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Calculates a perspective transform from four pairs of the
            corresponding
            points.</p>

            <p>The function calculates the <em>3 x 3</em> matrix of a perspective transform
                so that:</p>

            <p><em>t_i x'_i
                t_i y'_i
                t_i = map_matrix * x_i
                y_i
                1 </em></p>

            <p>where</p>

            <p><em>dst(i)=(x'_i,y'_i),&ltBR&gtsrc(i)=(x_i, y_i),&ltBR&gti=0,1,2,3</em></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Coordinates of quadrangle vertices in the source image.</dd>
            <dd><code>dst</code> - Coordinates of the corresponding quadrangle vertices in the
                destination image.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#getperspectivetransform">org.opencv.imgproc.Imgproc.getPerspectiveTransform</a>,
                <a href="../../../org/opencv/calib3d/Calib3d.html#findHomography(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, int, double, org.opencv.core.Mat)"><code>Calib3d.findHomography(org.opencv.core.MatOfPoint2f,
                    org.opencv.core.MatOfPoint2f, int, double, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/core/Core.html#perspectiveTransform(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Core.perspectiveTransform(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#warpPerspective(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int, org.opencv.core.Scalar)"><code>warpPerspective(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int,
                    org.opencv.core.Scalar)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="getRectSubPix(org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Point, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>getRectSubPix</h4>
<pre>public static&nbsp;void&nbsp;getRectSubPix(<a href="../../../org/opencv/core/Mat.html"
                                                   title="class in org.opencv.core">Mat</a>&nbsp;image,
                 <a href="../../../org/opencv/core/Size.html"
                    title="class in org.opencv.core">Size</a>&nbsp;patchSize,
                 <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;patch)</pre>
        <div class="block"><p>Retrieves a pixel rectangle from an image with sub-pixel accuracy.</p>

            <p>The function <code>getRectSubPix</code> extracts pixels from <code>src</code></p>

            <p><em>dst(x, y) = src(x + center.x - (dst.cols -1)*0.5, y + center.y -
                (dst.rows -1)*0.5)</em></p>

            <p>where the values of the pixels at non-integer coordinates are retrieved using
                bilinear interpolation. Every channel of multi-channel images is processed
                independently. While the center of the rectangle must be inside the image,
                parts of the rectangle may be outside. In this case, the replication border
                mode (see "borderInterpolate") is used to extrapolate the pixel values
                outside of the image.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>image</code> - a image</dd>
            <dd><code>patchSize</code> - Size of the extracted patch.</dd>
            <dd><code>center</code> - Floating point coordinates of the center of the extracted
                rectangle within the source image. The center must be inside the image.
            </dd>
            <dd><code>patch</code> - a patch</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#getrectsubpix">org.opencv.imgproc.Imgproc.getRectSubPix</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#warpAffine(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int, org.opencv.core.Scalar)"><code>warpAffine(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#warpPerspective(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int, org.opencv.core.Scalar)"><code>warpPerspective(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int,
                    org.opencv.core.Scalar)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="getRectSubPix(org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Point, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>getRectSubPix</h4>
<pre>public static&nbsp;void&nbsp;getRectSubPix(<a href="../../../org/opencv/core/Mat.html"
                                                   title="class in org.opencv.core">Mat</a>&nbsp;image,
                 <a href="../../../org/opencv/core/Size.html"
                    title="class in org.opencv.core">Size</a>&nbsp;patchSize,
                 <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;patch,
                 int&nbsp;patchType)</pre>
        <div class="block"><p>Retrieves a pixel rectangle from an image with sub-pixel accuracy.</p>

            <p>The function <code>getRectSubPix</code> extracts pixels from <code>src</code></p>

            <p><em>dst(x, y) = src(x + center.x - (dst.cols -1)*0.5, y + center.y -
                (dst.rows -1)*0.5)</em></p>

            <p>where the values of the pixels at non-integer coordinates are retrieved using
                bilinear interpolation. Every channel of multi-channel images is processed
                independently. While the center of the rectangle must be inside the image,
                parts of the rectangle may be outside. In this case, the replication border
                mode (see "borderInterpolate") is used to extrapolate the pixel values
                outside of the image.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>image</code> - a image</dd>
            <dd><code>patchSize</code> - Size of the extracted patch.</dd>
            <dd><code>center</code> - Floating point coordinates of the center of the extracted
                rectangle within the source image. The center must be inside the image.
            </dd>
            <dd><code>patch</code> - a patch</dd>
            <dd><code>patchType</code> - Depth of the extracted pixels. By default, they have the
                same depth as <code>src</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#getrectsubpix">org.opencv.imgproc.Imgproc.getRectSubPix</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#warpAffine(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int, org.opencv.core.Scalar)"><code>warpAffine(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#warpPerspective(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int, org.opencv.core.Scalar)"><code>warpPerspective(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int,
                    org.opencv.core.Scalar)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="getRotationMatrix2D(org.opencv.core.Point, double, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>getRotationMatrix2D</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html"
                           title="class in org.opencv.core">Mat</a>&nbsp;getRotationMatrix2D(<a
        href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
                      double&nbsp;angle,
                      double&nbsp;scale)</pre>
        <div class="block"><p>Calculates an affine matrix of 2D rotation.</p>

            <p>The function calculates the following matrix:</p>

            <p><em>alpha beta(1- alpha) * center.x - beta * center.y
                - beta alpha beta * center.x + (1- alpha) * center.y </em></p>

            <p>where</p>

            <p><em>alpha = scale * cos angle,
                beta = scale * sin angle </em></p>

            <p>The transformation maps the rotation center to itself. If this is not the
                target, adjust the shift.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>center</code> - Center of the rotation in the source image.</dd>
            <dd><code>angle</code> - Rotation angle in degrees. Positive values mean
                counter-clockwise rotation (the coordinate origin is assumed to be the
                top-left corner).
            </dd>
            <dd><code>scale</code> - Isotropic scale factor.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#getrotationmatrix2d">org.opencv.imgproc.Imgproc.getRotationMatrix2D</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#warpAffine(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int, org.opencv.core.Scalar)"><code>warpAffine(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#getAffineTransform(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f)"><code>getAffineTransform(org.opencv.core.MatOfPoint2f,
                    org.opencv.core.MatOfPoint2f)</code></a>,
                <a href="../../../org/opencv/core/Core.html#transform(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Core.transform(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="getStructuringElement(int, org.opencv.core.Size)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>getStructuringElement</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html"
                           title="class in org.opencv.core">Mat</a>&nbsp;getStructuringElement(int&nbsp;shape,
                        <a href="../../../org/opencv/core/Size.html"
                           title="class in org.opencv.core">Size</a>&nbsp;ksize)</pre>
        <div class="block"><p>Returns a structuring element of the specified size and shape for
            morphological operations.</p>

            <p>The function constructs and returns the structuring element that can be
                further passed to "createMorphologyFilter", "erode", "dilate" or
                "morphologyEx". But you can also construct an arbitrary binary mask yourself
                and use it as the structuring element.</p>

            <p>Note: When using OpenCV 1.x C API, the created structuring element
                <code>IplConvKernel* element</code> must be released in the end using
                <code>cvReleaseStructuringElement(&element)</code>.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>shape</code> - Element shape that could be one of the following:
                <ul>
                    <li> MORPH_RECT - a rectangular structuring element:
                </ul>

                <p><em>E_(ij)=1</em></p>

                <ul>
                    <li> MORPH_ELLIPSE - an elliptic structuring element, that is, a filled
                        ellipse inscribed into the rectangle <code>Rect(0, 0, esize.width,
                            0.esize.height)</code>
                    <li> MORPH_CROSS - a cross-shaped structuring element:
                </ul>

                <p><em>E_(ij) = 1 if i=anchor.y or j=anchor.x; 0 otherwise</em></p>

                <ul>
                    <li> CV_SHAPE_CUSTOM - custom structuring element (OpenCV 1.x API)
                </ul>
            </dd>
            <dd><code>ksize</code> - Size of the structuring element.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#getstructuringelement">org.opencv.imgproc.Imgproc.getStructuringElement</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="getStructuringElement(int, org.opencv.core.Size, org.opencv.core.Point)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>getStructuringElement</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html"
                           title="class in org.opencv.core">Mat</a>&nbsp;getStructuringElement(int&nbsp;shape,
                        <a href="../../../org/opencv/core/Size.html"
                           title="class in org.opencv.core">Size</a>&nbsp;ksize,
                        <a href="../../../org/opencv/core/Point.html"
                           title="class in org.opencv.core">Point</a>&nbsp;anchor)</pre>
        <div class="block"><p>Returns a structuring element of the specified size and shape for
            morphological operations.</p>

            <p>The function constructs and returns the structuring element that can be
                further passed to "createMorphologyFilter", "erode", "dilate" or
                "morphologyEx". But you can also construct an arbitrary binary mask yourself
                and use it as the structuring element.</p>

            <p>Note: When using OpenCV 1.x C API, the created structuring element
                <code>IplConvKernel* element</code> must be released in the end using
                <code>cvReleaseStructuringElement(&element)</code>.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>shape</code> - Element shape that could be one of the following:
                <ul>
                    <li> MORPH_RECT - a rectangular structuring element:
                </ul>

                <p><em>E_(ij)=1</em></p>

                <ul>
                    <li> MORPH_ELLIPSE - an elliptic structuring element, that is, a filled
                        ellipse inscribed into the rectangle <code>Rect(0, 0, esize.width,
                            0.esize.height)</code>
                    <li> MORPH_CROSS - a cross-shaped structuring element:
                </ul>

                <p><em>E_(ij) = 1 if i=anchor.y or j=anchor.x; 0 otherwise</em></p>

                <ul>
                    <li> CV_SHAPE_CUSTOM - custom structuring element (OpenCV 1.x API)
                </ul>
            </dd>
            <dd><code>ksize</code> - Size of the structuring element.</dd>
            <dd><code>anchor</code> - Anchor position within the element. The default value <em>(-1,
                -1)</em> means that the anchor is at the center. Note that only the shape of
                a cross-shaped element depends on the anchor position. In other cases the
                anchor just regulates how much the result of the morphological operation is
                shifted.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#getstructuringelement">org.opencv.imgproc.Imgproc.getStructuringElement</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="goodFeaturesToTrack(org.opencv.core.Mat, org.opencv.core.MatOfPoint, int, double, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>goodFeaturesToTrack</h4>
<pre>public static&nbsp;void&nbsp;goodFeaturesToTrack(<a href="../../../org/opencv/core/Mat.html"
                                                         title="class in org.opencv.core">Mat</a>&nbsp;image,
                       <a href="../../../org/opencv/core/MatOfPoint.html"
                          title="class in org.opencv.core">MatOfPoint</a>&nbsp;corners,
                       int&nbsp;maxCorners,
                       double&nbsp;qualityLevel,
                       double&nbsp;minDistance)</pre>
        <div class="block"><p>Determines strong corners on an image.</p>

            <p>The function finds the most prominent corners in the image or in the
                specified image region, as described in [Shi94]:</p>
            <ul>
                <li> Function calculates the corner quality measure at every source image
                    pixel using the "cornerMinEigenVal" or "cornerHarris".
                <li> Function performs a non-maximum suppression (the local maximums in *3
                    x 3* neighborhood are retained).
                <li> The corners with the minimal eigenvalue less than <em>qualityLevel *
                    max_(x,y) qualityMeasureMap(x,y)</em> are rejected.
                <li> The remaining corners are sorted by the quality measure in the
                    descending order.
                <li> Function throws away each corner for which there is a stronger corner
                    at a distance less than <code>maxDistance</code>.
            </ul>

            <p>The function can be used to initialize a point-based tracker of an object.</p>

            <p>Note: If the function is called with different values <code>A</code> and
                <code>B</code> of the parameter <code>qualityLevel</code>, and <code>A</code>
                > {B}, the vector of returned corners with <code>qualityLevel=A</code> will
                be the prefix of the output vector with <code>qualityLevel=B</code>.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>image</code> - Input 8-bit or floating-point 32-bit, single-channel image.
            </dd>
            <dd><code>corners</code> - Output vector of detected corners.</dd>
            <dd><code>maxCorners</code> - Maximum number of corners to return. If there are more
                corners than are found, the strongest of them is returned.
            </dd>
            <dd><code>qualityLevel</code> - Parameter characterizing the minimal accepted quality of
                image corners. The parameter value is multiplied by the best corner quality
                measure, which is the minimal eigenvalue (see "cornerMinEigenVal") or the
                Harris function response (see "cornerHarris"). The corners with the quality
                measure less than the product are rejected. For example, if the best corner
                has the quality measure = 1500, and the <code>qualityLevel=0.01</code>, then
                all the corners with the quality measure less than 15 are rejected.
            </dd>
            <dd><code>minDistance</code> - Minimum possible Euclidean distance between the returned
                corners.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#goodfeaturestotrack">org.opencv.imgproc.Imgproc.goodFeaturesToTrack</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#cornerHarris(org.opencv.core.Mat, org.opencv.core.Mat, int, int, double, int)"><code>cornerHarris(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int, double, int)</code></a>,
                <a href="../../../org/opencv/video/Video.html#estimateRigidTransform(org.opencv.core.Mat, org.opencv.core.Mat, boolean)"><code>Video.estimateRigidTransform(org.opencv.core.Mat,
                    org.opencv.core.Mat, boolean)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#cornerMinEigenVal(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int)"><code>cornerMinEigenVal(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int, int)</code></a>,
                <a href="../../../org/opencv/video/Video.html#calcOpticalFlowPyrLK(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfByte, org.opencv.core.MatOfFloat, org.opencv.core.Size, int, org.opencv.core.TermCriteria, int, double)"><code>Video.calcOpticalFlowPyrLK(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f,
                    org.opencv.core.MatOfByte, org.opencv.core.MatOfFloat, org.opencv.core.Size,
                    int, org.opencv.core.TermCriteria, int, double)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="goodFeaturesToTrack(org.opencv.core.Mat, org.opencv.core.MatOfPoint, int, double, double, org.opencv.core.Mat, int, boolean, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>goodFeaturesToTrack</h4>
<pre>public static&nbsp;void&nbsp;goodFeaturesToTrack(<a href="../../../org/opencv/core/Mat.html"
                                                         title="class in org.opencv.core">Mat</a>&nbsp;image,
                       <a href="../../../org/opencv/core/MatOfPoint.html"
                          title="class in org.opencv.core">MatOfPoint</a>&nbsp;corners,
                       int&nbsp;maxCorners,
                       double&nbsp;qualityLevel,
                       double&nbsp;minDistance,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                       int&nbsp;blockSize,
                       boolean&nbsp;useHarrisDetector,
                       double&nbsp;k)</pre>
        <div class="block"><p>Determines strong corners on an image.</p>

            <p>The function finds the most prominent corners in the image or in the
                specified image region, as described in [Shi94]:</p>
            <ul>
                <li> Function calculates the corner quality measure at every source image
                    pixel using the "cornerMinEigenVal" or "cornerHarris".
                <li> Function performs a non-maximum suppression (the local maximums in *3
                    x 3* neighborhood are retained).
                <li> The corners with the minimal eigenvalue less than <em>qualityLevel *
                    max_(x,y) qualityMeasureMap(x,y)</em> are rejected.
                <li> The remaining corners are sorted by the quality measure in the
                    descending order.
                <li> Function throws away each corner for which there is a stronger corner
                    at a distance less than <code>maxDistance</code>.
            </ul>

            <p>The function can be used to initialize a point-based tracker of an object.</p>

            <p>Note: If the function is called with different values <code>A</code> and
                <code>B</code> of the parameter <code>qualityLevel</code>, and <code>A</code>
                > {B}, the vector of returned corners with <code>qualityLevel=A</code> will
                be the prefix of the output vector with <code>qualityLevel=B</code>.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>image</code> - Input 8-bit or floating-point 32-bit, single-channel image.
            </dd>
            <dd><code>corners</code> - Output vector of detected corners.</dd>
            <dd><code>maxCorners</code> - Maximum number of corners to return. If there are more
                corners than are found, the strongest of them is returned.
            </dd>
            <dd><code>qualityLevel</code> - Parameter characterizing the minimal accepted quality of
                image corners. The parameter value is multiplied by the best corner quality
                measure, which is the minimal eigenvalue (see "cornerMinEigenVal") or the
                Harris function response (see "cornerHarris"). The corners with the quality
                measure less than the product are rejected. For example, if the best corner
                has the quality measure = 1500, and the <code>qualityLevel=0.01</code>, then
                all the corners with the quality measure less than 15 are rejected.
            </dd>
            <dd><code>minDistance</code> - Minimum possible Euclidean distance between the returned
                corners.
            </dd>
            <dd><code>mask</code> - Optional region of interest. If the image is not empty (it needs
                to have the type <code>CV_8UC1</code> and the same size as <code>image</code>),
                it specifies the region in which the corners are detected.
            </dd>
            <dd><code>blockSize</code> - Size of an average block for computing a derivative
                covariation matrix over each pixel neighborhood. See "cornerEigenValsAndVecs".
            </dd>
            <dd><code>useHarrisDetector</code> - Parameter indicating whether to use a Harris
                detector (see "cornerHarris") or "cornerMinEigenVal".
            </dd>
            <dd><code>k</code> - Free parameter of the Harris detector.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#goodfeaturestotrack">org.opencv.imgproc.Imgproc.goodFeaturesToTrack</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#cornerHarris(org.opencv.core.Mat, org.opencv.core.Mat, int, int, double, int)"><code>cornerHarris(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int, double, int)</code></a>,
                <a href="../../../org/opencv/video/Video.html#estimateRigidTransform(org.opencv.core.Mat, org.opencv.core.Mat, boolean)"><code>Video.estimateRigidTransform(org.opencv.core.Mat,
                    org.opencv.core.Mat, boolean)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#cornerMinEigenVal(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int)"><code>cornerMinEigenVal(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int, int)</code></a>,
                <a href="../../../org/opencv/video/Video.html#calcOpticalFlowPyrLK(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfByte, org.opencv.core.MatOfFloat, org.opencv.core.Size, int, org.opencv.core.TermCriteria, int, double)"><code>Video.calcOpticalFlowPyrLK(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f,
                    org.opencv.core.MatOfByte, org.opencv.core.MatOfFloat, org.opencv.core.Size,
                    int, org.opencv.core.TermCriteria, int, double)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="grabCut(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Rect, org.opencv.core.Mat, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>grabCut</h4>
<pre>public static&nbsp;void&nbsp;grabCut(<a href="../../../org/opencv/core/Mat.html"
                                             title="class in org.opencv.core">Mat</a>&nbsp;img,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
           <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;rect,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;bgdModel,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;fgdModel,
           int&nbsp;iterCount)</pre>
        <div class="block"><p>Runs the GrabCut algorithm.</p>

            <p>The function implements the GrabCut image segmentation algorithm
                (http://en.wikipedia.org/wiki/GrabCut).
                See the sample <code>grabcut.cpp</code> to learn how to use the function.</p>

            <p>Note:</p>
            <ul>
                <li> An example using the GrabCut algorithm can be found at
                    opencv_source_code/samples/cpp/grabcut.cpp
                <li> (Python) An example using the GrabCut algorithm can be found at
                    opencv_source_code/samples/python2/grabcut.py
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>img</code> - Input 8-bit 3-channel image.</dd>
            <dd><code>mask</code> - Input/output 8-bit single-channel mask. The mask is initialized
                by the function when <code>mode</code> is set to <code>GC_INIT_WITH_RECT</code>.
                Its elements may have one of following values:
                <ul>
                    <li> GC_BGD defines an obvious background pixels.
                    <li> GC_FGD defines an obvious foreground (object) pixel.
                    <li> GC_PR_BGD defines a possible background pixel.
                    <li> GC_PR_FGD defines a possible foreground pixel.
                </ul>
            </dd>
            <dd><code>rect</code> - ROI containing a segmented object. The pixels outside of the ROI
                are marked as "obvious background". The parameter is only used when
                <code>mode==GC_INIT_WITH_RECT</code>.
            </dd>
            <dd><code>bgdModel</code> - Temporary array for the background model. Do not modify it
                while you are processing the same image.
            </dd>
            <dd><code>fgdModel</code> - Temporary arrays for the foreground model. Do not modify it
                while you are processing the same image.
            </dd>
            <dd><code>iterCount</code> - Number of iterations the algorithm should make before
                returning the result. Note that the result can be refined with further calls
                with <code>mode==GC_INIT_WITH_MASK</code> or <code>mode==GC_EVAL</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#grabcut">org.opencv.imgproc.Imgproc.grabCut</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="grabCut(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Rect, org.opencv.core.Mat, org.opencv.core.Mat, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>grabCut</h4>
<pre>public static&nbsp;void&nbsp;grabCut(<a href="../../../org/opencv/core/Mat.html"
                                             title="class in org.opencv.core">Mat</a>&nbsp;img,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
           <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;rect,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;bgdModel,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;fgdModel,
           int&nbsp;iterCount,
           int&nbsp;mode)</pre>
        <div class="block"><p>Runs the GrabCut algorithm.</p>

            <p>The function implements the GrabCut image segmentation algorithm
                (http://en.wikipedia.org/wiki/GrabCut).
                See the sample <code>grabcut.cpp</code> to learn how to use the function.</p>

            <p>Note:</p>
            <ul>
                <li> An example using the GrabCut algorithm can be found at
                    opencv_source_code/samples/cpp/grabcut.cpp
                <li> (Python) An example using the GrabCut algorithm can be found at
                    opencv_source_code/samples/python2/grabcut.py
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>img</code> - Input 8-bit 3-channel image.</dd>
            <dd><code>mask</code> - Input/output 8-bit single-channel mask. The mask is initialized
                by the function when <code>mode</code> is set to <code>GC_INIT_WITH_RECT</code>.
                Its elements may have one of following values:
                <ul>
                    <li> GC_BGD defines an obvious background pixels.
                    <li> GC_FGD defines an obvious foreground (object) pixel.
                    <li> GC_PR_BGD defines a possible background pixel.
                    <li> GC_PR_FGD defines a possible foreground pixel.
                </ul>
            </dd>
            <dd><code>rect</code> - ROI containing a segmented object. The pixels outside of the ROI
                are marked as "obvious background". The parameter is only used when
                <code>mode==GC_INIT_WITH_RECT</code>.
            </dd>
            <dd><code>bgdModel</code> - Temporary array for the background model. Do not modify it
                while you are processing the same image.
            </dd>
            <dd><code>fgdModel</code> - Temporary arrays for the foreground model. Do not modify it
                while you are processing the same image.
            </dd>
            <dd><code>iterCount</code> - Number of iterations the algorithm should make before
                returning the result. Note that the result can be refined with further calls
                with <code>mode==GC_INIT_WITH_MASK</code> or <code>mode==GC_EVAL</code>.
            </dd>
            <dd><code>mode</code> - Operation mode that could be one of the following:
                <ul>
                    <li> GC_INIT_WITH_RECT The function initializes the state and the mask
                        using the provided rectangle. After that it runs <code>iterCount</code>
                        iterations of the algorithm.
                    <li> GC_INIT_WITH_MASK The function initializes the state using the
                        provided mask. Note that <code>GC_INIT_WITH_RECT</code> and <code>GC_INIT_WITH_MASK</code>
                        can be combined. Then, all the pixels outside of the ROI are automatically
                        initialized with <code>GC_BGD</code>.
                    <li> GC_EVAL The value means that the algorithm should just resume.
                </ul>
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#grabcut">org.opencv.imgproc.Imgproc.grabCut</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="HoughCircles(org.opencv.core.Mat, org.opencv.core.Mat, int, double, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>HoughCircles</h4>
<pre>public static&nbsp;void&nbsp;HoughCircles(<a href="../../../org/opencv/core/Mat.html"
                                                  title="class in org.opencv.core">Mat</a>&nbsp;image,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;circles,
                int&nbsp;method,
                double&nbsp;dp,
                double&nbsp;minDist)</pre>
        <div class="block"><p>Finds circles in a grayscale image using the Hough transform.</p>

            <p>The function finds circles in a grayscale image using a modification of the
                Hough transform.
                Example: <code></p>

            <p>// C++ code:</p>

            <p>#include
                <cv.h>
            </p>

            <p>#include
                <highgui.h>
            </p>

            <p>#include
                <math.h>
            </p>

            <p>using namespace cv;</p>

            <p>int main(int argc, char argv)</p>


            <p>Mat img, gray;</p>

            <p>if(argc != 2 && !(img=imread(argv[1], 1)).data)</p>

            <p>return -1;</p>

            <p>cvtColor(img, gray, CV_BGR2GRAY);</p>

            <p>// smooth it, otherwise a lot of false circles may be detected</p>

            <p>GaussianBlur(gray, gray, Size(9, 9), 2, 2);</p>

            <p>vector
                <Vec3f> circles;
            </p>

            <p>HoughCircles(gray, circles, CV_HOUGH_GRADIENT,</p>

            <p>2, gray->rows/4, 200, 100);</p>

            <p>for(size_t i = 0; i < circles.size(); i++)</p>


            <p>Point center(cvRound(circles[i][0]), cvRound(circles[i][1]));</p>

            <p>int radius = cvRound(circles[i][2]);</p>

            <p>// draw the circle center</p>

            <p>circle(img, center, 3, Scalar(0,255,0), -1, 8, 0);</p>

            <p>// draw the circle outline</p>

            <p>circle(img, center, radius, Scalar(0,0,255), 3, 8, 0);</p>


            <p>namedWindow("circles", 1);</p>

            <p>imshow("circles", img);</p>

            <p>return 0;</p>


            <p>Note: Usually the function detects the centers of circles well. However, it
                may fail to find correct radii. You can assist to the function by specifying
                the radius range (<code>minRadius</code> and <code>maxRadius</code>) if you
                know it. Or, you may ignore the returned radius, use only the center, and
                find the correct radius using an additional procedure.
                </code></p>

            <p>Note:</p>
            <ul>
                <li> An example using the Hough circle detector can be found at
                    opencv_source_code/samples/cpp/houghcircles.cpp
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>image</code> - 8-bit, single-channel, grayscale input image.</dd>
            <dd><code>circles</code> - Output vector of found circles. Each vector is encoded as a
                3-element floating-point vector <em>(x, y, radius)</em>.
            </dd>
            <dd><code>method</code> - Detection method to use. Currently, the only implemented
                method
                is <code>CV_HOUGH_GRADIENT</code>, which is basically *21HT*, described in
                [Yuen90].
            </dd>
            <dd><code>dp</code> - Inverse ratio of the accumulator resolution to the image
                resolution. For example, if <code>dp=1</code>, the accumulator has the same
                resolution as the input image. If <code>dp=2</code>, the accumulator has half
                as big width and height.
            </dd>
            <dd><code>minDist</code> - Minimum distance between the centers of the detected circles.
                If the parameter is too small, multiple neighbor circles may be falsely
                detected in addition to a true one. If it is too large, some circles may be
                missed.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#houghcircles">org.opencv.imgproc.Imgproc.HoughCircles</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#minEnclosingCircle(org.opencv.core.MatOfPoint2f, org.opencv.core.Point, float[])"><code>minEnclosingCircle(org.opencv.core.MatOfPoint2f,
                    org.opencv.core.Point, float[])</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#fitEllipse(org.opencv.core.MatOfPoint2f)"><code>fitEllipse(org.opencv.core.MatOfPoint2f)</code></a>
            </dd>
        </dl>
    </li>
</ul>
<a name="HoughCircles(org.opencv.core.Mat, org.opencv.core.Mat, int, double, double, double, double, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>HoughCircles</h4>
<pre>public static&nbsp;void&nbsp;HoughCircles(<a href="../../../org/opencv/core/Mat.html"
                                                  title="class in org.opencv.core">Mat</a>&nbsp;image,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;circles,
                int&nbsp;method,
                double&nbsp;dp,
                double&nbsp;minDist,
                double&nbsp;param1,
                double&nbsp;param2,
                int&nbsp;minRadius,
                int&nbsp;maxRadius)</pre>
        <div class="block"><p>Finds circles in a grayscale image using the Hough transform.</p>

            <p>The function finds circles in a grayscale image using a modification of the
                Hough transform.
                Example: <code></p>

            <p>// C++ code:</p>

            <p>#include
                <cv.h>
            </p>

            <p>#include
                <highgui.h>
            </p>

            <p>#include
                <math.h>
            </p>

            <p>using namespace cv;</p>

            <p>int main(int argc, char argv)</p>


            <p>Mat img, gray;</p>

            <p>if(argc != 2 && !(img=imread(argv[1], 1)).data)</p>

            <p>return -1;</p>

            <p>cvtColor(img, gray, CV_BGR2GRAY);</p>

            <p>// smooth it, otherwise a lot of false circles may be detected</p>

            <p>GaussianBlur(gray, gray, Size(9, 9), 2, 2);</p>

            <p>vector
                <Vec3f> circles;
            </p>

            <p>HoughCircles(gray, circles, CV_HOUGH_GRADIENT,</p>

            <p>2, gray->rows/4, 200, 100);</p>

            <p>for(size_t i = 0; i < circles.size(); i++)</p>


            <p>Point center(cvRound(circles[i][0]), cvRound(circles[i][1]));</p>

            <p>int radius = cvRound(circles[i][2]);</p>

            <p>// draw the circle center</p>

            <p>circle(img, center, 3, Scalar(0,255,0), -1, 8, 0);</p>

            <p>// draw the circle outline</p>

            <p>circle(img, center, radius, Scalar(0,0,255), 3, 8, 0);</p>


            <p>namedWindow("circles", 1);</p>

            <p>imshow("circles", img);</p>

            <p>return 0;</p>


            <p>Note: Usually the function detects the centers of circles well. However, it
                may fail to find correct radii. You can assist to the function by specifying
                the radius range (<code>minRadius</code> and <code>maxRadius</code>) if you
                know it. Or, you may ignore the returned radius, use only the center, and
                find the correct radius using an additional procedure.
                </code></p>

            <p>Note:</p>
            <ul>
                <li> An example using the Hough circle detector can be found at
                    opencv_source_code/samples/cpp/houghcircles.cpp
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>image</code> - 8-bit, single-channel, grayscale input image.</dd>
            <dd><code>circles</code> - Output vector of found circles. Each vector is encoded as a
                3-element floating-point vector <em>(x, y, radius)</em>.
            </dd>
            <dd><code>method</code> - Detection method to use. Currently, the only implemented
                method
                is <code>CV_HOUGH_GRADIENT</code>, which is basically *21HT*, described in
                [Yuen90].
            </dd>
            <dd><code>dp</code> - Inverse ratio of the accumulator resolution to the image
                resolution. For example, if <code>dp=1</code>, the accumulator has the same
                resolution as the input image. If <code>dp=2</code>, the accumulator has half
                as big width and height.
            </dd>
            <dd><code>minDist</code> - Minimum distance between the centers of the detected circles.
                If the parameter is too small, multiple neighbor circles may be falsely
                detected in addition to a true one. If it is too large, some circles may be
                missed.
            </dd>
            <dd><code>param1</code> - First method-specific parameter. In case of <code>CV_HOUGH_GRADIENT</code>,
                it is the higher threshold of the two passed to the "Canny" edge detector
                (the lower one is twice smaller).
            </dd>
            <dd><code>param2</code> - Second method-specific parameter. In case of <code>CV_HOUGH_GRADIENT</code>,
                it is the accumulator threshold for the circle centers at the detection
                stage. The smaller it is, the more false circles may be detected. Circles,
                corresponding to the larger accumulator values, will be returned first.
            </dd>
            <dd><code>minRadius</code> - Minimum circle radius.</dd>
            <dd><code>maxRadius</code> - Maximum circle radius.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#houghcircles">org.opencv.imgproc.Imgproc.HoughCircles</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#minEnclosingCircle(org.opencv.core.MatOfPoint2f, org.opencv.core.Point, float[])"><code>minEnclosingCircle(org.opencv.core.MatOfPoint2f,
                    org.opencv.core.Point, float[])</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#fitEllipse(org.opencv.core.MatOfPoint2f)"><code>fitEllipse(org.opencv.core.MatOfPoint2f)</code></a>
            </dd>
        </dl>
    </li>
</ul>
<a name="HoughLines(org.opencv.core.Mat, org.opencv.core.Mat, double, double, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>HoughLines</h4>
<pre>public static&nbsp;void&nbsp;HoughLines(<a href="../../../org/opencv/core/Mat.html"
                                                title="class in org.opencv.core">Mat</a>&nbsp;image,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines,
              double&nbsp;rho,
              double&nbsp;theta,
              int&nbsp;threshold)</pre>
        <div class="block"><p>Finds lines in a binary image using the standard Hough transform.</p>

            <p>The function implements the standard or standard multi-scale Hough transform
                algorithm for line detection. See http://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm
                for a good explanation of Hough transform.
                See also the example in "HoughLinesP" description.</p>

            <p>Note:</p>
            <ul>
                <li> An example using the Hough line detector can be found at
                    opencv_source_code/samples/cpp/houghlines.cpp
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>image</code> - 8-bit, single-channel binary source image. The image may be
                modified by the function.
            </dd>
            <dd><code>lines</code> - Output vector of lines. Each line is represented by a
                two-element vector <em>(rho, theta)</em>. <em>rho</em> is the distance from
                the coordinate origin <em>(0,0)</em> (top-left corner of the image).
                <em>theta</em> is the line rotation angle in radians (<em>0 ~ vertical line,
                    pi/2 ~ horizontal line</em>).
            </dd>
            <dd><code>rho</code> - Distance resolution of the accumulator in pixels.</dd>
            <dd><code>theta</code> - Angle resolution of the accumulator in radians.</dd>
            <dd><code>threshold</code> - Accumulator threshold parameter. Only those lines are
                returned that get enough votes (<em>&gtthreshold</em>).
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#houghlines">org.opencv.imgproc.Imgproc.HoughLines</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="HoughLines(org.opencv.core.Mat, org.opencv.core.Mat, double, double, int, double, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>HoughLines</h4>
<pre>public static&nbsp;void&nbsp;HoughLines(<a href="../../../org/opencv/core/Mat.html"
                                                title="class in org.opencv.core">Mat</a>&nbsp;image,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines,
              double&nbsp;rho,
              double&nbsp;theta,
              int&nbsp;threshold,
              double&nbsp;srn,
              double&nbsp;stn)</pre>
        <div class="block"><p>Finds lines in a binary image using the standard Hough transform.</p>

            <p>The function implements the standard or standard multi-scale Hough transform
                algorithm for line detection. See http://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm
                for a good explanation of Hough transform.
                See also the example in "HoughLinesP" description.</p>

            <p>Note:</p>
            <ul>
                <li> An example using the Hough line detector can be found at
                    opencv_source_code/samples/cpp/houghlines.cpp
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>image</code> - 8-bit, single-channel binary source image. The image may be
                modified by the function.
            </dd>
            <dd><code>lines</code> - Output vector of lines. Each line is represented by a
                two-element vector <em>(rho, theta)</em>. <em>rho</em> is the distance from
                the coordinate origin <em>(0,0)</em> (top-left corner of the image).
                <em>theta</em> is the line rotation angle in radians (<em>0 ~ vertical line,
                    pi/2 ~ horizontal line</em>).
            </dd>
            <dd><code>rho</code> - Distance resolution of the accumulator in pixels.</dd>
            <dd><code>theta</code> - Angle resolution of the accumulator in radians.</dd>
            <dd><code>threshold</code> - Accumulator threshold parameter. Only those lines are
                returned that get enough votes (<em>&gtthreshold</em>).
            </dd>
            <dd><code>srn</code> - For the multi-scale Hough transform, it is a divisor for the
                distance resolution <code>rho</code>. The coarse accumulator distance
                resolution is <code>rho</code> and the accurate accumulator resolution is
                <code>rho/srn</code>. If both <code>srn=0</code> and <code>stn=0</code>, the
                classical Hough transform is used. Otherwise, both these parameters should be
                positive.
            </dd>
            <dd><code>stn</code> - For the multi-scale Hough transform, it is a divisor for the
                distance resolution <code>theta</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#houghlines">org.opencv.imgproc.Imgproc.HoughLines</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="HoughLinesP(org.opencv.core.Mat, org.opencv.core.Mat, double, double, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>HoughLinesP</h4>
<pre>public static&nbsp;void&nbsp;HoughLinesP(<a href="../../../org/opencv/core/Mat.html"
                                                 title="class in org.opencv.core">Mat</a>&nbsp;image,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines,
               double&nbsp;rho,
               double&nbsp;theta,
               int&nbsp;threshold)</pre>
        <div class="block"><p>Finds line segments in a binary image using the probabilistic Hough
            transform.</p>

            <p>The function implements the probabilistic Hough transform algorithm for line
                detection, described in[Matas00]. See the line detection example below:
                <code></p>

            <p>// C++ code:</p>

            <p>/ * This is a standalone program. Pass an image name as the first parameter</p>

            <p>of the program. Switch between standard and probabilistic Hough transform</p>

            <p>by changing "#if 1" to "#if 0" and back * /</p>

            <p>#include
                <cv.h>
            </p>

            <p>#include
                <highgui.h>
            </p>

            <p>#include
                <math.h>
            </p>

            <p>using namespace cv;</p>

            <p>int main(int argc, char argv)</p>


            <p>Mat src, dst, color_dst;</p>

            <p>if(argc != 2 || !(src=imread(argv[1], 0)).data)</p>

            <p>return -1;</p>

            <p>Canny(src, dst, 50, 200, 3);</p>

            <p>cvtColor(dst, color_dst, CV_GRAY2BGR);</p>

            <p>#if 0</p>

            <p>vector
                <Vec2f> lines;
            </p>

            <p>HoughLines(dst, lines, 1, CV_PI/180, 100);</p>

            <p>for(size_t i = 0; i < lines.size(); i++)</p>


            <p>float rho = lines[i][0];</p>

            <p>float theta = lines[i][1];</p>

            <p>double a = cos(theta), b = sin(theta);</p>

            <p>double x0 = a*rho, y0 = b*rho;</p>

            <p>Point pt1(cvRound(x0 + 1000*(-b)),</p>

            <p>cvRound(y0 + 1000*(a)));</p>

            <p>Point pt2(cvRound(x0 - 1000*(-b)),</p>

            <p>cvRound(y0 - 1000*(a)));</p>

            <p>line(color_dst, pt1, pt2, Scalar(0,0,255), 3, 8);</p>


            <p>#else</p>

            <p>vector
                <Vec4i> lines;
            </p>

            <p>HoughLinesP(dst, lines, 1, CV_PI/180, 80, 30, 10);</p>

            <p>for(size_t i = 0; i < lines.size(); i++)</p>


            <p>line(color_dst, Point(lines[i][0], lines[i][1]),</p>

            <p>Point(lines[i][2], lines[i][3]), Scalar(0,0,255), 3, 8);</p>


            <p>#endif</p>

            <p>namedWindow("Source", 1);</p>

            <p>imshow("Source", src);</p>

            <p>namedWindow("Detected Lines", 1);</p>

            <p>imshow("Detected Lines", color_dst);</p>

            <p>waitKey(0);</p>

            <p>return 0;</p>


            <p>This is a sample picture the function parameters have been tuned for: </code></p>

            <p>And this is the output of the above program in case of the probabilistic
                Hough transform:</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>image</code> - 8-bit, single-channel binary source image. The image may be
                modified by the function.
            </dd>
            <dd><code>lines</code> - Output vector of lines. Each line is represented by a 4-element
                vector <em>(x_1, y_1, x_2, y_2)</em>, where <em>(x_1,y_1)</em> and <em>(x_2,
                    y_2)</em> are the ending points of each detected line segment.
            </dd>
            <dd><code>rho</code> - Distance resolution of the accumulator in pixels.</dd>
            <dd><code>theta</code> - Angle resolution of the accumulator in radians.</dd>
            <dd><code>threshold</code> - Accumulator threshold parameter. Only those lines are
                returned that get enough votes (<em>&gtthreshold</em>).
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#houghlinesp">org.opencv.imgproc.Imgproc.HoughLinesP</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="HoughLinesP(org.opencv.core.Mat, org.opencv.core.Mat, double, double, int, double, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>HoughLinesP</h4>
<pre>public static&nbsp;void&nbsp;HoughLinesP(<a href="../../../org/opencv/core/Mat.html"
                                                 title="class in org.opencv.core">Mat</a>&nbsp;image,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines,
               double&nbsp;rho,
               double&nbsp;theta,
               int&nbsp;threshold,
               double&nbsp;minLineLength,
               double&nbsp;maxLineGap)</pre>
        <div class="block"><p>Finds line segments in a binary image using the probabilistic Hough
            transform.</p>

            <p>The function implements the probabilistic Hough transform algorithm for line
                detection, described in[Matas00]. See the line detection example below:
                <code></p>

            <p>// C++ code:</p>

            <p>/ * This is a standalone program. Pass an image name as the first parameter</p>

            <p>of the program. Switch between standard and probabilistic Hough transform</p>

            <p>by changing "#if 1" to "#if 0" and back * /</p>

            <p>#include
                <cv.h>
            </p>

            <p>#include
                <highgui.h>
            </p>

            <p>#include
                <math.h>
            </p>

            <p>using namespace cv;</p>

            <p>int main(int argc, char argv)</p>


            <p>Mat src, dst, color_dst;</p>

            <p>if(argc != 2 || !(src=imread(argv[1], 0)).data)</p>

            <p>return -1;</p>

            <p>Canny(src, dst, 50, 200, 3);</p>

            <p>cvtColor(dst, color_dst, CV_GRAY2BGR);</p>

            <p>#if 0</p>

            <p>vector
                <Vec2f> lines;
            </p>

            <p>HoughLines(dst, lines, 1, CV_PI/180, 100);</p>

            <p>for(size_t i = 0; i < lines.size(); i++)</p>


            <p>float rho = lines[i][0];</p>

            <p>float theta = lines[i][1];</p>

            <p>double a = cos(theta), b = sin(theta);</p>

            <p>double x0 = a*rho, y0 = b*rho;</p>

            <p>Point pt1(cvRound(x0 + 1000*(-b)),</p>

            <p>cvRound(y0 + 1000*(a)));</p>

            <p>Point pt2(cvRound(x0 - 1000*(-b)),</p>

            <p>cvRound(y0 - 1000*(a)));</p>

            <p>line(color_dst, pt1, pt2, Scalar(0,0,255), 3, 8);</p>


            <p>#else</p>

            <p>vector
                <Vec4i> lines;
            </p>

            <p>HoughLinesP(dst, lines, 1, CV_PI/180, 80, 30, 10);</p>

            <p>for(size_t i = 0; i < lines.size(); i++)</p>


            <p>line(color_dst, Point(lines[i][0], lines[i][1]),</p>

            <p>Point(lines[i][2], lines[i][3]), Scalar(0,0,255), 3, 8);</p>


            <p>#endif</p>

            <p>namedWindow("Source", 1);</p>

            <p>imshow("Source", src);</p>

            <p>namedWindow("Detected Lines", 1);</p>

            <p>imshow("Detected Lines", color_dst);</p>

            <p>waitKey(0);</p>

            <p>return 0;</p>


            <p>This is a sample picture the function parameters have been tuned for: </code></p>

            <p>And this is the output of the above program in case of the probabilistic
                Hough transform:</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>image</code> - 8-bit, single-channel binary source image. The image may be
                modified by the function.
            </dd>
            <dd><code>lines</code> - Output vector of lines. Each line is represented by a 4-element
                vector <em>(x_1, y_1, x_2, y_2)</em>, where <em>(x_1,y_1)</em> and <em>(x_2,
                    y_2)</em> are the ending points of each detected line segment.
            </dd>
            <dd><code>rho</code> - Distance resolution of the accumulator in pixels.</dd>
            <dd><code>theta</code> - Angle resolution of the accumulator in radians.</dd>
            <dd><code>threshold</code> - Accumulator threshold parameter. Only those lines are
                returned that get enough votes (<em>&gtthreshold</em>).
            </dd>
            <dd><code>minLineLength</code> - Minimum line length. Line segments shorter than that
                are
                rejected.
            </dd>
            <dd><code>maxLineGap</code> - Maximum allowed gap between points on the same line to
                link
                them.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#houghlinesp">org.opencv.imgproc.Imgproc.HoughLinesP</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="HuMoments(org.opencv.imgproc.Moments, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>HuMoments</h4>
<pre>public static&nbsp;void&nbsp;HuMoments(<a href="../../../org/opencv/imgproc/Moments.html"
                                               title="class in org.opencv.imgproc">Moments</a>&nbsp;m,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;hu)</pre>
        <div class="block"><p>Calculates seven Hu invariants.</p>

            <p>The function calculates seven Hu invariants (introduced in [Hu62]; see also
                http://en.wikipedia.org/wiki/Image_moment) defined as:</p>

            <p><em>hu[0]= eta _20+ eta _02
                hu[1]=(eta _20- eta _02)^2+4 eta _11^2
                hu[2]=(eta _30-3 eta _12)^2+ (3 eta _21- eta _03)^2
                hu[3]=(eta _30+ eta _12)^2+ (eta _21+ eta _03)^2
                hu[4]=(eta _30-3 eta _12)(eta _30+ eta _12)[(eta _30+ eta _12)^2-3(eta _21+
                eta _03)^2]+(3 eta _21- eta _03)(eta _21+ eta _03)[3(eta _30+ eta _12)^2-(eta
                _21+ eta _03)^2]
                hu[5]=(eta _20- eta _02)[(eta _30+ eta _12)^2- (eta _21+ eta _03)^2]+4 eta
                _11(eta _30+ eta _12)(eta _21+ eta _03)
                hu[6]=(3 eta _21- eta _03)(eta _21+ eta _03)[3(eta _30+ eta _12)^2-(eta _21+
                eta _03)^2]-(eta _30-3 eta _12)(eta _21+ eta _03)[3(eta _30+ eta _12)^2-(eta
                _21+ eta _03)^2]
            </em></p>

            <p>where <em>eta_(ji)</em> stands for <em>Moments.nu_(ji)</em>.</p>

            <p>These values are proved to be invariants to the image scale, rotation, and
                reflection except the seventh one, whose sign is changed by reflection. This
                invariance is proved with the assumption of infinite image resolution. In
                case of raster images, the computed Hu invariants for the original and
                transformed images are a bit different.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>m</code> - a m</dd>
            <dd><code>hu</code> - Output Hu invariants.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#humoments">org.opencv.imgproc.Imgproc.HuMoments</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#matchShapes(org.opencv.core.Mat, org.opencv.core.Mat, int, double)"><code>matchShapes(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, double)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="initUndistortRectifyMap(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>initUndistortRectifyMap</h4>
<pre>public static&nbsp;void&nbsp;initUndistortRectifyMap(<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                           <a href="../../../org/opencv/core/Mat.html"
                              title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                           <a href="../../../org/opencv/core/Mat.html"
                              title="class in org.opencv.core">Mat</a>&nbsp;R,
                           <a href="../../../org/opencv/core/Mat.html"
                              title="class in org.opencv.core">Mat</a>&nbsp;newCameraMatrix,
                           <a href="../../../org/opencv/core/Size.html"
                              title="class in org.opencv.core">Size</a>&nbsp;size,
                           int&nbsp;m1type,
                           <a href="../../../org/opencv/core/Mat.html"
                              title="class in org.opencv.core">Mat</a>&nbsp;map1,
                           <a href="../../../org/opencv/core/Mat.html"
                              title="class in org.opencv.core">Mat</a>&nbsp;map2)</pre>
        <div class="block"><p>Computes the undistortion and rectification transformation map.</p>

            <p>The function computes the joint undistortion and rectification transformation
                and represents the result in the form of maps for "remap". The undistorted
                image looks like original, as if it is captured with a camera using the
                camera matrix <code>=newCameraMatrix</code> and zero distortion. In case of a
                monocular camera, <code>newCameraMatrix</code> is usually equal to
                <code>cameraMatrix</code>, or it can be computed by "getOptimalNewCameraMatrix"
                for a better control over scaling. In case of a stereo camera,
                <code>newCameraMatrix</code> is normally set to <code>P1</code> or
                <code>P2</code> computed by "stereoRectify".</p>

            <p>Also, this new camera is oriented differently in the coordinate space,
                according to <code>R</code>. That, for example, helps to align two heads of a
                stereo camera so that the epipolar lines on both images become horizontal and
                have the same y- coordinate (in case of a horizontally aligned stereo
                camera).</p>

            <p>The function actually builds the maps for the inverse mapping algorithm that
                is used by "remap". That is, for each pixel <em>(u, v)</em> in the
                destination (corrected and rectified) image, the function computes the
                corresponding coordinates in the source image (that is, in the original image
                from camera). The following process is applied:</p>

            <p><em>x <- (u - (c')_x)/(f')_x
                y <- (v - (c')_y)/(f')_y
                ([X Y W]) ^T <- R^(-1)*[x y 1]^T
                x' <- X/W
                y' <- Y/W
                x" <- x' (1 + k_1 r^2 + k_2 r^4 + k_3 r^6) + 2p_1 x' y' + p_2(r^2 + 2 x'^2)
                y" <- y' (1 + k_1 r^2 + k_2 r^4 + k_3 r^6) + p_1(r^2 + 2 y'^2) + 2 p_2 x' y'
                map_x(u,v) <- x" f_x + c_x
                map_y(u,v) <- y" f_y + c_y </em></p>

            <p>where <em>(k_1, k_2, p_1, p_2[, k_3])</em> are the distortion coefficients.</p>

            <p>In case of a stereo camera, this function is called twice: once for each
                camera head, after "stereoRectify", which in its turn is called after
                "stereoCalibrate". But if the stereo camera was not calibrated, it is still
                possible to compute the rectification transformations directly from the
                fundamental matrix using "stereoRectifyUncalibrated". For each camera, the
                function computes homography <code>H</code> as the rectification
                transformation in a pixel domain, not a rotation matrix <code>R</code> in 3D
                space. <code>R</code> can be computed from <code>H</code> as</p>

            <p><em>R = cameraMatrix ^(-1) * H * cameraMatrix</em></p>

            <p>where <code>cameraMatrix</code> can be chosen arbitrarily.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>cameraMatrix</code> - Input camera matrix <em>A=
                <p>|f_x 0 c_x|
                    |0 f_y c_y|
                    |0 0 1|
            </em>.</p></dd>
            <dd><code>distCoeffs</code> - Input vector of distortion coefficients <em>(k_1, k_2,
                p_1,
                p_2[, k_3[, k_4, k_5, k_6]])</em> of 4, 5, or 8 elements. If the vector is
                NULL/empty, the zero distortion coefficients are assumed.
            </dd>
            <dd><code>R</code> - Optional rectification transformation in the object space (3x3
                matrix). <code>R1</code> or <code>R2</code>, computed by "stereoRectify" can
                be passed here. If the matrix is empty, the identity transformation is
                assumed. In <code>cvInitUndistortMap</code> R assumed to be an identity
                matrix.
            </dd>
            <dd><code>newCameraMatrix</code> - New camera matrix <em>A'=
                <p>|f_x' 0 c_x'|
                    |0 f_y' c_y'|
                    |0 0 1|
            </em>.</p></dd>
            <dd><code>size</code> - Undistorted image size.</dd>
            <dd><code>m1type</code> - Type of the first output map that can be <code>CV_32FC1</code>
                or <code>CV_16SC2</code>. See "convertMaps" for details.
            </dd>
            <dd><code>map1</code> - The first output map.</dd>
            <dd><code>map2</code> - The second output map.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#initundistortrectifymap">org.opencv.imgproc.Imgproc.initUndistortRectifyMap</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="initWideAngleProjMap(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>initWideAngleProjMap</h4>
<pre>public static&nbsp;float&nbsp;initWideAngleProjMap(<a href="../../../org/opencv/core/Mat.html"
                                                           title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                         <a href="../../../org/opencv/core/Mat.html"
                            title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                         <a href="../../../org/opencv/core/Size.html"
                            title="class in org.opencv.core">Size</a>&nbsp;imageSize,
                         int&nbsp;destImageWidth,
                         int&nbsp;m1type,
                         <a href="../../../org/opencv/core/Mat.html"
                            title="class in org.opencv.core">Mat</a>&nbsp;map1,
                         <a href="../../../org/opencv/core/Mat.html"
                            title="class in org.opencv.core">Mat</a>&nbsp;map2)</pre>
    </li>
</ul>
<a name="initWideAngleProjMap(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int, org.opencv.core.Mat, org.opencv.core.Mat, int, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>initWideAngleProjMap</h4>
<pre>public static&nbsp;float&nbsp;initWideAngleProjMap(<a href="../../../org/opencv/core/Mat.html"
                                                           title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                         <a href="../../../org/opencv/core/Mat.html"
                            title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                         <a href="../../../org/opencv/core/Size.html"
                            title="class in org.opencv.core">Size</a>&nbsp;imageSize,
                         int&nbsp;destImageWidth,
                         int&nbsp;m1type,
                         <a href="../../../org/opencv/core/Mat.html"
                            title="class in org.opencv.core">Mat</a>&nbsp;map1,
                         <a href="../../../org/opencv/core/Mat.html"
                            title="class in org.opencv.core">Mat</a>&nbsp;map2,
                         int&nbsp;projType,
                         double&nbsp;alpha)</pre>
    </li>
</ul>
<a name="integral(org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>integral</h4>
<pre>public static&nbsp;void&nbsp;integral(<a href="../../../org/opencv/core/Mat.html"
                                              title="class in org.opencv.core">Mat</a>&nbsp;src,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sum)</pre>
        <div class="block"><p>Calculates the integral of an image.</p>

            <p>The functions calculate one or more integral images for the source image as
                follows:</p>

            <p><em>sum(X,Y) = sum(by: x&ltX,y&ltY) image(x,y)</em></p>


            <p><em>sqsum(X,Y) = sum(by: x&ltX,y&ltY) image(x,y)^2</em></p>


            <p><em>tilted(X,Y) = sum(by: y&ltY,abs(x-X+1) <= Y-y-1) image(x,y)</em></p>

            <p>Using these integral images, you can calculate sum, mean, and standard
                deviation over a specific up-right or rotated rectangular region of the image
                in a constant time, for example:</p>

            <p><em>sum(by: x_1 <= x &lt x_2, y_1 <= y &lt y_2) image(x,y) = sum(x_2,y_2)-
                sum(x_1,y_2)- sum(x_2,y_1)+ sum(x_1,y_1)</em></p>

            <p>It makes possible to do a fast blurring or fast block correlation with a
                variable window size, for example. In case of multi-channel images, sums for
                each channel are accumulated independently.</p>

            <p>As a practical example, the next figure shows the calculation of the integral
                of a straight rectangle <code>Rect(3,3,3,2)</code> and of a tilted rectangle
                <code>Rect(5,1,2,3)</code>. The selected pixels in the original
                <code>image</code> are shown, as well as the relative pixels in the integral
                images <code>sum</code> and <code>tilted</code>.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - a src</dd>
            <dd><code>sum</code> - integral image as <em>(W+1)x(H+1)</em>, 32-bit integer or
                floating-point (32f or 64f).
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#integral">org.opencv.imgproc.Imgproc.integral</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="integral(org.opencv.core.Mat, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>integral</h4>
<pre>public static&nbsp;void&nbsp;integral(<a href="../../../org/opencv/core/Mat.html"
                                              title="class in org.opencv.core">Mat</a>&nbsp;src,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sum,
            int&nbsp;sdepth)</pre>
        <div class="block"><p>Calculates the integral of an image.</p>

            <p>The functions calculate one or more integral images for the source image as
                follows:</p>

            <p><em>sum(X,Y) = sum(by: x&ltX,y&ltY) image(x,y)</em></p>


            <p><em>sqsum(X,Y) = sum(by: x&ltX,y&ltY) image(x,y)^2</em></p>


            <p><em>tilted(X,Y) = sum(by: y&ltY,abs(x-X+1) <= Y-y-1) image(x,y)</em></p>

            <p>Using these integral images, you can calculate sum, mean, and standard
                deviation over a specific up-right or rotated rectangular region of the image
                in a constant time, for example:</p>

            <p><em>sum(by: x_1 <= x &lt x_2, y_1 <= y &lt y_2) image(x,y) = sum(x_2,y_2)-
                sum(x_1,y_2)- sum(x_2,y_1)+ sum(x_1,y_1)</em></p>

            <p>It makes possible to do a fast blurring or fast block correlation with a
                variable window size, for example. In case of multi-channel images, sums for
                each channel are accumulated independently.</p>

            <p>As a practical example, the next figure shows the calculation of the integral
                of a straight rectangle <code>Rect(3,3,3,2)</code> and of a tilted rectangle
                <code>Rect(5,1,2,3)</code>. The selected pixels in the original
                <code>image</code> are shown, as well as the relative pixels in the integral
                images <code>sum</code> and <code>tilted</code>.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - a src</dd>
            <dd><code>sum</code> - integral image as <em>(W+1)x(H+1)</em>, 32-bit integer or
                floating-point (32f or 64f).
            </dd>
            <dd><code>sdepth</code> - desired depth of the integral and the tilted integral images,
                <code>CV_32S</code>, <code>CV_32F</code>, or <code>CV_64F</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#integral">org.opencv.imgproc.Imgproc.integral</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="integral2(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>integral2</h4>
<pre>public static&nbsp;void&nbsp;integral2(<a href="../../../org/opencv/core/Mat.html"
                                               title="class in org.opencv.core">Mat</a>&nbsp;src,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sum,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sqsum)</pre>
        <div class="block"><p>Calculates the integral of an image.</p>

            <p>The functions calculate one or more integral images for the source image as
                follows:</p>

            <p><em>sum(X,Y) = sum(by: x&ltX,y&ltY) image(x,y)</em></p>


            <p><em>sqsum(X,Y) = sum(by: x&ltX,y&ltY) image(x,y)^2</em></p>


            <p><em>tilted(X,Y) = sum(by: y&ltY,abs(x-X+1) <= Y-y-1) image(x,y)</em></p>

            <p>Using these integral images, you can calculate sum, mean, and standard
                deviation over a specific up-right or rotated rectangular region of the image
                in a constant time, for example:</p>

            <p><em>sum(by: x_1 <= x &lt x_2, y_1 <= y &lt y_2) image(x,y) = sum(x_2,y_2)-
                sum(x_1,y_2)- sum(x_2,y_1)+ sum(x_1,y_1)</em></p>

            <p>It makes possible to do a fast blurring or fast block correlation with a
                variable window size, for example. In case of multi-channel images, sums for
                each channel are accumulated independently.</p>

            <p>As a practical example, the next figure shows the calculation of the integral
                of a straight rectangle <code>Rect(3,3,3,2)</code> and of a tilted rectangle
                <code>Rect(5,1,2,3)</code>. The selected pixels in the original
                <code>image</code> are shown, as well as the relative pixels in the integral
                images <code>sum</code> and <code>tilted</code>.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - a src</dd>
            <dd><code>sum</code> - integral image as <em>(W+1)x(H+1)</em>, 32-bit integer or
                floating-point (32f or 64f).
            </dd>
            <dd><code>sqsum</code> - integral image for squared pixel values; it is
                <em>(W+1)x(H+1)</em>,
                double-precision floating-point (64f) array.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#integral">org.opencv.imgproc.Imgproc.integral</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="integral2(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>integral2</h4>
<pre>public static&nbsp;void&nbsp;integral2(<a href="../../../org/opencv/core/Mat.html"
                                               title="class in org.opencv.core">Mat</a>&nbsp;src,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sum,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sqsum,
             int&nbsp;sdepth)</pre>
        <div class="block"><p>Calculates the integral of an image.</p>

            <p>The functions calculate one or more integral images for the source image as
                follows:</p>

            <p><em>sum(X,Y) = sum(by: x&ltX,y&ltY) image(x,y)</em></p>


            <p><em>sqsum(X,Y) = sum(by: x&ltX,y&ltY) image(x,y)^2</em></p>


            <p><em>tilted(X,Y) = sum(by: y&ltY,abs(x-X+1) <= Y-y-1) image(x,y)</em></p>

            <p>Using these integral images, you can calculate sum, mean, and standard
                deviation over a specific up-right or rotated rectangular region of the image
                in a constant time, for example:</p>

            <p><em>sum(by: x_1 <= x &lt x_2, y_1 <= y &lt y_2) image(x,y) = sum(x_2,y_2)-
                sum(x_1,y_2)- sum(x_2,y_1)+ sum(x_1,y_1)</em></p>

            <p>It makes possible to do a fast blurring or fast block correlation with a
                variable window size, for example. In case of multi-channel images, sums for
                each channel are accumulated independently.</p>

            <p>As a practical example, the next figure shows the calculation of the integral
                of a straight rectangle <code>Rect(3,3,3,2)</code> and of a tilted rectangle
                <code>Rect(5,1,2,3)</code>. The selected pixels in the original
                <code>image</code> are shown, as well as the relative pixels in the integral
                images <code>sum</code> and <code>tilted</code>.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - a src</dd>
            <dd><code>sum</code> - integral image as <em>(W+1)x(H+1)</em>, 32-bit integer or
                floating-point (32f or 64f).
            </dd>
            <dd><code>sqsum</code> - integral image for squared pixel values; it is
                <em>(W+1)x(H+1)</em>,
                double-precision floating-point (64f) array.
            </dd>
            <dd><code>sdepth</code> - desired depth of the integral and the tilted integral images,
                <code>CV_32S</code>, <code>CV_32F</code>, or <code>CV_64F</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#integral">org.opencv.imgproc.Imgproc.integral</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="integral3(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>integral3</h4>
<pre>public static&nbsp;void&nbsp;integral3(<a href="../../../org/opencv/core/Mat.html"
                                               title="class in org.opencv.core">Mat</a>&nbsp;src,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sum,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sqsum,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tilted)</pre>
        <div class="block"><p>Calculates the integral of an image.</p>

            <p>The functions calculate one or more integral images for the source image as
                follows:</p>

            <p><em>sum(X,Y) = sum(by: x&ltX,y&ltY) image(x,y)</em></p>


            <p><em>sqsum(X,Y) = sum(by: x&ltX,y&ltY) image(x,y)^2</em></p>


            <p><em>tilted(X,Y) = sum(by: y&ltY,abs(x-X+1) <= Y-y-1) image(x,y)</em></p>

            <p>Using these integral images, you can calculate sum, mean, and standard
                deviation over a specific up-right or rotated rectangular region of the image
                in a constant time, for example:</p>

            <p><em>sum(by: x_1 <= x &lt x_2, y_1 <= y &lt y_2) image(x,y) = sum(x_2,y_2)-
                sum(x_1,y_2)- sum(x_2,y_1)+ sum(x_1,y_1)</em></p>

            <p>It makes possible to do a fast blurring or fast block correlation with a
                variable window size, for example. In case of multi-channel images, sums for
                each channel are accumulated independently.</p>

            <p>As a practical example, the next figure shows the calculation of the integral
                of a straight rectangle <code>Rect(3,3,3,2)</code> and of a tilted rectangle
                <code>Rect(5,1,2,3)</code>. The selected pixels in the original
                <code>image</code> are shown, as well as the relative pixels in the integral
                images <code>sum</code> and <code>tilted</code>.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - a src</dd>
            <dd><code>sum</code> - integral image as <em>(W+1)x(H+1)</em>, 32-bit integer or
                floating-point (32f or 64f).
            </dd>
            <dd><code>sqsum</code> - integral image for squared pixel values; it is
                <em>(W+1)x(H+1)</em>,
                double-precision floating-point (64f) array.
            </dd>
            <dd><code>tilted</code> - integral for the image rotated by 45 degrees; it is
                <em>(W+1)x(H+1)</em> array with the same data type as <code>sum</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#integral">org.opencv.imgproc.Imgproc.integral</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="integral3(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>integral3</h4>
<pre>public static&nbsp;void&nbsp;integral3(<a href="../../../org/opencv/core/Mat.html"
                                               title="class in org.opencv.core">Mat</a>&nbsp;src,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sum,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sqsum,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tilted,
             int&nbsp;sdepth)</pre>
        <div class="block"><p>Calculates the integral of an image.</p>

            <p>The functions calculate one or more integral images for the source image as
                follows:</p>

            <p><em>sum(X,Y) = sum(by: x&ltX,y&ltY) image(x,y)</em></p>


            <p><em>sqsum(X,Y) = sum(by: x&ltX,y&ltY) image(x,y)^2</em></p>


            <p><em>tilted(X,Y) = sum(by: y&ltY,abs(x-X+1) <= Y-y-1) image(x,y)</em></p>

            <p>Using these integral images, you can calculate sum, mean, and standard
                deviation over a specific up-right or rotated rectangular region of the image
                in a constant time, for example:</p>

            <p><em>sum(by: x_1 <= x &lt x_2, y_1 <= y &lt y_2) image(x,y) = sum(x_2,y_2)-
                sum(x_1,y_2)- sum(x_2,y_1)+ sum(x_1,y_1)</em></p>

            <p>It makes possible to do a fast blurring or fast block correlation with a
                variable window size, for example. In case of multi-channel images, sums for
                each channel are accumulated independently.</p>

            <p>As a practical example, the next figure shows the calculation of the integral
                of a straight rectangle <code>Rect(3,3,3,2)</code> and of a tilted rectangle
                <code>Rect(5,1,2,3)</code>. The selected pixels in the original
                <code>image</code> are shown, as well as the relative pixels in the integral
                images <code>sum</code> and <code>tilted</code>.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - a src</dd>
            <dd><code>sum</code> - integral image as <em>(W+1)x(H+1)</em>, 32-bit integer or
                floating-point (32f or 64f).
            </dd>
            <dd><code>sqsum</code> - integral image for squared pixel values; it is
                <em>(W+1)x(H+1)</em>,
                double-precision floating-point (64f) array.
            </dd>
            <dd><code>tilted</code> - integral for the image rotated by 45 degrees; it is
                <em>(W+1)x(H+1)</em> array with the same data type as <code>sum</code>.
            </dd>
            <dd><code>sdepth</code> - desired depth of the integral and the tilted integral images,
                <code>CV_32S</code>, <code>CV_32F</code>, or <code>CV_64F</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#integral">org.opencv.imgproc.Imgproc.integral</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="intersectConvexConvex(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>intersectConvexConvex</h4>
<pre>public static&nbsp;float&nbsp;intersectConvexConvex(<a href="../../../org/opencv/core/Mat.html"
                                                            title="class in org.opencv.core">Mat</a>&nbsp;_p1,
                          <a href="../../../org/opencv/core/Mat.html"
                             title="class in org.opencv.core">Mat</a>&nbsp;_p2,
                          <a href="../../../org/opencv/core/Mat.html"
                             title="class in org.opencv.core">Mat</a>&nbsp;_p12)</pre>
    </li>
</ul>
<a name="intersectConvexConvex(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>intersectConvexConvex</h4>
<pre>public static&nbsp;float&nbsp;intersectConvexConvex(<a href="../../../org/opencv/core/Mat.html"
                                                            title="class in org.opencv.core">Mat</a>&nbsp;_p1,
                          <a href="../../../org/opencv/core/Mat.html"
                             title="class in org.opencv.core">Mat</a>&nbsp;_p2,
                          <a href="../../../org/opencv/core/Mat.html"
                             title="class in org.opencv.core">Mat</a>&nbsp;_p12,
                          boolean&nbsp;handleNested)</pre>
    </li>
</ul>
<a name="invertAffineTransform(org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>invertAffineTransform</h4>
<pre>public static&nbsp;void&nbsp;invertAffineTransform(<a href="../../../org/opencv/core/Mat.html"
                                                           title="class in org.opencv.core">Mat</a>&nbsp;M,
                         <a href="../../../org/opencv/core/Mat.html"
                            title="class in org.opencv.core">Mat</a>&nbsp;iM)</pre>
        <div class="block"><p>Inverts an affine transformation.</p>

            <p>The function computes an inverse affine transformation represented by <em>2 x
                3</em> matrix <code>M</code> :</p>

            <p><em>a_11 a_12 b_1
                a_21 a_22 b_2 </em></p>

            <p>The result is also a <em>2 x 3</em> matrix of the same type as
                <code>M</code>.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>M</code> - Original affine transformation.</dd>
            <dd><code>iM</code> - Output reverse affine transformation.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#invertaffinetransform">org.opencv.imgproc.Imgproc.invertAffineTransform</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="isContourConvex(org.opencv.core.MatOfPoint)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>isContourConvex</h4>
        <pre>public static&nbsp;boolean&nbsp;isContourConvex(<a
                href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;contour)</pre>
        <div class="block"><p>Tests a contour convexity.</p>

            <p>The function tests whether the input contour is convex or not. The contour
                must be simple, that is, without self-intersections. Otherwise, the function
                output is undefined.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>contour</code> - Input vector of 2D points, stored in:
                <ul>
                    <li><code>std.vector<></code> or <code>Mat</code> (C++ interface)
                    <li><code>CvSeq*</code> or <code>CvMat*</code> (C interface)
                    <li> Nx2 numpy array (Python interface)
                </ul>
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#iscontourconvex">org.opencv.imgproc.Imgproc.isContourConvex</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="Laplacian(org.opencv.core.Mat, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>Laplacian</h4>
<pre>public static&nbsp;void&nbsp;Laplacian(<a href="../../../org/opencv/core/Mat.html"
                                               title="class in org.opencv.core">Mat</a>&nbsp;src,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
             int&nbsp;ddepth)</pre>
        <div class="block"><p>Calculates the Laplacian of an image.</p>

            <p>The function calculates the Laplacian of the source image by adding up the
                second x and y derivatives calculated using the Sobel operator:</p>

            <p><em>dst = Delta src = (d^2 src)/(dx^2) + (d^2 src)/(dy^2)</em></p>

            <p>This is done when <code>ksize > 1</code>. When <code>ksize == 1</code>, the
                Laplacian is computed by filtering the image with the following <em>3 x
                    3</em> aperture:</p>

            <p><em>vecthreethree 0101(-4)1010</em></p>

            <p>Note:</p>
            <ul>
                <li> An example using the Laplace transformation for edge detection can be
                    found at opencv_source_code/samples/cpp/laplace.cpp
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Source image.</dd>
            <dd><code>dst</code> - Destination image of the same size and the same number of
                channels
                as <code>src</code>.
            </dd>
            <dd><code>ddepth</code> - Desired depth of the destination image.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#laplacian">org.opencv.imgproc.Imgproc.Laplacian</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#Scharr(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, double, double, int)"><code>Scharr(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int, int, double, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#Sobel(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, int, double, double, int)"><code>Sobel(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int, int, int, double, double, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="Laplacian(org.opencv.core.Mat, org.opencv.core.Mat, int, int, double, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>Laplacian</h4>
<pre>public static&nbsp;void&nbsp;Laplacian(<a href="../../../org/opencv/core/Mat.html"
                                               title="class in org.opencv.core">Mat</a>&nbsp;src,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
             int&nbsp;ddepth,
             int&nbsp;ksize,
             double&nbsp;scale,
             double&nbsp;delta)</pre>
        <div class="block"><p>Calculates the Laplacian of an image.</p>

            <p>The function calculates the Laplacian of the source image by adding up the
                second x and y derivatives calculated using the Sobel operator:</p>

            <p><em>dst = Delta src = (d^2 src)/(dx^2) + (d^2 src)/(dy^2)</em></p>

            <p>This is done when <code>ksize > 1</code>. When <code>ksize == 1</code>, the
                Laplacian is computed by filtering the image with the following <em>3 x
                    3</em> aperture:</p>

            <p><em>vecthreethree 0101(-4)1010</em></p>

            <p>Note:</p>
            <ul>
                <li> An example using the Laplace transformation for edge detection can be
                    found at opencv_source_code/samples/cpp/laplace.cpp
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Source image.</dd>
            <dd><code>dst</code> - Destination image of the same size and the same number of
                channels
                as <code>src</code>.
            </dd>
            <dd><code>ddepth</code> - Desired depth of the destination image.</dd>
            <dd><code>ksize</code> - Aperture size used to compute the second-derivative filters.
                See
                "getDerivKernels" for details. The size must be positive and odd.
            </dd>
            <dd><code>scale</code> - Optional scale factor for the computed Laplacian values. By
                default, no scaling is applied. See "getDerivKernels" for details.
            </dd>
            <dd><code>delta</code> - Optional delta value that is added to the results prior to
                storing them in <code>dst</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#laplacian">org.opencv.imgproc.Imgproc.Laplacian</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#Scharr(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, double, double, int)"><code>Scharr(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int, int, double, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#Sobel(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, int, double, double, int)"><code>Sobel(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int, int, int, double, double, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="Laplacian(org.opencv.core.Mat, org.opencv.core.Mat, int, int, double, double, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>Laplacian</h4>
<pre>public static&nbsp;void&nbsp;Laplacian(<a href="../../../org/opencv/core/Mat.html"
                                               title="class in org.opencv.core">Mat</a>&nbsp;src,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
             int&nbsp;ddepth,
             int&nbsp;ksize,
             double&nbsp;scale,
             double&nbsp;delta,
             int&nbsp;borderType)</pre>
        <div class="block"><p>Calculates the Laplacian of an image.</p>

            <p>The function calculates the Laplacian of the source image by adding up the
                second x and y derivatives calculated using the Sobel operator:</p>

            <p><em>dst = Delta src = (d^2 src)/(dx^2) + (d^2 src)/(dy^2)</em></p>

            <p>This is done when <code>ksize > 1</code>. When <code>ksize == 1</code>, the
                Laplacian is computed by filtering the image with the following <em>3 x
                    3</em> aperture:</p>

            <p><em>vecthreethree 0101(-4)1010</em></p>

            <p>Note:</p>
            <ul>
                <li> An example using the Laplace transformation for edge detection can be
                    found at opencv_source_code/samples/cpp/laplace.cpp
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Source image.</dd>
            <dd><code>dst</code> - Destination image of the same size and the same number of
                channels
                as <code>src</code>.
            </dd>
            <dd><code>ddepth</code> - Desired depth of the destination image.</dd>
            <dd><code>ksize</code> - Aperture size used to compute the second-derivative filters.
                See
                "getDerivKernels" for details. The size must be positive and odd.
            </dd>
            <dd><code>scale</code> - Optional scale factor for the computed Laplacian values. By
                default, no scaling is applied. See "getDerivKernels" for details.
            </dd>
            <dd><code>delta</code> - Optional delta value that is added to the results prior to
                storing them in <code>dst</code>.
            </dd>
            <dd><code>borderType</code> - Pixel extrapolation method. See "borderInterpolate" for
                details.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#laplacian">org.opencv.imgproc.Imgproc.Laplacian</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#Scharr(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, double, double, int)"><code>Scharr(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int, int, double, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#Sobel(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, int, double, double, int)"><code>Sobel(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int, int, int, double, double, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="matchShapes(org.opencv.core.Mat, org.opencv.core.Mat, int, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>matchShapes</h4>
<pre>public static&nbsp;double&nbsp;matchShapes(<a href="../../../org/opencv/core/Mat.html"
                                                   title="class in org.opencv.core">Mat</a>&nbsp;contour1,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;contour2,
                 int&nbsp;method,
                 double&nbsp;parameter)</pre>
        <div class="block"><p>Compares two shapes.</p>

            <p>The function compares two shapes. All three implemented methods use the Hu
                invariants (see "HuMoments") as follows (<em>A</em> denotes
                <code>object1</code>,<em>B</em>
                denotes <code>object2</code>):</p>
            <ul>
                <li> method=CV_CONTOURS_MATCH_I1
            </ul>

            <p><em>I_1(A,B) = sum(by: i=1...7) <= ft|1/(m^A_i) - 1/(m^B_i) right|</em></p>

            <ul>
                <li> method=CV_CONTOURS_MATCH_I2
            </ul>

            <p><em>I_2(A,B) = sum(by: i=1...7) <= ft|m^A_i - m^B_i right|</em></p>

            <ul>
                <li> method=CV_CONTOURS_MATCH_I3
            </ul>

            <p><em>I_3(A,B) = max _(i=1...7)(<= ft| m^A_i - m^B_i right|)/(<= ft| m^A_i
                right|)</em></p>

            <p>where</p>

            <p><em>m^A_i = sign(h^A_i) * log(h^A_i)
                m^B_i = sign(h^B_i) * log(h^B_i) </em></p>

            <p>and <em>h^A_i, h^B_i</em> are the Hu moments of <em>A</em> and <em>B</em>,
                respectively.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>contour1</code> - a contour1</dd>
            <dd><code>contour2</code> - a contour2</dd>
            <dd><code>method</code> - Comparison method: <code>CV_CONTOURS_MATCH_I1</code>,
                <code>CV_CONTOURS_MATCH_I2</code> \
                <p>or <code>CV_CONTOURS_MATCH_I3</code> (see the details below).</p></dd>
            <dd><code>parameter</code> - Method-specific parameter (not supported now).</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#matchshapes">org.opencv.imgproc.Imgproc.matchShapes</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="matchTemplate(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>matchTemplate</h4>
<pre>public static&nbsp;void&nbsp;matchTemplate(<a href="../../../org/opencv/core/Mat.html"
                                                   title="class in org.opencv.core">Mat</a>&nbsp;image,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;templ,
                 <a href="../../../org/opencv/core/Mat.html"
                    title="class in org.opencv.core">Mat</a>&nbsp;result,
                 int&nbsp;method)</pre>
        <div class="block"><p>Compares a template against overlapped image regions.</p>

            <p>The function slides through <code>image</code>, compares the overlapped
                patches of size <em>w x h</em> against <code>templ</code> using the specified
                method and stores the comparison results in <code>result</code>. Here are the
                formulae for the available comparison methods (<em>I</em> denotes
                <code>image</code>, <em>T</em> <code>template</code>, <em>R</em>
                <code>result</code>). The summation is done over template and/or the image
                patch: <em>x' = 0...w-1, y' = 0...h-1</em></p>
            <ul>
                <li> method=CV_TM_SQDIFF
            </ul>

            <p><em>R(x,y)= sum(by: x',y')(T(x',y')-I(x+x',y+y'))^2</em></p>

            <ul>
                <li> method=CV_TM_SQDIFF_NORMED
            </ul>

            <p><em>R(x,y)= (sum_(x',y')(T(x',y')-I(x+x',y+y'))^2)/(sqrt(sum_(x',y')T(x',y')^2
                * sum_(x',y') I(x+x',y+y')^2))</em></p>

            <ul>
                <li> method=CV_TM_CCORR
            </ul>

            <p><em>R(x,y)= sum(by: x',y')(T(x',y') * I(x+x',y+y'))</em></p>

            <ul>
                <li> method=CV_TM_CCORR_NORMED
            </ul>

            <p><em>R(x,y)= (sum_(x',y')(T(x',y') * I(x+x',y+y')))/(sqrt(sum_(x',y')T(x',y')^2
                * sum_(x',y') I(x+x',y+y')^2))</em></p>

            <ul>
                <li> method=CV_TM_CCOEFF
            </ul>

            <p><em>R(x,y)= sum(by: x',y')(T'(x',y') * I'(x+x',y+y'))</em></p>

            <p>where</p>

            <p><em>T'(x',y')=T(x',y') - 1/(w * h) * sum(by: x'',y'') T(x'',y'')
                I'(x+x',y+y')=I(x+x',y+y') - 1/(w * h) * sum(by: x'',y'') I(x+x'',y+y'')
            </em></p>

            <ul>
                <li> method=CV_TM_CCOEFF_NORMED
            </ul>

            <p><em>R(x,y)= (sum_(x',y')(T'(x',y') * I'(x+x',y+y')))/(sqrt(sum_(x',y')T'(x',y')^2
                * sum_(x',y') I'(x+x',y+y')^2))</em></p>

            <p>After the function finishes the comparison, the best matches can be found as
                global minimums (when <code>CV_TM_SQDIFF</code> was used) or maximums (when
                <code>CV_TM_CCORR</code> or <code>CV_TM_CCOEFF</code> was used) using the
                "minMaxLoc" function. In case of a color image, template summation in the
                numerator and each sum in the denominator is done over all of the channels
                and separate mean values are used for each channel. That is, the function can
                take a color template and a color image. The result will still be a
                single-channel image, which is easier to analyze.</p>

            <p>Note:</p>
            <ul>
                <li> (Python) An example on how to match mouse selected regions in an image
                    can be found at opencv_source_code/samples/python2/mouse_and_match.py
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>image</code> - Image where the search is running. It must be 8-bit or 32-bit
                floating-point.
            </dd>
            <dd><code>templ</code> - Searched template. It must be not greater than the source image
                and have the same data type.
            </dd>
            <dd><code>result</code> - Map of comparison results. It must be single-channel 32-bit
                floating-point. If <code>image</code> is <em>W x H</em> and <code>templ</code>
                is <em>w x h</em>, then <code>result</code> is <em>(W-w+1) x(H-h+1)</em>.
            </dd>
            <dd><code>method</code> - Parameter specifying the comparison method (see below).</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/object_detection.html#matchtemplate">org.opencv.imgproc.Imgproc.matchTemplate</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="medianBlur(org.opencv.core.Mat, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>medianBlur</h4>
<pre>public static&nbsp;void&nbsp;medianBlur(<a href="../../../org/opencv/core/Mat.html"
                                                title="class in org.opencv.core">Mat</a>&nbsp;src,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
              int&nbsp;ksize)</pre>
        <div class="block"><p>Blurs an image using the median filter.</p>

            <p>The function smoothes an image using the median filter with the <em>ksize x
                ksize</em> aperture. Each channel of a multi-channel image is processed
                independently. In-place operation is supported.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input 1-, 3-, or 4-channel image; when <code>ksize</code> is 3 or
                5, the image depth should be <code>CV_8U</code>, <code>CV_16U</code>, or
                <code>CV_32F</code>, for larger aperture sizes, it can only be
                <code>CV_8U</code>.
            </dd>
            <dd><code>dst</code> - destination array of the same size and type as <code>src</code>.
            </dd>
            <dd><code>ksize</code> - aperture linear size; it must be odd and greater than 1, for
                example: 3, 5, 7...
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#medianblur">org.opencv.imgproc.Imgproc.medianBlur</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#boxFilter(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Size, org.opencv.core.Point, boolean, int)"><code>boxFilter(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, org.opencv.core.Size, org.opencv.core.Point, boolean,
                    int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#GaussianBlur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double, double, int)"><code>GaussianBlur(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Size, double, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#bilateralFilter(org.opencv.core.Mat, org.opencv.core.Mat, int, double, double, int)"><code>bilateralFilter(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, double, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#blur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Point, int)"><code>blur(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Point,
                    int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="minAreaRect(org.opencv.core.MatOfPoint2f)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>minAreaRect</h4>
        <pre>public static&nbsp;<a href="../../../org/opencv/core/RotatedRect.html"
                                   title="class in org.opencv.core">RotatedRect</a>&nbsp;minAreaRect(<a
                href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points)</pre>
        <div class="block"><p>Finds a rotated rectangle of the minimum area enclosing the input 2D
            point
            set.</p>

            <p>The function calculates and returns the minimum-area bounding rectangle
                (possibly rotated) for a specified point set. See the OpenCV sample
                <code>minarea.cpp</code>.
                Developer should keep in mind that the returned rotatedRect can contain
                negative indices when data is close the the containing Mat element boundary.</p>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>points</code> - Input vector of 2D points, stored in:
                <ul>
                    <li><code>std.vector<></code> or <code>Mat</code> (C++ interface)
                    <li><code>CvSeq*</code> or <code>CvMat*</code> (C interface)
                    <li> Nx2 numpy array (Python interface)
                </ul>
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#minarearect">org.opencv.imgproc.Imgproc.minAreaRect</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="minEnclosingCircle(org.opencv.core.MatOfPoint2f, org.opencv.core.Point, float[])">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>minEnclosingCircle</h4>
<pre>public static&nbsp;void&nbsp;minEnclosingCircle(<a
        href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points,
                      <a href="../../../org/opencv/core/Point.html"
                         title="class in org.opencv.core">Point</a>&nbsp;center,
                      float[]&nbsp;radius)</pre>
        <div class="block"><p>Finds a circle of the minimum area enclosing a 2D point set.</p>

            <p>The function finds the minimal enclosing circle of a 2D point set using an
                iterative algorithm. See the OpenCV sample <code>minarea.cpp</code>.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>points</code> - Input vector of 2D points, stored in:
                <ul>
                    <li><code>std.vector<></code> or <code>Mat</code> (C++ interface)
                    <li><code>CvSeq*</code> or <code>CvMat*</code> (C interface)
                    <li> Nx2 numpy array (Python interface)
                </ul>
            </dd>
            <dd><code>center</code> - Output center of the circle.</dd>
            <dd><code>radius</code> - Output radius of the circle.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#minenclosingcircle">org.opencv.imgproc.Imgproc.minEnclosingCircle</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="moments(org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>moments</h4>
        <pre>public static&nbsp;<a href="../../../org/opencv/imgproc/Moments.html"
                                   title="class in org.opencv.imgproc">Moments</a>&nbsp;moments(<a
                href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;array)</pre>
        <div class="block"><p>Calculates all of the moments up to the third order of a polygon or
            rasterized shape.</p>

            <p>The function computes moments, up to the 3rd order, of a vector shape or a
                rasterized shape. The results are returned in the structure <code>Moments</code>
                defined as: <code></p>

            <p>// C++ code:</p>

            <p>class Moments</p>


            <p>public:</p>

            <p>Moments();</p>

            <p>Moments(double m00, double m10, double m01, double m20, double m11,</p>

            <p>double m02, double m30, double m21, double m12, double m03);</p>

            <p>Moments(const CvMoments& moments);</p>

            <p>operator CvMoments() const;</p>

            <p>// spatial moments</p>

            <p>double m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;</p>

            <p>// central moments</p>

            <p>double mu20, mu11, mu02, mu30, mu21, mu12, mu03;</p>

            <p>// central normalized moments</p>

            <p>double nu20, nu11, nu02, nu30, nu21, nu12, nu03;</p>


            <p>In case of a raster image, the spatial moments <em>Moments.m_(ji)</em> are
                computed as: </code></p>

            <p><em>m _(ji)= sum(by: x,y)(array(x,y) * x^j * y^i)</em></p>

            <p>The central moments <em>Moments.mu_(ji)</em> are computed as:</p>

            <p><em>mu _(ji)= sum(by: x,y)(array(x,y) * (x - x")^j * (y - y")^i)</em></p>

            <p>where <em>(x", y")</em> is the mass center:</p>

            <p><em>x" = (m_10)/(m_(00)), y" = (m_01)/(m_(00))</em></p>

            <p>The normalized central moments <em>Moments.nu_(ij)</em> are computed as:</p>

            <p><em>nu _(ji)= (mu_(ji))/(m_(00)^((i+j)/2+1)).</em></p>

            <p>Note:</p>

            <p><em>mu_00=m_00</em>, <em>nu_00=1</em> <em>nu_10=mu_10=mu_01=mu_10=0</em>,
                hence the values are not stored.</p>

            <p>The moments of a contour are defined in the same way but computed using the
                Green's formula (see http://en.wikipedia.org/wiki/Green_theorem). So, due to
                a limited raster resolution, the moments computed for a contour are slightly
                different from the moments computed for the same rasterized contour.</p>

            <p>Note:</p>

            <p>Since the contour moments are computed using Green formula, you may get
                seemingly odd results for contours with self-intersections, e.g. a zero area
                (<code>m00</code>) for butterfly-shaped contours.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>array</code> - Raster image (single-channel, 8-bit or floating-point 2D array)
                or an array (<em>1 x N</em> or <em>N x 1</em>) of 2D points (<code>Point</code>
                or <code>Point2f</code>).
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#moments">org.opencv.imgproc.Imgproc.moments</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#contourArea(org.opencv.core.Mat, boolean)"><code>contourArea(org.opencv.core.Mat,
                    boolean)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#arcLength(org.opencv.core.MatOfPoint2f, boolean)"><code>arcLength(org.opencv.core.MatOfPoint2f,
                    boolean)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="moments(org.opencv.core.Mat, boolean)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>moments</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/imgproc/Moments.html"
                           title="class in org.opencv.imgproc">Moments</a>&nbsp;moments(<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;array,
              boolean&nbsp;binaryImage)</pre>
        <div class="block"><p>Calculates all of the moments up to the third order of a polygon or
            rasterized shape.</p>

            <p>The function computes moments, up to the 3rd order, of a vector shape or a
                rasterized shape. The results are returned in the structure <code>Moments</code>
                defined as: <code></p>

            <p>// C++ code:</p>

            <p>class Moments</p>


            <p>public:</p>

            <p>Moments();</p>

            <p>Moments(double m00, double m10, double m01, double m20, double m11,</p>

            <p>double m02, double m30, double m21, double m12, double m03);</p>

            <p>Moments(const CvMoments& moments);</p>

            <p>operator CvMoments() const;</p>

            <p>// spatial moments</p>

            <p>double m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;</p>

            <p>// central moments</p>

            <p>double mu20, mu11, mu02, mu30, mu21, mu12, mu03;</p>

            <p>// central normalized moments</p>

            <p>double nu20, nu11, nu02, nu30, nu21, nu12, nu03;</p>


            <p>In case of a raster image, the spatial moments <em>Moments.m_(ji)</em> are
                computed as: </code></p>

            <p><em>m _(ji)= sum(by: x,y)(array(x,y) * x^j * y^i)</em></p>

            <p>The central moments <em>Moments.mu_(ji)</em> are computed as:</p>

            <p><em>mu _(ji)= sum(by: x,y)(array(x,y) * (x - x")^j * (y - y")^i)</em></p>

            <p>where <em>(x", y")</em> is the mass center:</p>

            <p><em>x" = (m_10)/(m_(00)), y" = (m_01)/(m_(00))</em></p>

            <p>The normalized central moments <em>Moments.nu_(ij)</em> are computed as:</p>

            <p><em>nu _(ji)= (mu_(ji))/(m_(00)^((i+j)/2+1)).</em></p>

            <p>Note:</p>

            <p><em>mu_00=m_00</em>, <em>nu_00=1</em> <em>nu_10=mu_10=mu_01=mu_10=0</em>,
                hence the values are not stored.</p>

            <p>The moments of a contour are defined in the same way but computed using the
                Green's formula (see http://en.wikipedia.org/wiki/Green_theorem). So, due to
                a limited raster resolution, the moments computed for a contour are slightly
                different from the moments computed for the same rasterized contour.</p>

            <p>Note:</p>

            <p>Since the contour moments are computed using Green formula, you may get
                seemingly odd results for contours with self-intersections, e.g. a zero area
                (<code>m00</code>) for butterfly-shaped contours.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>array</code> - Raster image (single-channel, 8-bit or floating-point 2D array)
                or an array (<em>1 x N</em> or <em>N x 1</em>) of 2D points (<code>Point</code>
                or <code>Point2f</code>).
            </dd>
            <dd><code>binaryImage</code> - If it is true, all non-zero image pixels are treated as
                1's. The parameter is used for images only.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#moments">org.opencv.imgproc.Imgproc.moments</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#contourArea(org.opencv.core.Mat, boolean)"><code>contourArea(org.opencv.core.Mat,
                    boolean)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#arcLength(org.opencv.core.MatOfPoint2f, boolean)"><code>arcLength(org.opencv.core.MatOfPoint2f,
                    boolean)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="morphologyEx(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>morphologyEx</h4>
<pre>public static&nbsp;void&nbsp;morphologyEx(<a href="../../../org/opencv/core/Mat.html"
                                                  title="class in org.opencv.core">Mat</a>&nbsp;src,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                int&nbsp;op,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel)</pre>
        <div class="block"><p>Performs advanced morphological transformations.</p>

            <p>The function can perform advanced morphological transformations using an
                erosion and dilation as basic operations.</p>

            <p>Opening operation:</p>

            <p><em>dst = open(src, element)= dilate(erode(src, element))</em></p>

            <p>Closing operation:</p>

            <p><em>dst = close(src, element)= erode(dilate(src, element))</em></p>

            <p>Morphological gradient:</p>

            <p><em>dst = morph_grad(src, element)= dilate(src, element)- erode(src,
                element)</em></p>

            <p>"Top hat":</p>

            <p><em>dst = tophat(src, element)= src - open(src, element)</em></p>

            <p>"Black hat":</p>

            <p><em>dst = blackhat(src, element)= close(src, element)- src</em></p>

            <p>Any of the operations can be done in-place. In case of multi-channel images,
                each channel is processed independently.</p>

            <p>Note:</p>
            <ul>
                <li> An example using the morphologyEx function for the morphological
                    opening and closing operations can be found at
                    opencv_source_code/samples/cpp/morphology2.cpp
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Source image. The number of channels can be arbitrary. The depth
                should be one of <code>CV_8U</code>, <code>CV_16U</code>, <code>CV_16S</code>,
                <code>CV_32F</code> or <code>CV_64F</code>.
            </dd>
            <dd><code>dst</code> - Destination image of the same size and type as <code>src</code>.
            </dd>
            <dd><code>op</code> - Type of a morphological operation that can be one of the
                following:
                <ul>
                    <li> MORPH_OPEN - an opening operation
                    <li> MORPH_CLOSE - a closing operation
                    <li> MORPH_GRADIENT - a morphological gradient
                    <li> MORPH_TOPHAT - "top hat"
                    <li> MORPH_BLACKHAT - "black hat"
                </ul>
            </dd>
            <dd><code>kernel</code> - a kernel</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#morphologyex">org.opencv.imgproc.Imgproc.morphologyEx</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#erode(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, int, int, org.opencv.core.Scalar)"><code>erode(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#dilate(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, int, int, org.opencv.core.Scalar)"><code>dilate(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, int, int,
                    org.opencv.core.Scalar)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="morphologyEx(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>morphologyEx</h4>
<pre>public static&nbsp;void&nbsp;morphologyEx(<a href="../../../org/opencv/core/Mat.html"
                                                  title="class in org.opencv.core">Mat</a>&nbsp;src,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                int&nbsp;op,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
                <a href="../../../org/opencv/core/Point.html"
                   title="class in org.opencv.core">Point</a>&nbsp;anchor,
                int&nbsp;iterations)</pre>
        <div class="block"><p>Performs advanced morphological transformations.</p>

            <p>The function can perform advanced morphological transformations using an
                erosion and dilation as basic operations.</p>

            <p>Opening operation:</p>

            <p><em>dst = open(src, element)= dilate(erode(src, element))</em></p>

            <p>Closing operation:</p>

            <p><em>dst = close(src, element)= erode(dilate(src, element))</em></p>

            <p>Morphological gradient:</p>

            <p><em>dst = morph_grad(src, element)= dilate(src, element)- erode(src,
                element)</em></p>

            <p>"Top hat":</p>

            <p><em>dst = tophat(src, element)= src - open(src, element)</em></p>

            <p>"Black hat":</p>

            <p><em>dst = blackhat(src, element)= close(src, element)- src</em></p>

            <p>Any of the operations can be done in-place. In case of multi-channel images,
                each channel is processed independently.</p>

            <p>Note:</p>
            <ul>
                <li> An example using the morphologyEx function for the morphological
                    opening and closing operations can be found at
                    opencv_source_code/samples/cpp/morphology2.cpp
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Source image. The number of channels can be arbitrary. The depth
                should be one of <code>CV_8U</code>, <code>CV_16U</code>, <code>CV_16S</code>,
                <code>CV_32F</code> or <code>CV_64F</code>.
            </dd>
            <dd><code>dst</code> - Destination image of the same size and type as <code>src</code>.
            </dd>
            <dd><code>op</code> - Type of a morphological operation that can be one of the
                following:
                <ul>
                    <li> MORPH_OPEN - an opening operation
                    <li> MORPH_CLOSE - a closing operation
                    <li> MORPH_GRADIENT - a morphological gradient
                    <li> MORPH_TOPHAT - "top hat"
                    <li> MORPH_BLACKHAT - "black hat"
                </ul>
            </dd>
            <dd><code>kernel</code> - a kernel</dd>
            <dd><code>anchor</code> - a anchor</dd>
            <dd><code>iterations</code> - Number of times erosion and dilation are applied.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#morphologyex">org.opencv.imgproc.Imgproc.morphologyEx</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#erode(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, int, int, org.opencv.core.Scalar)"><code>erode(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#dilate(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, int, int, org.opencv.core.Scalar)"><code>dilate(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, int, int,
                    org.opencv.core.Scalar)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="morphologyEx(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, int, int, org.opencv.core.Scalar)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>morphologyEx</h4>
<pre>public static&nbsp;void&nbsp;morphologyEx(<a href="../../../org/opencv/core/Mat.html"
                                                  title="class in org.opencv.core">Mat</a>&nbsp;src,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                int&nbsp;op,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
                <a href="../../../org/opencv/core/Point.html"
                   title="class in org.opencv.core">Point</a>&nbsp;anchor,
                int&nbsp;iterations,
                int&nbsp;borderType,
                <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;borderValue)</pre>
        <div class="block"><p>Performs advanced morphological transformations.</p>

            <p>The function can perform advanced morphological transformations using an
                erosion and dilation as basic operations.</p>

            <p>Opening operation:</p>

            <p><em>dst = open(src, element)= dilate(erode(src, element))</em></p>

            <p>Closing operation:</p>

            <p><em>dst = close(src, element)= erode(dilate(src, element))</em></p>

            <p>Morphological gradient:</p>

            <p><em>dst = morph_grad(src, element)= dilate(src, element)- erode(src,
                element)</em></p>

            <p>"Top hat":</p>

            <p><em>dst = tophat(src, element)= src - open(src, element)</em></p>

            <p>"Black hat":</p>

            <p><em>dst = blackhat(src, element)= close(src, element)- src</em></p>

            <p>Any of the operations can be done in-place. In case of multi-channel images,
                each channel is processed independently.</p>

            <p>Note:</p>
            <ul>
                <li> An example using the morphologyEx function for the morphological
                    opening and closing operations can be found at
                    opencv_source_code/samples/cpp/morphology2.cpp
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Source image. The number of channels can be arbitrary. The depth
                should be one of <code>CV_8U</code>, <code>CV_16U</code>, <code>CV_16S</code>,
                <code>CV_32F</code> or <code>CV_64F</code>.
            </dd>
            <dd><code>dst</code> - Destination image of the same size and type as <code>src</code>.
            </dd>
            <dd><code>op</code> - Type of a morphological operation that can be one of the
                following:
                <ul>
                    <li> MORPH_OPEN - an opening operation
                    <li> MORPH_CLOSE - a closing operation
                    <li> MORPH_GRADIENT - a morphological gradient
                    <li> MORPH_TOPHAT - "top hat"
                    <li> MORPH_BLACKHAT - "black hat"
                </ul>
            </dd>
            <dd><code>kernel</code> - a kernel</dd>
            <dd><code>anchor</code> - a anchor</dd>
            <dd><code>iterations</code> - Number of times erosion and dilation are applied.</dd>
            <dd><code>borderType</code> - Pixel extrapolation method. See "borderInterpolate" for
                details.
            </dd>
            <dd><code>borderValue</code> - Border value in case of a constant border. The default
                value has a special meaning. See "createMorphologyFilter" for details.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#morphologyex">org.opencv.imgproc.Imgproc.morphologyEx</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#erode(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, int, int, org.opencv.core.Scalar)"><code>erode(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#dilate(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, int, int, org.opencv.core.Scalar)"><code>dilate(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, int, int,
                    org.opencv.core.Scalar)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="phaseCorrelate(org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>phaseCorrelate</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Point.html"
                           title="class in org.opencv.core">Point</a>&nbsp;phaseCorrelate(<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;src2)</pre>
        <div class="block"><p>The function is used to detect translational shifts that occur between
            two
            images. The operation takes advantage of the Fourier shift theorem for
            detecting the translational shift in the frequency domain. It can be used for
            fast image registration as well as motion estimation. For more information
            please see http://en.wikipedia.org/wiki/Phase_correlation.</p>

            <p>Calculates the cross-power spectrum of two supplied source arrays. The arrays
                are padded if needed with "getOptimalDFTSize".</p>

            <p>Return value: detected phase shift (sub-pixel) between the two arrays.</p>

            <p>The function performs the following equations</p>
            <ul>
                <li> First it applies a Hanning window (see
                    http://en.wikipedia.org/wiki/Hann_function)
                    to each image to remove possible edge effects. This window is cached until
                    the array size changes to speed up processing time.
                <li> Next it computes the forward DFTs of each source array:
            </ul>

            <p><em>mathbf(G)_a = mathcal(F)(src_1), mathbf(G)_b = mathcal(F)(src_2)</em></p>

            <p>where <em>mathcal(F)</em> is the forward DFT.</p>
            <ul>
                <li> It then computes the cross-power spectrum of each frequency domain
                    array:
            </ul>

            <p><em>R = (mathbf(G)_a mathbf(G)_b^*)/(|mathbf(G)_a mathbf(G)_b^*|)</em></p>

            <ul>
                <li> Next the cross-correlation is converted back into the time domain via
                    the inverse DFT:
            </ul>

            <p><em>r = mathcal(F)^(-1)(R)</em></p>

            <ul>
                <li> Finally, it computes the peak location and computes a 5x5 weighted
                    centroid around the peak to achieve sub-pixel accuracy.
            </ul>

            <p><em>(Delta x, Delta y) = weightedCentroid (arg max_((x, y))(r))</em></p>

            <ul>
                <li> If non-zero, the response parameter is computed as the sum of the
                    elements of r within the 5x5 centroid around the peak location. It is
                    normalized to a maximum of 1 (meaning there is a single peak) and will be
                    smaller when there are multiple peaks.
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - Source floating point array (CV_32FC1 or CV_64FC1)</dd>
            <dd><code>src2</code> - Source floating point array (CV_32FC1 or CV_64FC1)</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/motion_analysis_and_object_tracking.html#phasecorrelate">org.opencv.imgproc.Imgproc.phaseCorrelate</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#createHanningWindow(org.opencv.core.Mat, org.opencv.core.Size, int)"><code>createHanningWindow(org.opencv.core.Mat,
                    org.opencv.core.Size, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#dft(org.opencv.core.Mat, org.opencv.core.Mat, int, int)"><code>Core.dft(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#mulSpectrums(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, boolean)"><code>Core.mulSpectrums(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, int, boolean)</code></a>,
                <a href="../../../org/opencv/core/Core.html#getOptimalDFTSize(int)"><code>Core.getOptimalDFTSize(int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#idft(org.opencv.core.Mat, org.opencv.core.Mat, int, int)"><code>Core.idft(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="phaseCorrelate(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>phaseCorrelate</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Point.html"
                           title="class in org.opencv.core">Point</a>&nbsp;phaseCorrelate(<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;src2,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;window)</pre>
        <div class="block"><p>The function is used to detect translational shifts that occur between
            two
            images. The operation takes advantage of the Fourier shift theorem for
            detecting the translational shift in the frequency domain. It can be used for
            fast image registration as well as motion estimation. For more information
            please see http://en.wikipedia.org/wiki/Phase_correlation.</p>

            <p>Calculates the cross-power spectrum of two supplied source arrays. The arrays
                are padded if needed with "getOptimalDFTSize".</p>

            <p>Return value: detected phase shift (sub-pixel) between the two arrays.</p>

            <p>The function performs the following equations</p>
            <ul>
                <li> First it applies a Hanning window (see
                    http://en.wikipedia.org/wiki/Hann_function)
                    to each image to remove possible edge effects. This window is cached until
                    the array size changes to speed up processing time.
                <li> Next it computes the forward DFTs of each source array:
            </ul>

            <p><em>mathbf(G)_a = mathcal(F)(src_1), mathbf(G)_b = mathcal(F)(src_2)</em></p>

            <p>where <em>mathcal(F)</em> is the forward DFT.</p>
            <ul>
                <li> It then computes the cross-power spectrum of each frequency domain
                    array:
            </ul>

            <p><em>R = (mathbf(G)_a mathbf(G)_b^*)/(|mathbf(G)_a mathbf(G)_b^*|)</em></p>

            <ul>
                <li> Next the cross-correlation is converted back into the time domain via
                    the inverse DFT:
            </ul>

            <p><em>r = mathcal(F)^(-1)(R)</em></p>

            <ul>
                <li> Finally, it computes the peak location and computes a 5x5 weighted
                    centroid around the peak to achieve sub-pixel accuracy.
            </ul>

            <p><em>(Delta x, Delta y) = weightedCentroid (arg max_((x, y))(r))</em></p>

            <ul>
                <li> If non-zero, the response parameter is computed as the sum of the
                    elements of r within the 5x5 centroid around the peak location. It is
                    normalized to a maximum of 1 (meaning there is a single peak) and will be
                    smaller when there are multiple peaks.
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src1</code> - Source floating point array (CV_32FC1 or CV_64FC1)</dd>
            <dd><code>src2</code> - Source floating point array (CV_32FC1 or CV_64FC1)</dd>
            <dd><code>window</code> - Floating point array with windowing coefficients to reduce
                edge
                effects (optional).
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/motion_analysis_and_object_tracking.html#phasecorrelate">org.opencv.imgproc.Imgproc.phaseCorrelate</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#createHanningWindow(org.opencv.core.Mat, org.opencv.core.Size, int)"><code>createHanningWindow(org.opencv.core.Mat,
                    org.opencv.core.Size, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#dft(org.opencv.core.Mat, org.opencv.core.Mat, int, int)"><code>Core.dft(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#mulSpectrums(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, boolean)"><code>Core.mulSpectrums(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, int, boolean)</code></a>,
                <a href="../../../org/opencv/core/Core.html#getOptimalDFTSize(int)"><code>Core.getOptimalDFTSize(int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#idft(org.opencv.core.Mat, org.opencv.core.Mat, int, int)"><code>Core.idft(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="phaseCorrelateRes(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>phaseCorrelateRes</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Point.html"
                           title="class in org.opencv.core">Point</a>&nbsp;phaseCorrelateRes(<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;window)</pre>
    </li>
</ul>
<a name="phaseCorrelateRes(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, double[])">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>phaseCorrelateRes</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Point.html"
                           title="class in org.opencv.core">Point</a>&nbsp;phaseCorrelateRes(<a
        href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;window,
                      double[]&nbsp;response)</pre>
    </li>
</ul>
<a name="pointPolygonTest(org.opencv.core.MatOfPoint2f, org.opencv.core.Point, boolean)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>pointPolygonTest</h4>
<pre>public static&nbsp;double&nbsp;pointPolygonTest(<a
        href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;contour,
                      <a href="../../../org/opencv/core/Point.html"
                         title="class in org.opencv.core">Point</a>&nbsp;pt,
                      boolean&nbsp;measureDist)</pre>
        <div class="block"><p>Performs a point-in-contour test.</p>

            <p>The function determines whether the point is inside a contour, outside, or
                lies on an edge (or coincides with a vertex). It returns positive (inside),
                negative (outside), or zero (on an edge) value, correspondingly. When
                <code>measureDist=false</code>, the return value is +1, -1, and 0,
                respectively. Otherwise, the return value is a signed distance between the
                point and the nearest contour edge.</p>

            <p>See below a sample output of the function where each image pixel is tested
                against the contour.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>contour</code> - Input contour.</dd>
            <dd><code>pt</code> - Point tested against the contour.</dd>
            <dd><code>measureDist</code> - If true, the function estimates the signed distance from
                the point to the nearest contour edge. Otherwise, the function only checks if
                the point is inside a contour or not.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#pointpolygontest">org.opencv.imgproc.Imgproc.pointPolygonTest</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="preCornerDetect(org.opencv.core.Mat, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>preCornerDetect</h4>
<pre>public static&nbsp;void&nbsp;preCornerDetect(<a href="../../../org/opencv/core/Mat.html"
                                                     title="class in org.opencv.core">Mat</a>&nbsp;src,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;dst,
                   int&nbsp;ksize)</pre>
        <div class="block"><p>Calculates a feature map for corner detection.</p>

            <p>The function calculates the complex spatial derivative-based function of the
                source image</p>

            <p><em>dst = (D_x src)^2 * D_(yy) src + (D_y src)^2 * D_(xx) src - 2 D_x src *
                D_y src * D_(xy) src</em></p>

            <p>where <em>D_x</em>,<em>D_y</em> are the first image derivatives,
                <em>D_(xx)</em>,<em>D_(yy)</em> are the second image derivatives, and
                <em>D_(xy)</em> is the mixed derivative.
                The corners can be found as local maximums of the functions, as shown below:
                <code></p>

            <p>// C++ code:</p>

            <p>Mat corners, dilated_corners;</p>

            <p>preCornerDetect(image, corners, 3);</p>

            <p>// dilation with 3x3 rectangular structuring element</p>

            <p>dilate(corners, dilated_corners, Mat(), 1);</p>

            <p>Mat corner_mask = corners == dilated_corners;</p>

            <p></code></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Source single-channel 8-bit of floating-point image.</dd>
            <dd><code>dst</code> - Output image that has the type <code>CV_32F</code> and the same
                size as <code>src</code>.
            </dd>
            <dd><code>ksize</code> - Aperture size of the "Sobel".</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#precornerdetect">org.opencv.imgproc.Imgproc.preCornerDetect</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="preCornerDetect(org.opencv.core.Mat, org.opencv.core.Mat, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>preCornerDetect</h4>
<pre>public static&nbsp;void&nbsp;preCornerDetect(<a href="../../../org/opencv/core/Mat.html"
                                                     title="class in org.opencv.core">Mat</a>&nbsp;src,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;dst,
                   int&nbsp;ksize,
                   int&nbsp;borderType)</pre>
        <div class="block"><p>Calculates a feature map for corner detection.</p>

            <p>The function calculates the complex spatial derivative-based function of the
                source image</p>

            <p><em>dst = (D_x src)^2 * D_(yy) src + (D_y src)^2 * D_(xx) src - 2 D_x src *
                D_y src * D_(xy) src</em></p>

            <p>where <em>D_x</em>,<em>D_y</em> are the first image derivatives,
                <em>D_(xx)</em>,<em>D_(yy)</em> are the second image derivatives, and
                <em>D_(xy)</em> is the mixed derivative.
                The corners can be found as local maximums of the functions, as shown below:
                <code></p>

            <p>// C++ code:</p>

            <p>Mat corners, dilated_corners;</p>

            <p>preCornerDetect(image, corners, 3);</p>

            <p>// dilation with 3x3 rectangular structuring element</p>

            <p>dilate(corners, dilated_corners, Mat(), 1);</p>

            <p>Mat corner_mask = corners == dilated_corners;</p>

            <p></code></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Source single-channel 8-bit of floating-point image.</dd>
            <dd><code>dst</code> - Output image that has the type <code>CV_32F</code> and the same
                size as <code>src</code>.
            </dd>
            <dd><code>ksize</code> - Aperture size of the "Sobel".</dd>
            <dd><code>borderType</code> - Pixel extrapolation method. See "borderInterpolate".</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#precornerdetect">org.opencv.imgproc.Imgproc.preCornerDetect</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="PSNR(org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>PSNR</h4>
<pre>public static&nbsp;double&nbsp;PSNR(<a href="../../../org/opencv/core/Mat.html"
                                            title="class in org.opencv.core">Mat</a>&nbsp;src1,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2)</pre>
    </li>
</ul>
<a name="pyrDown(org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>pyrDown</h4>
<pre>public static&nbsp;void&nbsp;pyrDown(<a href="../../../org/opencv/core/Mat.html"
                                             title="class in org.opencv.core">Mat</a>&nbsp;src,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Blurs an image and downsamples it.</p>

            <p>By default, size of the output image is computed as <code>Size((src.cols+1)/2,
                (src.rows+1)/2)</code>, but in any case, the following conditions should be
                satisfied:</p>

            <p><em> ltBR gt| dstsize.width *2-src.cols| <= 2
                |dstsize.height *2-src.rows| <= 2 </em></p>

            <p>The function performs the downsampling step of the Gaussian pyramid
                construction. First, it convolves the source image with the kernel:</p>

            <p><em>1/256 1 4 6 4 1
                4 16 24 16 4
                6 24 36 24 6
                4 16 24 16 4
                1 4 6 4 1 </em></p>

            <p>Then, it downsamples the image by rejecting even rows and columns.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image.</dd>
            <dd><code>dst</code> - output image; it has the specified size and the same type as
                <code>src</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#pyrdown">org.opencv.imgproc.Imgproc.pyrDown</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="pyrDown(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>pyrDown</h4>
<pre>public static&nbsp;void&nbsp;pyrDown(<a href="../../../org/opencv/core/Mat.html"
                                             title="class in org.opencv.core">Mat</a>&nbsp;src,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
           <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dstsize)</pre>
        <div class="block"><p>Blurs an image and downsamples it.</p>

            <p>By default, size of the output image is computed as <code>Size((src.cols+1)/2,
                (src.rows+1)/2)</code>, but in any case, the following conditions should be
                satisfied:</p>

            <p><em> ltBR gt| dstsize.width *2-src.cols| <= 2
                |dstsize.height *2-src.rows| <= 2 </em></p>

            <p>The function performs the downsampling step of the Gaussian pyramid
                construction. First, it convolves the source image with the kernel:</p>

            <p><em>1/256 1 4 6 4 1
                4 16 24 16 4
                6 24 36 24 6
                4 16 24 16 4
                1 4 6 4 1 </em></p>

            <p>Then, it downsamples the image by rejecting even rows and columns.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image.</dd>
            <dd><code>dst</code> - output image; it has the specified size and the same type as
                <code>src</code>.
            </dd>
            <dd><code>dstsize</code> - size of the output image.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#pyrdown">org.opencv.imgproc.Imgproc.pyrDown</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="pyrDown(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>pyrDown</h4>
<pre>public static&nbsp;void&nbsp;pyrDown(<a href="../../../org/opencv/core/Mat.html"
                                             title="class in org.opencv.core">Mat</a>&nbsp;src,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
           <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dstsize,
           int&nbsp;borderType)</pre>
        <div class="block"><p>Blurs an image and downsamples it.</p>

            <p>By default, size of the output image is computed as <code>Size((src.cols+1)/2,
                (src.rows+1)/2)</code>, but in any case, the following conditions should be
                satisfied:</p>

            <p><em> ltBR gt| dstsize.width *2-src.cols| <= 2
                |dstsize.height *2-src.rows| <= 2 </em></p>

            <p>The function performs the downsampling step of the Gaussian pyramid
                construction. First, it convolves the source image with the kernel:</p>

            <p><em>1/256 1 4 6 4 1
                4 16 24 16 4
                6 24 36 24 6
                4 16 24 16 4
                1 4 6 4 1 </em></p>

            <p>Then, it downsamples the image by rejecting even rows and columns.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image.</dd>
            <dd><code>dst</code> - output image; it has the specified size and the same type as
                <code>src</code>.
            </dd>
            <dd><code>dstsize</code> - size of the output image.</dd>
            <dd><code>borderType</code> - Pixel extrapolation method (BORDER_CONSTANT don't
                supported). See "borderInterpolate" for details.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#pyrdown">org.opencv.imgproc.Imgproc.pyrDown</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="pyrMeanShiftFiltering(org.opencv.core.Mat, org.opencv.core.Mat, double, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>pyrMeanShiftFiltering</h4>
<pre>public static&nbsp;void&nbsp;pyrMeanShiftFiltering(<a href="../../../org/opencv/core/Mat.html"
                                                           title="class in org.opencv.core">Mat</a>&nbsp;src,
                         <a href="../../../org/opencv/core/Mat.html"
                            title="class in org.opencv.core">Mat</a>&nbsp;dst,
                         double&nbsp;sp,
                         double&nbsp;sr)</pre>
        <div class="block"><p>Performs initial step of meanshift segmentation of an image.</p>

            <p>The function implements the filtering stage of meanshift segmentation, that
                is, the output of the function is the filtered "posterized" image with color
                gradients and fine-grain texture flattened. At every pixel <code>(X,Y)</code>
                of the input image (or down-sized input image, see below) the function
                executes meanshift iterations, that is, the pixel <code>(X,Y)</code>
                neighborhood in the joint space-color hyperspace is considered:</p>

            <p><em>(x,y): X- sp <= x <= X+ sp, Y- sp <= y <= Y+ sp, ||(R,G,B)-(r,g,b)|| <=
                sr</em></p>

            <p>where <code>(R,G,B)</code> and <code>(r,g,b)</code> are the vectors of color
                components at <code>(X,Y)</code> and <code>(x,y)</code>, respectively
                (though, the algorithm does not depend on the color space used, so any
                3-component color space can be used instead). Over the neighborhood the
                average spatial value <code>(X',Y')</code> and average color vector
                <code>(R',G',B')</code> are found and they act as the neighborhood center on
                the next iteration:</p>

            <p><em>(X,Y)~(X',Y'), (R,G,B)~(R',G',B').</em></p>

            <p>After the iterations over, the color components of the initial pixel (that
                is, the pixel from where the iterations started) are set to the final value
                (average color at the last iteration):</p>

            <p><em>I(X,Y) &lt- (R*,G*,B*)</em></p>

            <p>When <code>maxLevel > 0</code>, the gaussian pyramid of <code>maxLevel+1</code>
                levels is built, and the above procedure is run on the smallest layer first.
                After that, the results are propagated to the larger layer and the iterations
                are run again only on those pixels where the layer colors differ by more than
                <code>sr</code> from the lower-resolution layer of the pyramid. That makes
                boundaries of color regions sharper. Note that the results will be actually
                different from the ones obtained by running the meanshift procedure on the
                whole original image (i.e. when <code>maxLevel==0</code>).</p>

            <p>Note:</p>
            <ul>
                <li> An example using mean-shift image segmentation can be found at
                    opencv_source_code/samples/cpp/meanshift_segmentation.cpp
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - The source 8-bit, 3-channel image.</dd>
            <dd><code>dst</code> - The destination image of the same format and the same size as the
                source.
            </dd>
            <dd><code>sp</code> - The spatial window radius.</dd>
            <dd><code>sr</code> - The color window radius.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#pyrmeanshiftfiltering">org.opencv.imgproc.Imgproc.pyrMeanShiftFiltering</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="pyrMeanShiftFiltering(org.opencv.core.Mat, org.opencv.core.Mat, double, double, int, org.opencv.core.TermCriteria)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>pyrMeanShiftFiltering</h4>
<pre>public static&nbsp;void&nbsp;pyrMeanShiftFiltering(<a href="../../../org/opencv/core/Mat.html"
                                                           title="class in org.opencv.core">Mat</a>&nbsp;src,
                         <a href="../../../org/opencv/core/Mat.html"
                            title="class in org.opencv.core">Mat</a>&nbsp;dst,
                         double&nbsp;sp,
                         double&nbsp;sr,
                         int&nbsp;maxLevel,
                         <a href="../../../org/opencv/core/TermCriteria.html"
                            title="class in org.opencv.core">TermCriteria</a>&nbsp;termcrit)</pre>
        <div class="block"><p>Performs initial step of meanshift segmentation of an image.</p>

            <p>The function implements the filtering stage of meanshift segmentation, that
                is, the output of the function is the filtered "posterized" image with color
                gradients and fine-grain texture flattened. At every pixel <code>(X,Y)</code>
                of the input image (or down-sized input image, see below) the function
                executes meanshift iterations, that is, the pixel <code>(X,Y)</code>
                neighborhood in the joint space-color hyperspace is considered:</p>

            <p><em>(x,y): X- sp <= x <= X+ sp, Y- sp <= y <= Y+ sp, ||(R,G,B)-(r,g,b)|| <=
                sr</em></p>

            <p>where <code>(R,G,B)</code> and <code>(r,g,b)</code> are the vectors of color
                components at <code>(X,Y)</code> and <code>(x,y)</code>, respectively
                (though, the algorithm does not depend on the color space used, so any
                3-component color space can be used instead). Over the neighborhood the
                average spatial value <code>(X',Y')</code> and average color vector
                <code>(R',G',B')</code> are found and they act as the neighborhood center on
                the next iteration:</p>

            <p><em>(X,Y)~(X',Y'), (R,G,B)~(R',G',B').</em></p>

            <p>After the iterations over, the color components of the initial pixel (that
                is, the pixel from where the iterations started) are set to the final value
                (average color at the last iteration):</p>

            <p><em>I(X,Y) &lt- (R*,G*,B*)</em></p>

            <p>When <code>maxLevel > 0</code>, the gaussian pyramid of <code>maxLevel+1</code>
                levels is built, and the above procedure is run on the smallest layer first.
                After that, the results are propagated to the larger layer and the iterations
                are run again only on those pixels where the layer colors differ by more than
                <code>sr</code> from the lower-resolution layer of the pyramid. That makes
                boundaries of color regions sharper. Note that the results will be actually
                different from the ones obtained by running the meanshift procedure on the
                whole original image (i.e. when <code>maxLevel==0</code>).</p>

            <p>Note:</p>
            <ul>
                <li> An example using mean-shift image segmentation can be found at
                    opencv_source_code/samples/cpp/meanshift_segmentation.cpp
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - The source 8-bit, 3-channel image.</dd>
            <dd><code>dst</code> - The destination image of the same format and the same size as the
                source.
            </dd>
            <dd><code>sp</code> - The spatial window radius.</dd>
            <dd><code>sr</code> - The color window radius.</dd>
            <dd><code>maxLevel</code> - Maximum level of the pyramid for the segmentation.</dd>
            <dd><code>termcrit</code> - Termination criteria: when to stop meanshift iterations.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#pyrmeanshiftfiltering">org.opencv.imgproc.Imgproc.pyrMeanShiftFiltering</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="pyrUp(org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>pyrUp</h4>
<pre>public static&nbsp;void&nbsp;pyrUp(<a href="../../../org/opencv/core/Mat.html"
                                           title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
        <div class="block"><p>Upsamples an image and then blurs it.</p>

            <p>By default, size of the output image is computed as <code>Size(src.cols*2,
                (src.rows*2)</code>, but in any case, the following conditions should be
                satisfied:</p>

            <p><em> ltBR gt| dstsize.width -src.cols*2| <= (dstsize.width mod 2)
                |dstsize.height -src.rows*2| <= (dstsize.height mod 2) </em></p>

            <p>The function performs the upsampling step of the Gaussian pyramid
                construction, though it can actually be used to construct the Laplacian
                pyramid. First, it upsamples the source image by injecting even zero rows and
                columns and then convolves the result with the same kernel as in "pyrDown"
                multiplied by 4.</p>

            <p>Note:</p>
            <ul>
                <li> (Python) An example of Laplacian Pyramid construction and merging can
                    be found at opencv_source_code/samples/python2/lappyr.py
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image.</dd>
            <dd><code>dst</code> - output image. It has the specified size and the same type as
                <code>src</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#pyrup">org.opencv.imgproc.Imgproc.pyrUp</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="pyrUp(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>pyrUp</h4>
<pre>public static&nbsp;void&nbsp;pyrUp(<a href="../../../org/opencv/core/Mat.html"
                                           title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
         <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dstsize)</pre>
        <div class="block"><p>Upsamples an image and then blurs it.</p>

            <p>By default, size of the output image is computed as <code>Size(src.cols*2,
                (src.rows*2)</code>, but in any case, the following conditions should be
                satisfied:</p>

            <p><em> ltBR gt| dstsize.width -src.cols*2| <= (dstsize.width mod 2)
                |dstsize.height -src.rows*2| <= (dstsize.height mod 2) </em></p>

            <p>The function performs the upsampling step of the Gaussian pyramid
                construction, though it can actually be used to construct the Laplacian
                pyramid. First, it upsamples the source image by injecting even zero rows and
                columns and then convolves the result with the same kernel as in "pyrDown"
                multiplied by 4.</p>

            <p>Note:</p>
            <ul>
                <li> (Python) An example of Laplacian Pyramid construction and merging can
                    be found at opencv_source_code/samples/python2/lappyr.py
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image.</dd>
            <dd><code>dst</code> - output image. It has the specified size and the same type as
                <code>src</code>.
            </dd>
            <dd><code>dstsize</code> - size of the output image.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#pyrup">org.opencv.imgproc.Imgproc.pyrUp</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="pyrUp(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>pyrUp</h4>
<pre>public static&nbsp;void&nbsp;pyrUp(<a href="../../../org/opencv/core/Mat.html"
                                           title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
         <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dstsize,
         int&nbsp;borderType)</pre>
        <div class="block"><p>Upsamples an image and then blurs it.</p>

            <p>By default, size of the output image is computed as <code>Size(src.cols*2,
                (src.rows*2)</code>, but in any case, the following conditions should be
                satisfied:</p>

            <p><em> ltBR gt| dstsize.width -src.cols*2| <= (dstsize.width mod 2)
                |dstsize.height -src.rows*2| <= (dstsize.height mod 2) </em></p>

            <p>The function performs the upsampling step of the Gaussian pyramid
                construction, though it can actually be used to construct the Laplacian
                pyramid. First, it upsamples the source image by injecting even zero rows and
                columns and then convolves the result with the same kernel as in "pyrDown"
                multiplied by 4.</p>

            <p>Note:</p>
            <ul>
                <li> (Python) An example of Laplacian Pyramid construction and merging can
                    be found at opencv_source_code/samples/python2/lappyr.py
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image.</dd>
            <dd><code>dst</code> - output image. It has the specified size and the same type as
                <code>src</code>.
            </dd>
            <dd><code>dstsize</code> - size of the output image.</dd>
            <dd><code>borderType</code> - Pixel extrapolation method (only BORDER_DEFAULT
                supported).
                See "borderInterpolate" for details.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#pyrup">org.opencv.imgproc.Imgproc.pyrUp</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="remap(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>remap</h4>
<pre>public static&nbsp;void&nbsp;remap(<a href="../../../org/opencv/core/Mat.html"
                                           title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map2,
         int&nbsp;interpolation)</pre>
        <div class="block"><p>Applies a generic geometrical transformation to an image.</p>

            <p>The function <code>remap</code> transforms the source image using the
                specified map:</p>

            <p><em>dst(x,y) = src(map_x(x,y),map_y(x,y))</em></p>

            <p>where values of pixels with non-integer coordinates are computed using one of
                available interpolation methods.
                <em>map_x</em> and <em>map_y</em> can be encoded as separate floating-point
                maps in <em>map_1</em> and <em>map_2</em> respectively, or interleaved
                floating-point maps of <em>(x,y)</em> in <em>map_1</em>, or fixed-point maps
                created by using "convertMaps". The reason you might want to convert from
                floating to fixed-point representations of a map is that they can yield much
                faster (~2x) remapping operations. In the converted case, <em>map_1</em>
                contains pairs <code>(cvFloor(x), cvFloor(y))</code> and <em>map_2</em>
                contains indices in a table of interpolation coefficients.</p>

            <p>This function cannot operate in-place.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Source image.</dd>
            <dd><code>dst</code> - Destination image. It has the same size as <code>map1</code> and
                the same type as <code>src</code>.
            </dd>
            <dd><code>map1</code> - The first map of either <code>(x,y)</code> points or just
                <code>x</code> values having the type <code>CV_16SC2</code>,
                <code>CV_32FC1</code>, or <code>CV_32FC2</code>. See "convertMaps" for
                details on converting a floating point representation to fixed-point for
                speed.
            </dd>
            <dd><code>map2</code> - The second map of <code>y</code> values having the type
                <code>CV_16UC1</code>, <code>CV_32FC1</code>, or none (empty map if
                <code>map1</code> is <code>(x,y)</code> points), respectively.
            </dd>
            <dd><code>interpolation</code> - Interpolation method (see "resize"). The method
                <code>INTER_AREA</code> is not supported by this function.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#remap">org.opencv.imgproc.Imgproc.remap</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="remap(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int, org.opencv.core.Scalar)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>remap</h4>
<pre>public static&nbsp;void&nbsp;remap(<a href="../../../org/opencv/core/Mat.html"
                                           title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map1,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map2,
         int&nbsp;interpolation,
         int&nbsp;borderMode,
         <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;borderValue)</pre>
        <div class="block"><p>Applies a generic geometrical transformation to an image.</p>

            <p>The function <code>remap</code> transforms the source image using the
                specified map:</p>

            <p><em>dst(x,y) = src(map_x(x,y),map_y(x,y))</em></p>

            <p>where values of pixels with non-integer coordinates are computed using one of
                available interpolation methods.
                <em>map_x</em> and <em>map_y</em> can be encoded as separate floating-point
                maps in <em>map_1</em> and <em>map_2</em> respectively, or interleaved
                floating-point maps of <em>(x,y)</em> in <em>map_1</em>, or fixed-point maps
                created by using "convertMaps". The reason you might want to convert from
                floating to fixed-point representations of a map is that they can yield much
                faster (~2x) remapping operations. In the converted case, <em>map_1</em>
                contains pairs <code>(cvFloor(x), cvFloor(y))</code> and <em>map_2</em>
                contains indices in a table of interpolation coefficients.</p>

            <p>This function cannot operate in-place.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Source image.</dd>
            <dd><code>dst</code> - Destination image. It has the same size as <code>map1</code> and
                the same type as <code>src</code>.
            </dd>
            <dd><code>map1</code> - The first map of either <code>(x,y)</code> points or just
                <code>x</code> values having the type <code>CV_16SC2</code>,
                <code>CV_32FC1</code>, or <code>CV_32FC2</code>. See "convertMaps" for
                details on converting a floating point representation to fixed-point for
                speed.
            </dd>
            <dd><code>map2</code> - The second map of <code>y</code> values having the type
                <code>CV_16UC1</code>, <code>CV_32FC1</code>, or none (empty map if
                <code>map1</code> is <code>(x,y)</code> points), respectively.
            </dd>
            <dd><code>interpolation</code> - Interpolation method (see "resize"). The method
                <code>INTER_AREA</code> is not supported by this function.
            </dd>
            <dd><code>borderMode</code> - Pixel extrapolation method (see "borderInterpolate"). When
                <code>borderMode=BORDER_TRANSPARENT</code>, it means that the pixels in the
                destination image that corresponds to the "outliers" in the source image are
                not modified by the function.
            </dd>
            <dd><code>borderValue</code> - Value used in case of a constant border. By default, it
                is
                0.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#remap">org.opencv.imgproc.Imgproc.remap</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="resize(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>resize</h4>
<pre>public static&nbsp;void&nbsp;resize(<a href="../../../org/opencv/core/Mat.html"
                                            title="class in org.opencv.core">Mat</a>&nbsp;src,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
          <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize)</pre>
        <div class="block"><p>Resizes an image.</p>

            <p>The function <code>resize</code> resizes the image <code>src</code> down to
                or up to the specified size.Note that the initial <code>dst</code> type or
                size are not taken into account. Instead, the size and type are derived from
                the <code>src</code>,<code>dsize</code>,<code>fx</code>, and <code>fy</code>.
                If you want to resize <code>src</code> so that it fits the pre-created
                <code>dst</code>, you may call the function as follows: <code></p>

            <p>// C++ code:</p>

            <p>// explicitly specify dsize=dst.size(); fx and fy will be computed from that.</p>

            <p>resize(src, dst, dst.size(), 0, 0, interpolation);</p>

            <p>If you want to decimate the image by factor of 2 in each direction, you can
                call the function this way:</p>

            <p>// specify fx and fy and let the function compute the destination image size.</p>

            <p>resize(src, dst, Size(), 0.5, 0.5, interpolation);</p>

            <p>To shrink an image, it will generally look best with CV_INTER_AREA
                interpolation, whereas to enlarge an image, it will generally look best with
                CV_INTER_CUBIC (slow) or CV_INTER_LINEAR (faster but still looks OK).
                </code></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image.</dd>
            <dd><code>dst</code> - output image; it has the size <code>dsize</code> (when it is
                non-zero) or the size computed from <code>src.size()</code>, <code>fx</code>,
                and <code>fy</code>; the type of <code>dst</code> is the same as of
                <code>src</code>.
            </dd>
            <dd><code>dsize</code> - output image size; if it equals zero, it is computed as:

                <p><em>dsize = Size(round(fx*src.cols), round(fy*src.rows))</em></p>

                <p>Either <code>dsize</code> or both <code>fx</code> and <code>fy</code> must be
                    non-zero.</p></dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#resize">org.opencv.imgproc.Imgproc.resize</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#warpAffine(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int, org.opencv.core.Scalar)"><code>warpAffine(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#remap(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int, org.opencv.core.Scalar)"><code>remap(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#warpPerspective(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int, org.opencv.core.Scalar)"><code>warpPerspective(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int,
                    org.opencv.core.Scalar)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="resize(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double, double, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>resize</h4>
<pre>public static&nbsp;void&nbsp;resize(<a href="../../../org/opencv/core/Mat.html"
                                            title="class in org.opencv.core">Mat</a>&nbsp;src,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
          <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize,
          double&nbsp;fx,
          double&nbsp;fy,
          int&nbsp;interpolation)</pre>
        <div class="block"><p>Resizes an image.</p>

            <p>The function <code>resize</code> resizes the image <code>src</code> down to
                or up to the specified size.Note that the initial <code>dst</code> type or
                size are not taken into account. Instead, the size and type are derived from
                the <code>src</code>,<code>dsize</code>,<code>fx</code>, and <code>fy</code>.
                If you want to resize <code>src</code> so that it fits the pre-created
                <code>dst</code>, you may call the function as follows: <code></p>

            <p>// C++ code:</p>

            <p>// explicitly specify dsize=dst.size(); fx and fy will be computed from that.</p>

            <p>resize(src, dst, dst.size(), 0, 0, interpolation);</p>

            <p>If you want to decimate the image by factor of 2 in each direction, you can
                call the function this way:</p>

            <p>// specify fx and fy and let the function compute the destination image size.</p>

            <p>resize(src, dst, Size(), 0.5, 0.5, interpolation);</p>

            <p>To shrink an image, it will generally look best with CV_INTER_AREA
                interpolation, whereas to enlarge an image, it will generally look best with
                CV_INTER_CUBIC (slow) or CV_INTER_LINEAR (faster but still looks OK).
                </code></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image.</dd>
            <dd><code>dst</code> - output image; it has the size <code>dsize</code> (when it is
                non-zero) or the size computed from <code>src.size()</code>, <code>fx</code>,
                and <code>fy</code>; the type of <code>dst</code> is the same as of
                <code>src</code>.
            </dd>
            <dd><code>dsize</code> - output image size; if it equals zero, it is computed as:

                <p><em>dsize = Size(round(fx*src.cols), round(fy*src.rows))</em></p>

                <p>Either <code>dsize</code> or both <code>fx</code> and <code>fy</code> must be
                    non-zero.</p></dd>
            <dd><code>fx</code> - scale factor along the horizontal axis; when it equals 0, it is
                computed as

                <p><em>(double)dsize.width/src.cols</em></p></dd>
            <dd><code>fy</code> - scale factor along the vertical axis; when it equals 0, it is
                computed as

                <p><em>(double)dsize.height/src.rows</em></p></dd>
            <dd><code>interpolation</code> - interpolation method:
                <ul>
                    <li> INTER_NEAREST - a nearest-neighbor interpolation
                    <li> INTER_LINEAR - a bilinear interpolation (used by default)
                    <li> INTER_AREA - resampling using pixel area relation. It may be a
                        preferred method for image decimation, as it gives moire'-free results. But
                        when the image is zoomed, it is similar to the <code>INTER_NEAREST</code>
                        method.
                    <li> INTER_CUBIC - a bicubic interpolation over 4x4 pixel neighborhood
                    <li> INTER_LANCZOS4 - a Lanczos interpolation over 8x8 pixel neighborhood
                </ul>
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#resize">org.opencv.imgproc.Imgproc.resize</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#warpAffine(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int, org.opencv.core.Scalar)"><code>warpAffine(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#remap(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int, org.opencv.core.Scalar)"><code>remap(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#warpPerspective(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int, org.opencv.core.Scalar)"><code>warpPerspective(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int,
                    org.opencv.core.Scalar)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="Scharr(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>Scharr</h4>
<pre>public static&nbsp;void&nbsp;Scharr(<a href="../../../org/opencv/core/Mat.html"
                                            title="class in org.opencv.core">Mat</a>&nbsp;src,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
          int&nbsp;ddepth,
          int&nbsp;dx,
          int&nbsp;dy)</pre>
        <div class="block"><p>Calculates the first x- or y- image derivative using Scharr
            operator.</p>

            <p>The function computes the first x- or y- spatial image derivative using the
                Scharr operator. The call</p>

            <p><em>Scharr(src, dst, ddepth, dx, dy, scale, delta, borderType)</em></p>

            <p>is equivalent to</p>

            <p><em>Sobel(src, dst, ddepth, dx, dy, CV_SCHARR, scale, delta,
                borderType).</em></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image.</dd>
            <dd><code>dst</code> - output image of the same size and the same number of channels as
                <code>src</code>.
            </dd>
            <dd><code>ddepth</code> - output image depth (see "Sobel" for the list of supported
                combination of <code>src.depth()</code> and <code>ddepth</code>).
            </dd>
            <dd><code>dx</code> - order of the derivative x.</dd>
            <dd><code>dy</code> - order of the derivative y.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#scharr">org.opencv.imgproc.Imgproc.Scharr</a>,
                <a href="../../../org/opencv/core/Core.html#cartToPolar(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)"><code>Core.cartToPolar(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat,
                    boolean)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="Scharr(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, double, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>Scharr</h4>
<pre>public static&nbsp;void&nbsp;Scharr(<a href="../../../org/opencv/core/Mat.html"
                                            title="class in org.opencv.core">Mat</a>&nbsp;src,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
          int&nbsp;ddepth,
          int&nbsp;dx,
          int&nbsp;dy,
          double&nbsp;scale,
          double&nbsp;delta)</pre>
        <div class="block"><p>Calculates the first x- or y- image derivative using Scharr
            operator.</p>

            <p>The function computes the first x- or y- spatial image derivative using the
                Scharr operator. The call</p>

            <p><em>Scharr(src, dst, ddepth, dx, dy, scale, delta, borderType)</em></p>

            <p>is equivalent to</p>

            <p><em>Sobel(src, dst, ddepth, dx, dy, CV_SCHARR, scale, delta,
                borderType).</em></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image.</dd>
            <dd><code>dst</code> - output image of the same size and the same number of channels as
                <code>src</code>.
            </dd>
            <dd><code>ddepth</code> - output image depth (see "Sobel" for the list of supported
                combination of <code>src.depth()</code> and <code>ddepth</code>).
            </dd>
            <dd><code>dx</code> - order of the derivative x.</dd>
            <dd><code>dy</code> - order of the derivative y.</dd>
            <dd><code>scale</code> - optional scale factor for the computed derivative values; by
                default, no scaling is applied (see "getDerivKernels" for details).
            </dd>
            <dd><code>delta</code> - optional delta value that is added to the results prior to
                storing them in <code>dst</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#scharr">org.opencv.imgproc.Imgproc.Scharr</a>,
                <a href="../../../org/opencv/core/Core.html#cartToPolar(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)"><code>Core.cartToPolar(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat,
                    boolean)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="Scharr(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, double, double, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>Scharr</h4>
<pre>public static&nbsp;void&nbsp;Scharr(<a href="../../../org/opencv/core/Mat.html"
                                            title="class in org.opencv.core">Mat</a>&nbsp;src,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
          int&nbsp;ddepth,
          int&nbsp;dx,
          int&nbsp;dy,
          double&nbsp;scale,
          double&nbsp;delta,
          int&nbsp;borderType)</pre>
        <div class="block"><p>Calculates the first x- or y- image derivative using Scharr
            operator.</p>

            <p>The function computes the first x- or y- spatial image derivative using the
                Scharr operator. The call</p>

            <p><em>Scharr(src, dst, ddepth, dx, dy, scale, delta, borderType)</em></p>

            <p>is equivalent to</p>

            <p><em>Sobel(src, dst, ddepth, dx, dy, CV_SCHARR, scale, delta,
                borderType).</em></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image.</dd>
            <dd><code>dst</code> - output image of the same size and the same number of channels as
                <code>src</code>.
            </dd>
            <dd><code>ddepth</code> - output image depth (see "Sobel" for the list of supported
                combination of <code>src.depth()</code> and <code>ddepth</code>).
            </dd>
            <dd><code>dx</code> - order of the derivative x.</dd>
            <dd><code>dy</code> - order of the derivative y.</dd>
            <dd><code>scale</code> - optional scale factor for the computed derivative values; by
                default, no scaling is applied (see "getDerivKernels" for details).
            </dd>
            <dd><code>delta</code> - optional delta value that is added to the results prior to
                storing them in <code>dst</code>.
            </dd>
            <dd><code>borderType</code> - pixel extrapolation method (see "borderInterpolate" for
                details).
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#scharr">org.opencv.imgproc.Imgproc.Scharr</a>,
                <a href="../../../org/opencv/core/Core.html#cartToPolar(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)"><code>Core.cartToPolar(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat,
                    boolean)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="sepFilter2D(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>sepFilter2D</h4>
<pre>public static&nbsp;void&nbsp;sepFilter2D(<a href="../../../org/opencv/core/Mat.html"
                                                 title="class in org.opencv.core">Mat</a>&nbsp;src,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
               int&nbsp;ddepth,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernelX,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernelY)</pre>
        <div class="block"><p>Applies a separable linear filter to an image.</p>

            <p>The function applies a separable linear filter to the image. That is, first,
                every row of <code>src</code> is filtered with the 1D kernel
                <code>kernelX</code>. Then, every column of the result is filtered with the
                1D kernel <code>kernelY</code>. The final result shifted by <code>delta</code>
                is stored in <code>dst</code>.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Source image.</dd>
            <dd><code>dst</code> - Destination image of the same size and the same number of
                channels
                as <code>src</code>.
            </dd>
            <dd><code>ddepth</code> - Destination image depth. The following combination of
                <code>src.depth()</code> and <code>ddepth</code> are supported:
                <ul>
                    <li><code>src.depth()</code> = <code>CV_8U</code>, <code>ddepth</code> =
                        -1/<code>CV_16S</code>/<code>CV_32F</code>/<code>CV_64F</code>
                    <li><code>src.depth()</code> = <code>CV_16U</code>/<code>CV_16S</code>,
                        <code>ddepth</code> = -1/<code>CV_32F</code>/<code>CV_64F</code>
                    <li><code>src.depth()</code> = <code>CV_32F</code>, <code>ddepth</code> =
                        -1/<code>CV_32F</code>/<code>CV_64F</code>
                    <li><code>src.depth()</code> = <code>CV_64F</code>, <code>ddepth</code> =
                        -1/<code>CV_64F</code>
                </ul>

                <p>when <code>ddepth=-1</code>, the destination image will have the same depth
                    as the source.</p></dd>
            <dd><code>kernelX</code> - Coefficients for filtering each row.</dd>
            <dd><code>kernelY</code> - Coefficients for filtering each column.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#sepfilter2d">org.opencv.imgproc.Imgproc.sepFilter2D</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#GaussianBlur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double, double, int)"><code>GaussianBlur(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Size, double, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#Sobel(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, int, double, double, int)"><code>Sobel(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int, int, int, double, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#boxFilter(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Size, org.opencv.core.Point, boolean, int)"><code>boxFilter(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, org.opencv.core.Size, org.opencv.core.Point, boolean,
                    int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#blur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Point, int)"><code>blur(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Point,
                    int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#filter2D(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, double, int)"><code>filter2D(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, double,
                    int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="sepFilter2D(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>sepFilter2D</h4>
<pre>public static&nbsp;void&nbsp;sepFilter2D(<a href="../../../org/opencv/core/Mat.html"
                                                 title="class in org.opencv.core">Mat</a>&nbsp;src,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
               int&nbsp;ddepth,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernelX,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernelY,
               <a href="../../../org/opencv/core/Point.html"
                  title="class in org.opencv.core">Point</a>&nbsp;anchor,
               double&nbsp;delta)</pre>
        <div class="block"><p>Applies a separable linear filter to an image.</p>

            <p>The function applies a separable linear filter to the image. That is, first,
                every row of <code>src</code> is filtered with the 1D kernel
                <code>kernelX</code>. Then, every column of the result is filtered with the
                1D kernel <code>kernelY</code>. The final result shifted by <code>delta</code>
                is stored in <code>dst</code>.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Source image.</dd>
            <dd><code>dst</code> - Destination image of the same size and the same number of
                channels
                as <code>src</code>.
            </dd>
            <dd><code>ddepth</code> - Destination image depth. The following combination of
                <code>src.depth()</code> and <code>ddepth</code> are supported:
                <ul>
                    <li><code>src.depth()</code> = <code>CV_8U</code>, <code>ddepth</code> =
                        -1/<code>CV_16S</code>/<code>CV_32F</code>/<code>CV_64F</code>
                    <li><code>src.depth()</code> = <code>CV_16U</code>/<code>CV_16S</code>,
                        <code>ddepth</code> = -1/<code>CV_32F</code>/<code>CV_64F</code>
                    <li><code>src.depth()</code> = <code>CV_32F</code>, <code>ddepth</code> =
                        -1/<code>CV_32F</code>/<code>CV_64F</code>
                    <li><code>src.depth()</code> = <code>CV_64F</code>, <code>ddepth</code> =
                        -1/<code>CV_64F</code>
                </ul>

                <p>when <code>ddepth=-1</code>, the destination image will have the same depth
                    as the source.</p></dd>
            <dd><code>kernelX</code> - Coefficients for filtering each row.</dd>
            <dd><code>kernelY</code> - Coefficients for filtering each column.</dd>
            <dd><code>anchor</code> - Anchor position within the kernel. The default value
                <em>(-1,-1)</em> means that the anchor is at the kernel center.
            </dd>
            <dd><code>delta</code> - Value added to the filtered results before storing them.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#sepfilter2d">org.opencv.imgproc.Imgproc.sepFilter2D</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#GaussianBlur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double, double, int)"><code>GaussianBlur(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Size, double, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#Sobel(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, int, double, double, int)"><code>Sobel(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int, int, int, double, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#boxFilter(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Size, org.opencv.core.Point, boolean, int)"><code>boxFilter(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, org.opencv.core.Size, org.opencv.core.Point, boolean,
                    int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#blur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Point, int)"><code>blur(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Point,
                    int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#filter2D(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, double, int)"><code>filter2D(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, double,
                    int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="sepFilter2D(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, double, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>sepFilter2D</h4>
<pre>public static&nbsp;void&nbsp;sepFilter2D(<a href="../../../org/opencv/core/Mat.html"
                                                 title="class in org.opencv.core">Mat</a>&nbsp;src,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
               int&nbsp;ddepth,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernelX,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernelY,
               <a href="../../../org/opencv/core/Point.html"
                  title="class in org.opencv.core">Point</a>&nbsp;anchor,
               double&nbsp;delta,
               int&nbsp;borderType)</pre>
        <div class="block"><p>Applies a separable linear filter to an image.</p>

            <p>The function applies a separable linear filter to the image. That is, first,
                every row of <code>src</code> is filtered with the 1D kernel
                <code>kernelX</code>. Then, every column of the result is filtered with the
                1D kernel <code>kernelY</code>. The final result shifted by <code>delta</code>
                is stored in <code>dst</code>.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Source image.</dd>
            <dd><code>dst</code> - Destination image of the same size and the same number of
                channels
                as <code>src</code>.
            </dd>
            <dd><code>ddepth</code> - Destination image depth. The following combination of
                <code>src.depth()</code> and <code>ddepth</code> are supported:
                <ul>
                    <li><code>src.depth()</code> = <code>CV_8U</code>, <code>ddepth</code> =
                        -1/<code>CV_16S</code>/<code>CV_32F</code>/<code>CV_64F</code>
                    <li><code>src.depth()</code> = <code>CV_16U</code>/<code>CV_16S</code>,
                        <code>ddepth</code> = -1/<code>CV_32F</code>/<code>CV_64F</code>
                    <li><code>src.depth()</code> = <code>CV_32F</code>, <code>ddepth</code> =
                        -1/<code>CV_32F</code>/<code>CV_64F</code>
                    <li><code>src.depth()</code> = <code>CV_64F</code>, <code>ddepth</code> =
                        -1/<code>CV_64F</code>
                </ul>

                <p>when <code>ddepth=-1</code>, the destination image will have the same depth
                    as the source.</p></dd>
            <dd><code>kernelX</code> - Coefficients for filtering each row.</dd>
            <dd><code>kernelY</code> - Coefficients for filtering each column.</dd>
            <dd><code>anchor</code> - Anchor position within the kernel. The default value
                <em>(-1,-1)</em> means that the anchor is at the kernel center.
            </dd>
            <dd><code>delta</code> - Value added to the filtered results before storing them.</dd>
            <dd><code>borderType</code> - Pixel extrapolation method. See "borderInterpolate" for
                details.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#sepfilter2d">org.opencv.imgproc.Imgproc.sepFilter2D</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#GaussianBlur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double, double, int)"><code>GaussianBlur(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Size, double, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#Sobel(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, int, double, double, int)"><code>Sobel(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int, int, int, double, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#boxFilter(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Size, org.opencv.core.Point, boolean, int)"><code>boxFilter(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, org.opencv.core.Size, org.opencv.core.Point, boolean,
                    int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#blur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Point, int)"><code>blur(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Point,
                    int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#filter2D(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, double, int)"><code>filter2D(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, double,
                    int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="Sobel(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>Sobel</h4>
<pre>public static&nbsp;void&nbsp;Sobel(<a href="../../../org/opencv/core/Mat.html"
                                           title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
         int&nbsp;ddepth,
         int&nbsp;dx,
         int&nbsp;dy)</pre>
        <div class="block"><p>Calculates the first, second, third, or mixed image derivatives using
            an
            extended Sobel operator.</p>

            <p>In all cases except one, the <em>ksize x&ltBR&gtksize</em> separable kernel
                is used to calculate the derivative. When <em>ksize = 1</em>, the <em>3 x
                    1</em> or <em>1 x 3</em> kernel is used (that is, no Gaussian smoothing is
                done). <code>ksize = 1</code> can only be used for the first or the second x-
                or y- derivatives.</p>

            <p>There is also the special value <code>ksize = CV_SCHARR</code> (-1) that
                corresponds to the <em>3x3</em> Scharr filter that may give more accurate
                results than the <em>3x3</em> Sobel. The Scharr aperture is</p>

            <p><em>
                |-3 0 3|
                |-10 0 10|
                |-3 0 3|
            </em></p>

            <p>for the x-derivative, or transposed for the y-derivative.</p>

            <p>The function calculates an image derivative by convolving the image with the
                appropriate kernel:</p>

            <p><em>dst = (d^(xorder+yorder) src)/(dx^(xorder) dy^(yorder))</em></p>

            <p>The Sobel operators combine Gaussian smoothing and differentiation, so the
                result is more or less resistant to the noise. Most often, the function is
                called with (<code>xorder</code> = 1, <code>yorder</code> = 0,
                <code>ksize</code> = 3) or (<code>xorder</code> = 0, <code>yorder</code> = 1,
                <code>ksize</code> = 3) to calculate the first x- or y- image derivative. The
                first case corresponds to a kernel of:</p>

            <p><em>
                |-1 0 1|
                |-2 0 2|
                |-1 0 1|
            </em></p>

            <p>The second case corresponds to a kernel of:</p>

            <p><em>
                |-1 -2 -1|
                |0 0 0|
                |1 2 1|
            </em></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image.</dd>
            <dd><code>dst</code> - output image of the same size and the same number of channels as
                <code>src</code>.
            </dd>
            <dd><code>ddepth</code> - output image depth; the following combinations of
                <code>src.depth()</code> and <code>ddepth</code> are supported:
                <ul>
                    <li><code>src.depth()</code> = <code>CV_8U</code>, <code>ddepth</code> =
                        -1/<code>CV_16S</code>/<code>CV_32F</code>/<code>CV_64F</code>
                    <li><code>src.depth()</code> = <code>CV_16U</code>/<code>CV_16S</code>,
                        <code>ddepth</code> = -1/<code>CV_32F</code>/<code>CV_64F</code>
                    <li><code>src.depth()</code> = <code>CV_32F</code>, <code>ddepth</code> =
                        -1/<code>CV_32F</code>/<code>CV_64F</code>
                    <li><code>src.depth()</code> = <code>CV_64F</code>, <code>ddepth</code> =
                        -1/<code>CV_64F</code>
                </ul>

                <p>when <code>ddepth=-1</code>, the destination image will have the same depth
                    as the source; in the case of 8-bit input images it will result in truncated
                    derivatives.</p></dd>
            <dd><code>dx</code> - a dx</dd>
            <dd><code>dy</code> - a dy</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#sobel">org.opencv.imgproc.Imgproc.Sobel</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#GaussianBlur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double, double, int)"><code>GaussianBlur(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Size, double, double, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#cartToPolar(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)"><code>Core.cartToPolar(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat,
                    boolean)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#sepFilter2D(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, double, int)"><code>sepFilter2D(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Mat,
                    org.opencv.core.Point, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#Laplacian(org.opencv.core.Mat, org.opencv.core.Mat, int, int, double, double, int)"><code>Laplacian(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int, double, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#Scharr(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, double, double, int)"><code>Scharr(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int, int, double, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#filter2D(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, double, int)"><code>filter2D(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, double,
                    int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="Sobel(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, int, double, double)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>Sobel</h4>
<pre>public static&nbsp;void&nbsp;Sobel(<a href="../../../org/opencv/core/Mat.html"
                                           title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
         int&nbsp;ddepth,
         int&nbsp;dx,
         int&nbsp;dy,
         int&nbsp;ksize,
         double&nbsp;scale,
         double&nbsp;delta)</pre>
        <div class="block"><p>Calculates the first, second, third, or mixed image derivatives using
            an
            extended Sobel operator.</p>

            <p>In all cases except one, the <em>ksize x&ltBR&gtksize</em> separable kernel
                is used to calculate the derivative. When <em>ksize = 1</em>, the <em>3 x
                    1</em> or <em>1 x 3</em> kernel is used (that is, no Gaussian smoothing is
                done). <code>ksize = 1</code> can only be used for the first or the second x-
                or y- derivatives.</p>

            <p>There is also the special value <code>ksize = CV_SCHARR</code> (-1) that
                corresponds to the <em>3x3</em> Scharr filter that may give more accurate
                results than the <em>3x3</em> Sobel. The Scharr aperture is</p>

            <p><em>
                |-3 0 3|
                |-10 0 10|
                |-3 0 3|
            </em></p>

            <p>for the x-derivative, or transposed for the y-derivative.</p>

            <p>The function calculates an image derivative by convolving the image with the
                appropriate kernel:</p>

            <p><em>dst = (d^(xorder+yorder) src)/(dx^(xorder) dy^(yorder))</em></p>

            <p>The Sobel operators combine Gaussian smoothing and differentiation, so the
                result is more or less resistant to the noise. Most often, the function is
                called with (<code>xorder</code> = 1, <code>yorder</code> = 0,
                <code>ksize</code> = 3) or (<code>xorder</code> = 0, <code>yorder</code> = 1,
                <code>ksize</code> = 3) to calculate the first x- or y- image derivative. The
                first case corresponds to a kernel of:</p>

            <p><em>
                |-1 0 1|
                |-2 0 2|
                |-1 0 1|
            </em></p>

            <p>The second case corresponds to a kernel of:</p>

            <p><em>
                |-1 -2 -1|
                |0 0 0|
                |1 2 1|
            </em></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image.</dd>
            <dd><code>dst</code> - output image of the same size and the same number of channels as
                <code>src</code>.
            </dd>
            <dd><code>ddepth</code> - output image depth; the following combinations of
                <code>src.depth()</code> and <code>ddepth</code> are supported:
                <ul>
                    <li><code>src.depth()</code> = <code>CV_8U</code>, <code>ddepth</code> =
                        -1/<code>CV_16S</code>/<code>CV_32F</code>/<code>CV_64F</code>
                    <li><code>src.depth()</code> = <code>CV_16U</code>/<code>CV_16S</code>,
                        <code>ddepth</code> = -1/<code>CV_32F</code>/<code>CV_64F</code>
                    <li><code>src.depth()</code> = <code>CV_32F</code>, <code>ddepth</code> =
                        -1/<code>CV_32F</code>/<code>CV_64F</code>
                    <li><code>src.depth()</code> = <code>CV_64F</code>, <code>ddepth</code> =
                        -1/<code>CV_64F</code>
                </ul>

                <p>when <code>ddepth=-1</code>, the destination image will have the same depth
                    as the source; in the case of 8-bit input images it will result in truncated
                    derivatives.</p></dd>
            <dd><code>dx</code> - a dx</dd>
            <dd><code>dy</code> - a dy</dd>
            <dd><code>ksize</code> - size of the extended Sobel kernel; it must be 1, 3, 5, or 7.
            </dd>
            <dd><code>scale</code> - optional scale factor for the computed derivative values; by
                default, no scaling is applied (see "getDerivKernels" for details).
            </dd>
            <dd><code>delta</code> - optional delta value that is added to the results prior to
                storing them in <code>dst</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#sobel">org.opencv.imgproc.Imgproc.Sobel</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#GaussianBlur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double, double, int)"><code>GaussianBlur(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Size, double, double, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#cartToPolar(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)"><code>Core.cartToPolar(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat,
                    boolean)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#sepFilter2D(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, double, int)"><code>sepFilter2D(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Mat,
                    org.opencv.core.Point, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#Laplacian(org.opencv.core.Mat, org.opencv.core.Mat, int, int, double, double, int)"><code>Laplacian(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int, double, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#Scharr(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, double, double, int)"><code>Scharr(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int, int, double, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#filter2D(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, double, int)"><code>filter2D(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, double,
                    int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="Sobel(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, int, double, double, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>Sobel</h4>
<pre>public static&nbsp;void&nbsp;Sobel(<a href="../../../org/opencv/core/Mat.html"
                                           title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
         int&nbsp;ddepth,
         int&nbsp;dx,
         int&nbsp;dy,
         int&nbsp;ksize,
         double&nbsp;scale,
         double&nbsp;delta,
         int&nbsp;borderType)</pre>
        <div class="block"><p>Calculates the first, second, third, or mixed image derivatives using
            an
            extended Sobel operator.</p>

            <p>In all cases except one, the <em>ksize x&ltBR&gtksize</em> separable kernel
                is used to calculate the derivative. When <em>ksize = 1</em>, the <em>3 x
                    1</em> or <em>1 x 3</em> kernel is used (that is, no Gaussian smoothing is
                done). <code>ksize = 1</code> can only be used for the first or the second x-
                or y- derivatives.</p>

            <p>There is also the special value <code>ksize = CV_SCHARR</code> (-1) that
                corresponds to the <em>3x3</em> Scharr filter that may give more accurate
                results than the <em>3x3</em> Sobel. The Scharr aperture is</p>

            <p><em>
                |-3 0 3|
                |-10 0 10|
                |-3 0 3|
            </em></p>

            <p>for the x-derivative, or transposed for the y-derivative.</p>

            <p>The function calculates an image derivative by convolving the image with the
                appropriate kernel:</p>

            <p><em>dst = (d^(xorder+yorder) src)/(dx^(xorder) dy^(yorder))</em></p>

            <p>The Sobel operators combine Gaussian smoothing and differentiation, so the
                result is more or less resistant to the noise. Most often, the function is
                called with (<code>xorder</code> = 1, <code>yorder</code> = 0,
                <code>ksize</code> = 3) or (<code>xorder</code> = 0, <code>yorder</code> = 1,
                <code>ksize</code> = 3) to calculate the first x- or y- image derivative. The
                first case corresponds to a kernel of:</p>

            <p><em>
                |-1 0 1|
                |-2 0 2|
                |-1 0 1|
            </em></p>

            <p>The second case corresponds to a kernel of:</p>

            <p><em>
                |-1 -2 -1|
                |0 0 0|
                |1 2 1|
            </em></p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image.</dd>
            <dd><code>dst</code> - output image of the same size and the same number of channels as
                <code>src</code>.
            </dd>
            <dd><code>ddepth</code> - output image depth; the following combinations of
                <code>src.depth()</code> and <code>ddepth</code> are supported:
                <ul>
                    <li><code>src.depth()</code> = <code>CV_8U</code>, <code>ddepth</code> =
                        -1/<code>CV_16S</code>/<code>CV_32F</code>/<code>CV_64F</code>
                    <li><code>src.depth()</code> = <code>CV_16U</code>/<code>CV_16S</code>,
                        <code>ddepth</code> = -1/<code>CV_32F</code>/<code>CV_64F</code>
                    <li><code>src.depth()</code> = <code>CV_32F</code>, <code>ddepth</code> =
                        -1/<code>CV_32F</code>/<code>CV_64F</code>
                    <li><code>src.depth()</code> = <code>CV_64F</code>, <code>ddepth</code> =
                        -1/<code>CV_64F</code>
                </ul>

                <p>when <code>ddepth=-1</code>, the destination image will have the same depth
                    as the source; in the case of 8-bit input images it will result in truncated
                    derivatives.</p></dd>
            <dd><code>dx</code> - a dx</dd>
            <dd><code>dy</code> - a dy</dd>
            <dd><code>ksize</code> - size of the extended Sobel kernel; it must be 1, 3, 5, or 7.
            </dd>
            <dd><code>scale</code> - optional scale factor for the computed derivative values; by
                default, no scaling is applied (see "getDerivKernels" for details).
            </dd>
            <dd><code>delta</code> - optional delta value that is added to the results prior to
                storing them in <code>dst</code>.
            </dd>
            <dd><code>borderType</code> - pixel extrapolation method (see "borderInterpolate" for
                details).
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd><a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#sobel">org.opencv.imgproc.Imgproc.Sobel</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#GaussianBlur(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double, double, int)"><code>GaussianBlur(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Size, double, double, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#cartToPolar(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, boolean)"><code>Core.cartToPolar(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat,
                    boolean)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#sepFilter2D(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Point, double, int)"><code>sepFilter2D(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Mat,
                    org.opencv.core.Point, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#Laplacian(org.opencv.core.Mat, org.opencv.core.Mat, int, int, double, double, int)"><code>Laplacian(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int, double, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#Scharr(org.opencv.core.Mat, org.opencv.core.Mat, int, int, int, double, double, int)"><code>Scharr(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, int, int, double, double, int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#filter2D(org.opencv.core.Mat, org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, double, int)"><code>filter2D(org.opencv.core.Mat,
                    org.opencv.core.Mat, int, org.opencv.core.Mat, org.opencv.core.Point, double,
                    int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="threshold(org.opencv.core.Mat, org.opencv.core.Mat, double, double, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>threshold</h4>
<pre>public static&nbsp;double&nbsp;threshold(<a href="../../../org/opencv/core/Mat.html"
                                                 title="class in org.opencv.core">Mat</a>&nbsp;src,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
               double&nbsp;thresh,
               double&nbsp;maxval,
               int&nbsp;type)</pre>
        <div class="block"><p>Applies a fixed-level threshold to each array element.</p>

            <p>The function applies fixed-level thresholding to a single-channel array. The
                function is typically used to get a bi-level (binary) image out of a
                grayscale image ("compare" could be also used for this purpose) or for
                removing a noise, that is, filtering out pixels with too small or too large
                values. There are several types of thresholding supported by the function.
                They are determined by <code>type</code> :</p>
            <ul>
                <li> THRESH_BINARY
            </ul>

            <p><em>dst(x,y) = maxval if src(x,y) &gt thresh; 0 otherwise</em></p>

            <ul>
                <li> THRESH_BINARY_INV
            </ul>

            <p><em>dst(x,y) = 0 if src(x,y) &gt thresh; maxval otherwise</em></p>

            <ul>
                <li> THRESH_TRUNC
            </ul>

            <p><em>dst(x,y) = threshold if src(x,y) &gt thresh; src(x,y) otherwise</em></p>

            <ul>
                <li> THRESH_TOZERO
            </ul>

            <p><em>dst(x,y) = src(x,y) if src(x,y) &gt thresh; 0 otherwise</em></p>

            <ul>
                <li> THRESH_TOZERO_INV
            </ul>

            <p><em>dst(x,y) = 0 if src(x,y) &gt thresh; src(x,y) otherwise</em></p>

            <p>Also, the special value <code>THRESH_OTSU</code> may be combined with one of
                the above values. In this case, the function determines the optimal threshold
                value using the Otsu's algorithm and uses it instead of the specified
                <code>thresh</code>.
                The function returns the computed threshold value.
                Currently, the Otsu's method is implemented only for 8-bit images.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input array (single-channel, 8-bit or 32-bit floating point).
            </dd>
            <dd><code>dst</code> - output array of the same size and type as <code>src</code>.</dd>
            <dd><code>thresh</code> - threshold value.</dd>
            <dd><code>maxval</code> - maximum value to use with the <code>THRESH_BINARY</code> and
                <code>THRESH_BINARY_INV</code> thresholding types.
            </dd>
            <dd><code>type</code> - thresholding type (see the details below).</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#threshold">org.opencv.imgproc.Imgproc.threshold</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#findContours(org.opencv.core.Mat, java.util.List, org.opencv.core.Mat, int, int, org.opencv.core.Point)"><code>findContours(org.opencv.core.Mat,
                    java.util.List
                    <org.opencv.core.MatOfPoint>, org.opencv.core.Mat, int, int,
                        org.opencv.core.Point)
                </code></a>,
                <a href="../../../org/opencv/core/Core.html#max(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Core.max(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#adaptiveThreshold(org.opencv.core.Mat, org.opencv.core.Mat, double, int, int, int, double)"><code>adaptiveThreshold(org.opencv.core.Mat,
                    org.opencv.core.Mat, double, int, int, int, double)</code></a>,
                <a href="../../../org/opencv/core/Core.html#compare(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int)"><code>Core.compare(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#min(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Core.min(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="undistort(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>undistort</h4>
<pre>public static&nbsp;void&nbsp;undistort(<a href="../../../org/opencv/core/Mat.html"
                                               title="class in org.opencv.core">Mat</a>&nbsp;src,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs)</pre>
        <div class="block"><p>Transforms an image to compensate for lens distortion.</p>

            <p>The function transforms an image to compensate radial and tangential lens
                distortion.</p>

            <p>The function is simply a combination of "initUndistortRectifyMap" (with unity
                <code>R</code>) and "remap" (with bilinear interpolation). See the former
                function for details of the transformation being performed.</p>

            <p>Those pixels in the destination image, for which there is no correspondent
                pixels in the source image, are filled with zeros (black color).</p>

            <p>A particular subset of the source image that will be visible in the corrected
                image can be regulated by <code>newCameraMatrix</code>. You can use
                "getOptimalNewCameraMatrix" to compute the appropriate <code>newCameraMatrix</code>
                depending on your requirements.</p>

            <p>The camera matrix and the distortion parameters can be determined using
                "calibrateCamera". If the resolution of images is different from the
                resolution used at the calibration stage, <em>f_x, f_y, c_x</em> and
                <em>c_y</em> need to be scaled accordingly, while the distortion coefficients
                remain the same.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Input (distorted) image.</dd>
            <dd><code>dst</code> - Output (corrected) image that has the same size and type as
                <code>src</code>.
            </dd>
            <dd><code>cameraMatrix</code> - Input camera matrix <em>A =
                <p>|f_x 0 c_x|
                    |0 f_y c_y|
                    |0 0 1|
            </em>.</p></dd>
            <dd><code>distCoeffs</code> - Input vector of distortion coefficients <em>(k_1, k_2,
                p_1,
                p_2[, k_3[, k_4, k_5, k_6]])</em> of 4, 5, or 8 elements. If the vector is
                NULL/empty, the zero distortion coefficients are assumed.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#undistort">org.opencv.imgproc.Imgproc.undistort</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="undistort(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>undistort</h4>
<pre>public static&nbsp;void&nbsp;undistort(<a href="../../../org/opencv/core/Mat.html"
                                               title="class in org.opencv.core">Mat</a>&nbsp;src,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;newCameraMatrix)</pre>
        <div class="block"><p>Transforms an image to compensate for lens distortion.</p>

            <p>The function transforms an image to compensate radial and tangential lens
                distortion.</p>

            <p>The function is simply a combination of "initUndistortRectifyMap" (with unity
                <code>R</code>) and "remap" (with bilinear interpolation). See the former
                function for details of the transformation being performed.</p>

            <p>Those pixels in the destination image, for which there is no correspondent
                pixels in the source image, are filled with zeros (black color).</p>

            <p>A particular subset of the source image that will be visible in the corrected
                image can be regulated by <code>newCameraMatrix</code>. You can use
                "getOptimalNewCameraMatrix" to compute the appropriate <code>newCameraMatrix</code>
                depending on your requirements.</p>

            <p>The camera matrix and the distortion parameters can be determined using
                "calibrateCamera". If the resolution of images is different from the
                resolution used at the calibration stage, <em>f_x, f_y, c_x</em> and
                <em>c_y</em> need to be scaled accordingly, while the distortion coefficients
                remain the same.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Input (distorted) image.</dd>
            <dd><code>dst</code> - Output (corrected) image that has the same size and type as
                <code>src</code>.
            </dd>
            <dd><code>cameraMatrix</code> - Input camera matrix <em>A =
                <p>|f_x 0 c_x|
                    |0 f_y c_y|
                    |0 0 1|
            </em>.</p></dd>
            <dd><code>distCoeffs</code> - Input vector of distortion coefficients <em>(k_1, k_2,
                p_1,
                p_2[, k_3[, k_4, k_5, k_6]])</em> of 4, 5, or 8 elements. If the vector is
                NULL/empty, the zero distortion coefficients are assumed.
            </dd>
            <dd><code>newCameraMatrix</code> - Camera matrix of the distorted image. By default, it
                is the same as <code>cameraMatrix</code> but you may additionally scale and
                shift the result by using a different matrix.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#undistort">org.opencv.imgproc.Imgproc.undistort</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="undistortPoints(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>undistortPoints</h4>
<pre>public static&nbsp;void&nbsp;undistortPoints(<a
        href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;src,
                   <a href="../../../org/opencv/core/MatOfPoint2f.html"
                      title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;dst,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs)</pre>
        <div class="block"><p>Computes the ideal point coordinates from the observed point
            coordinates.</p>

            <p>The function is similar to "undistort" and "initUndistortRectifyMap" but it
                operates on a sparse set of points instead of a raster image. Also the
                function performs a reverse transformation to"projectPoints". In case of a 3D
                object, it does not reconstruct its 3D coordinates, but for a planar object,
                it does, up to a translation vector, if the proper <code>R</code> is
                specified.
                <code></p>

            <p>// C++ code:</p>

            <p>// (u,v) is the input point, (u', v') is the output point</p>

            <p>// camera_matrix=[fx 0 cx; 0 fy cy; 0 0 1]</p>

            <p>// P=[fx' 0 cx' tx; 0 fy' cy' ty; 0 0 1 tz]</p>

            <p>x" = (u - cx)/fx</p>

            <p>y" = (v - cy)/fy</p>

            <p>(x',y') = undistort(x",y",dist_coeffs)</p>

            <p>[X,Y,W]T = R*[x' y' 1]T</p>

            <p>x = X/W, y = Y/W</p>

            <p>// only performed if P=[fx' 0 cx' [tx]; 0 fy' cy' [ty]; 0 0 1 [tz]] is
                specified</p>

            <p>u' = x*fx' + cx'</p>

            <p>v' = y*fy' + cy',</p>

            <p>where <code>undistort()</code> is an approximate iterative algorithm that
                estimates the normalized original point coordinates out of the normalized
                distorted point coordinates ("normalized" means that the coordinates do not
                depend on the camera matrix).
                </code></p>

            <p>The function can be used for both a stereo camera head or a monocular camera
                (when R is empty).</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Observed point coordinates, 1xN or Nx1 2-channel (CV_32FC2 or
                CV_64FC2).
            </dd>
            <dd><code>dst</code> - Output ideal point coordinates after undistortion and reverse
                perspective transformation. If matrix <code>P</code> is identity or omitted,
                <code>dst</code> will contain normalized point coordinates.
            </dd>
            <dd><code>cameraMatrix</code> - Camera matrix <em>
                <p>|f_x 0 c_x|
                    |0 f_y c_y|
                    |0 0 1|
            </em>.</p></dd>
            <dd><code>distCoeffs</code> - Input vector of distortion coefficients <em>(k_1, k_2,
                p_1,
                p_2[, k_3[, k_4, k_5, k_6]])</em> of 4, 5, or 8 elements. If the vector is
                NULL/empty, the zero distortion coefficients are assumed.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#undistortpoints">org.opencv.imgproc.Imgproc.undistortPoints</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="undistortPoints(org.opencv.core.MatOfPoint2f, org.opencv.core.MatOfPoint2f, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>undistortPoints</h4>
<pre>public static&nbsp;void&nbsp;undistortPoints(<a
        href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;src,
                   <a href="../../../org/opencv/core/MatOfPoint2f.html"
                      title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;dst,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;cameraMatrix,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;distCoeffs,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;R,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;P)</pre>
        <div class="block"><p>Computes the ideal point coordinates from the observed point
            coordinates.</p>

            <p>The function is similar to "undistort" and "initUndistortRectifyMap" but it
                operates on a sparse set of points instead of a raster image. Also the
                function performs a reverse transformation to"projectPoints". In case of a 3D
                object, it does not reconstruct its 3D coordinates, but for a planar object,
                it does, up to a translation vector, if the proper <code>R</code> is
                specified.
                <code></p>

            <p>// C++ code:</p>

            <p>// (u,v) is the input point, (u', v') is the output point</p>

            <p>// camera_matrix=[fx 0 cx; 0 fy cy; 0 0 1]</p>

            <p>// P=[fx' 0 cx' tx; 0 fy' cy' ty; 0 0 1 tz]</p>

            <p>x" = (u - cx)/fx</p>

            <p>y" = (v - cy)/fy</p>

            <p>(x',y') = undistort(x",y",dist_coeffs)</p>

            <p>[X,Y,W]T = R*[x' y' 1]T</p>

            <p>x = X/W, y = Y/W</p>

            <p>// only performed if P=[fx' 0 cx' [tx]; 0 fy' cy' [ty]; 0 0 1 [tz]] is
                specified</p>

            <p>u' = x*fx' + cx'</p>

            <p>v' = y*fy' + cy',</p>

            <p>where <code>undistort()</code> is an approximate iterative algorithm that
                estimates the normalized original point coordinates out of the normalized
                distorted point coordinates ("normalized" means that the coordinates do not
                depend on the camera matrix).
                </code></p>

            <p>The function can be used for both a stereo camera head or a monocular camera
                (when R is empty).</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - Observed point coordinates, 1xN or Nx1 2-channel (CV_32FC2 or
                CV_64FC2).
            </dd>
            <dd><code>dst</code> - Output ideal point coordinates after undistortion and reverse
                perspective transformation. If matrix <code>P</code> is identity or omitted,
                <code>dst</code> will contain normalized point coordinates.
            </dd>
            <dd><code>cameraMatrix</code> - Camera matrix <em>
                <p>|f_x 0 c_x|
                    |0 f_y c_y|
                    |0 0 1|
            </em>.</p></dd>
            <dd><code>distCoeffs</code> - Input vector of distortion coefficients <em>(k_1, k_2,
                p_1,
                p_2[, k_3[, k_4, k_5, k_6]])</em> of 4, 5, or 8 elements. If the vector is
                NULL/empty, the zero distortion coefficients are assumed.
            </dd>
            <dd><code>R</code> - Rectification transformation in the object space (3x3 matrix).
                <code>R1</code> or <code>R2</code> computed by "stereoRectify" can be passed
                here. If the matrix is empty, the identity transformation is used.
            </dd>
            <dd><code>P</code> - New camera matrix (3x3) or new projection matrix (3x4).
                <code>P1</code> or <code>P2</code> computed by "stereoRectify" can be passed
                here. If the matrix is empty, the identity new camera matrix is used.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#undistortpoints">org.opencv.imgproc.Imgproc.undistortPoints</a>
            </dd>
        </dl>
    </li>
</ul>
<a name="warpAffine(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>warpAffine</h4>
<pre>public static&nbsp;void&nbsp;warpAffine(<a href="../../../org/opencv/core/Mat.html"
                                                title="class in org.opencv.core">Mat</a>&nbsp;src,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;M,
              <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize)</pre>
        <div class="block"><p>Applies an affine transformation to an image.</p>

            <p>The function <code>warpAffine</code> transforms the source image using the
                specified matrix:</p>

            <p><em>dst(x,y) = src(M _11 x + M _12 y + M _13, M _21 x + M _22 y + M _23)</em></p>

            <p>when the flag <code>WARP_INVERSE_MAP</code> is set. Otherwise, the
                transformation is first inverted with "invertAffineTransform" and then put in
                the formula above instead of <code>M</code>.
                The function cannot operate in-place.</p>

            <p>Note: <code>cvGetQuadrangleSubPix</code> is similar to <code>cvWarpAffine</code>,
                but the outliers are extrapolated using replication border mode.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image.</dd>
            <dd><code>dst</code> - output image that has the size <code>dsize</code> and the same
                type as <code>src</code>.
            </dd>
            <dd><code>M</code> - <em>2x 3</em> transformation matrix.</dd>
            <dd><code>dsize</code> - size of the output image.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#warpaffine">org.opencv.imgproc.Imgproc.warpAffine</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#remap(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int, org.opencv.core.Scalar)"><code>remap(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#warpPerspective(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int, org.opencv.core.Scalar)"><code>warpPerspective(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#getRectSubPix(org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Point, org.opencv.core.Mat, int)"><code>getRectSubPix(org.opencv.core.Mat,
                    org.opencv.core.Size, org.opencv.core.Point, org.opencv.core.Mat,
                    int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#resize(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double, double, int)"><code>resize(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Size, double, double, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#transform(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Core.transform(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="warpAffine(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>warpAffine</h4>
<pre>public static&nbsp;void&nbsp;warpAffine(<a href="../../../org/opencv/core/Mat.html"
                                                title="class in org.opencv.core">Mat</a>&nbsp;src,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;M,
              <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize,
              int&nbsp;flags)</pre>
        <div class="block"><p>Applies an affine transformation to an image.</p>

            <p>The function <code>warpAffine</code> transforms the source image using the
                specified matrix:</p>

            <p><em>dst(x,y) = src(M _11 x + M _12 y + M _13, M _21 x + M _22 y + M _23)</em></p>

            <p>when the flag <code>WARP_INVERSE_MAP</code> is set. Otherwise, the
                transformation is first inverted with "invertAffineTransform" and then put in
                the formula above instead of <code>M</code>.
                The function cannot operate in-place.</p>

            <p>Note: <code>cvGetQuadrangleSubPix</code> is similar to <code>cvWarpAffine</code>,
                but the outliers are extrapolated using replication border mode.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image.</dd>
            <dd><code>dst</code> - output image that has the size <code>dsize</code> and the same
                type as <code>src</code>.
            </dd>
            <dd><code>M</code> - <em>2x 3</em> transformation matrix.</dd>
            <dd><code>dsize</code> - size of the output image.</dd>
            <dd><code>flags</code> - combination of interpolation methods (see "resize") and the
                optional flag <code>WARP_INVERSE_MAP</code> that means that <code>M</code> is
                the inverse transformation (<em>dst->src</em>).
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#warpaffine">org.opencv.imgproc.Imgproc.warpAffine</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#remap(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int, org.opencv.core.Scalar)"><code>remap(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#warpPerspective(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int, org.opencv.core.Scalar)"><code>warpPerspective(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#getRectSubPix(org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Point, org.opencv.core.Mat, int)"><code>getRectSubPix(org.opencv.core.Mat,
                    org.opencv.core.Size, org.opencv.core.Point, org.opencv.core.Mat,
                    int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#resize(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double, double, int)"><code>resize(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Size, double, double, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#transform(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Core.transform(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="warpAffine(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int, org.opencv.core.Scalar)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>warpAffine</h4>
<pre>public static&nbsp;void&nbsp;warpAffine(<a href="../../../org/opencv/core/Mat.html"
                                                title="class in org.opencv.core">Mat</a>&nbsp;src,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;M,
              <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize,
              int&nbsp;flags,
              int&nbsp;borderMode,
              <a href="../../../org/opencv/core/Scalar.html"
                 title="class in org.opencv.core">Scalar</a>&nbsp;borderValue)</pre>
        <div class="block"><p>Applies an affine transformation to an image.</p>

            <p>The function <code>warpAffine</code> transforms the source image using the
                specified matrix:</p>

            <p><em>dst(x,y) = src(M _11 x + M _12 y + M _13, M _21 x + M _22 y + M _23)</em></p>

            <p>when the flag <code>WARP_INVERSE_MAP</code> is set. Otherwise, the
                transformation is first inverted with "invertAffineTransform" and then put in
                the formula above instead of <code>M</code>.
                The function cannot operate in-place.</p>

            <p>Note: <code>cvGetQuadrangleSubPix</code> is similar to <code>cvWarpAffine</code>,
                but the outliers are extrapolated using replication border mode.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image.</dd>
            <dd><code>dst</code> - output image that has the size <code>dsize</code> and the same
                type as <code>src</code>.
            </dd>
            <dd><code>M</code> - <em>2x 3</em> transformation matrix.</dd>
            <dd><code>dsize</code> - size of the output image.</dd>
            <dd><code>flags</code> - combination of interpolation methods (see "resize") and the
                optional flag <code>WARP_INVERSE_MAP</code> that means that <code>M</code> is
                the inverse transformation (<em>dst->src</em>).
            </dd>
            <dd><code>borderMode</code> - pixel extrapolation method (see "borderInterpolate"); when
                <code>borderMode=BORDER_TRANSPARENT</code>, it means that the pixels in the
                destination image corresponding to the "outliers" in the source image are not
                modified by the function.
            </dd>
            <dd><code>borderValue</code> - value used in case of a constant border; by default, it
                is
                0.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#warpaffine">org.opencv.imgproc.Imgproc.warpAffine</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#remap(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int, org.opencv.core.Scalar)"><code>remap(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#warpPerspective(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int, org.opencv.core.Scalar)"><code>warpPerspective(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#getRectSubPix(org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Point, org.opencv.core.Mat, int)"><code>getRectSubPix(org.opencv.core.Mat,
                    org.opencv.core.Size, org.opencv.core.Point, org.opencv.core.Mat,
                    int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#resize(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double, double, int)"><code>resize(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Size, double, double, int)</code></a>,
                <a href="../../../org/opencv/core/Core.html#transform(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Core.transform(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="warpPerspective(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>warpPerspective</h4>
<pre>public static&nbsp;void&nbsp;warpPerspective(<a href="../../../org/opencv/core/Mat.html"
                                                     title="class in org.opencv.core">Mat</a>&nbsp;src,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;dst,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;M,
                   <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize)</pre>
        <div class="block"><p>Applies a perspective transformation to an image.</p>

            <p>The function <code>warpPerspective</code> transforms the source image using
                the specified matrix:</p>

            <p><em>dst(x,y) = src((M_11 x + M_12 y + M_13)/(M_(31) x + M_32 y +
                M_33),&ltBR&gt(M_21 x + M_22 y + M_23)/(M_(31) x + M_32 y + M_33))</em></p>

            <p>when the flag <code>WARP_INVERSE_MAP</code> is set. Otherwise, the
                transformation is first inverted with "invert" and then put in the formula
                above instead of <code>M</code>.
                The function cannot operate in-place.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image.</dd>
            <dd><code>dst</code> - output image that has the size <code>dsize</code> and the same
                type as <code>src</code>.
            </dd>
            <dd><code>M</code> - <em>3x 3</em> transformation matrix.</dd>
            <dd><code>dsize</code> - size of the output image.</dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#warpperspective">org.opencv.imgproc.Imgproc.warpPerspective</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#warpAffine(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int, org.opencv.core.Scalar)"><code>warpAffine(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#remap(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int, org.opencv.core.Scalar)"><code>remap(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/core/Core.html#perspectiveTransform(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Core.perspectiveTransform(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#getRectSubPix(org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Point, org.opencv.core.Mat, int)"><code>getRectSubPix(org.opencv.core.Mat,
                    org.opencv.core.Size, org.opencv.core.Point, org.opencv.core.Mat,
                    int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#resize(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double, double, int)"><code>resize(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Size, double, double, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="warpPerspective(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>warpPerspective</h4>
<pre>public static&nbsp;void&nbsp;warpPerspective(<a href="../../../org/opencv/core/Mat.html"
                                                     title="class in org.opencv.core">Mat</a>&nbsp;src,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;dst,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;M,
                   <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize,
                   int&nbsp;flags)</pre>
        <div class="block"><p>Applies a perspective transformation to an image.</p>

            <p>The function <code>warpPerspective</code> transforms the source image using
                the specified matrix:</p>

            <p><em>dst(x,y) = src((M_11 x + M_12 y + M_13)/(M_(31) x + M_32 y +
                M_33),&ltBR&gt(M_21 x + M_22 y + M_23)/(M_(31) x + M_32 y + M_33))</em></p>

            <p>when the flag <code>WARP_INVERSE_MAP</code> is set. Otherwise, the
                transformation is first inverted with "invert" and then put in the formula
                above instead of <code>M</code>.
                The function cannot operate in-place.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image.</dd>
            <dd><code>dst</code> - output image that has the size <code>dsize</code> and the same
                type as <code>src</code>.
            </dd>
            <dd><code>M</code> - <em>3x 3</em> transformation matrix.</dd>
            <dd><code>dsize</code> - size of the output image.</dd>
            <dd><code>flags</code> - combination of interpolation methods (<code>INTER_LINEAR</code>
                or <code>INTER_NEAREST</code>) and the optional flag <code>WARP_INVERSE_MAP</code>,
                that sets <code>M</code> as the inverse transformation (<em>dst->src</em>).
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#warpperspective">org.opencv.imgproc.Imgproc.warpPerspective</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#warpAffine(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int, org.opencv.core.Scalar)"><code>warpAffine(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#remap(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int, org.opencv.core.Scalar)"><code>remap(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/core/Core.html#perspectiveTransform(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Core.perspectiveTransform(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#getRectSubPix(org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Point, org.opencv.core.Mat, int)"><code>getRectSubPix(org.opencv.core.Mat,
                    org.opencv.core.Size, org.opencv.core.Point, org.opencv.core.Mat,
                    int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#resize(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double, double, int)"><code>resize(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Size, double, double, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="warpPerspective(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int, org.opencv.core.Scalar)">
    <!--   -->
</a>
<ul class="blockList">
    <li class="blockList">
        <h4>warpPerspective</h4>
<pre>public static&nbsp;void&nbsp;warpPerspective(<a href="../../../org/opencv/core/Mat.html"
                                                     title="class in org.opencv.core">Mat</a>&nbsp;src,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;dst,
                   <a href="../../../org/opencv/core/Mat.html"
                      title="class in org.opencv.core">Mat</a>&nbsp;M,
                   <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize,
                   int&nbsp;flags,
                   int&nbsp;borderMode,
                   <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;borderValue)</pre>
        <div class="block"><p>Applies a perspective transformation to an image.</p>

            <p>The function <code>warpPerspective</code> transforms the source image using
                the specified matrix:</p>

            <p><em>dst(x,y) = src((M_11 x + M_12 y + M_13)/(M_(31) x + M_32 y +
                M_33),&ltBR&gt(M_21 x + M_22 y + M_23)/(M_(31) x + M_32 y + M_33))</em></p>

            <p>when the flag <code>WARP_INVERSE_MAP</code> is set. Otherwise, the
                transformation is first inverted with "invert" and then put in the formula
                above instead of <code>M</code>.
                The function cannot operate in-place.</p></div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>src</code> - input image.</dd>
            <dd><code>dst</code> - output image that has the size <code>dsize</code> and the same
                type as <code>src</code>.
            </dd>
            <dd><code>M</code> - <em>3x 3</em> transformation matrix.</dd>
            <dd><code>dsize</code> - size of the output image.</dd>
            <dd><code>flags</code> - combination of interpolation methods (<code>INTER_LINEAR</code>
                or <code>INTER_NEAREST</code>) and the optional flag <code>WARP_INVERSE_MAP</code>,
                that sets <code>M</code> as the inverse transformation (<em>dst->src</em>).
            </dd>
            <dd><code>borderMode</code> - pixel extrapolation method (<code>BORDER_CONSTANT</code>
                or
                <code>BORDER_REPLICATE</code>).
            </dd>
            <dd><code>borderValue</code> - value used in case of a constant border; by default, it
                equals 0.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#warpperspective">org.opencv.imgproc.Imgproc.warpPerspective</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#warpAffine(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int, org.opencv.core.Scalar)"><code>warpAffine(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#remap(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int, org.opencv.core.Scalar)"><code>remap(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat, int, int,
                    org.opencv.core.Scalar)</code></a>,
                <a href="../../../org/opencv/core/Core.html#perspectiveTransform(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Mat)"><code>Core.perspectiveTransform(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Mat)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#getRectSubPix(org.opencv.core.Mat, org.opencv.core.Size, org.opencv.core.Point, org.opencv.core.Mat, int)"><code>getRectSubPix(org.opencv.core.Mat,
                    org.opencv.core.Size, org.opencv.core.Point, org.opencv.core.Mat,
                    int)</code></a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#resize(org.opencv.core.Mat, org.opencv.core.Mat, org.opencv.core.Size, double, double, int)"><code>resize(org.opencv.core.Mat,
                    org.opencv.core.Mat, org.opencv.core.Size, double, double, int)</code></a></dd>
        </dl>
    </li>
</ul>
<a name="watershed(org.opencv.core.Mat, org.opencv.core.Mat)">
    <!--   -->
</a>
<ul class="blockListLast">
    <li class="blockList">
        <h4>watershed</h4>
<pre>public static&nbsp;void&nbsp;watershed(<a href="../../../org/opencv/core/Mat.html"
                                               title="class in org.opencv.core">Mat</a>&nbsp;image,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;markers)</pre>
        <div class="block"><p>Performs a marker-based image segmentation using the watershed
            algorithm.</p>

            <p>The function implements one of the variants of watershed, non-parametric
                marker-based segmentation algorithm, described in [Meyer92].</p>

            <p>Before passing the image to the function, you have to roughly outline the
                desired regions in the image <code>markers</code> with positive
                (<code>>0</code>) indices. So, every region is represented as one or more
                connected components with the pixel values 1, 2, 3, and so on. Such markers
                can be retrieved from a binary mask using "findContours" and "drawContours"
                (see the <code>watershed.cpp</code> demo). The markers are "seeds" of the
                future image regions. All the other pixels in <code>markers</code>, whose
                relation to the outlined regions is not known and should be defined by the
                algorithm, should be set to 0's. In the function output, each pixel in
                markers is set to a value of the "seed" components or to -1 at boundaries
                between the regions.</p>

            <p>Visual demonstration and usage example of the function can be found in the
                OpenCV samples directory (see the <code>watershed.cpp</code> demo).</p>

            <p>Note: Any two neighbor connected components are not necessarily separated by
                a watershed boundary (-1's pixels); for example, they can touch each other in
                the initial marker image passed to the function.</p>

            <p>Note:</p>
            <ul>
                <li> An example using the watershed algorithm can be found at
                    opencv_source_code/samples/cpp/watershed.cpp
                <li> (Python) An example using the watershed algorithm can be found at
                    opencv_source_code/samples/python2/watershed.py
            </ul>
        </div>
        <dl>
            <dt><span class="strong">Parameters:</span></dt>
            <dd><code>image</code> - Input 8-bit 3-channel image.</dd>
            <dd><code>markers</code> - Input/output 32-bit single-channel image (map) of markers. It
                should have the same size as <code>image</code>.
            </dd>
            <dt><span class="strong">See Also:</span></dt>
            <dd>
                <a href="http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#watershed">org.opencv.imgproc.Imgproc.watershed</a>,
                <a href="../../../org/opencv/imgproc/Imgproc.html#findContours(org.opencv.core.Mat, java.util.List, org.opencv.core.Mat, int, int, org.opencv.core.Point)"><code>findContours(org.opencv.core.Mat,
                    java.util.List
                    <org.opencv.core.MatOfPoint>, org.opencv.core.Mat, int, int,
                        org.opencv.core.Point)
                </code></a></dd>
        </dl>
    </li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
    <!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a
        name="navbar_bottom_firstrow">
    <!--   -->
</a>
    <ul class="navList" title="Navigation">
        <li><a href="../../../overview-summary.html">Overview</a></li>
        <li><a href="package-summary.html">Package</a></li>
        <li class="navBarCell1Rev">Class</li>
        <li><a href="package-tree.html">Tree</a></li>
        <li><a href="../../../index-all.html">Index</a></li>
        <li><a href="../../../help-doc.html">Help</a></li>
    </ul>
    <div class="aboutLanguage"><em><a href=http://docs.opencv.org>OpenCV 2.4.11
        Documentation</a></em></div>
</div>
<div class="subNav">
    <ul class="navList">
        <li><a href="../../../org/opencv/imgproc/CLAHE.html"
               title="class in org.opencv.imgproc"><span class="strong">PREV CLASS</span></a></li>
        <li><a href="../../../org/opencv/imgproc/Moments.html"
               title="class in org.opencv.imgproc"><span class="strong">NEXT CLASS</span></a></li>
    </ul>
    <ul class="navList">
        <li><a href="../../../index.html?org/opencv/imgproc/Imgproc.html" target="_top">FRAMES</a>
        </li>
        <li><a href="Imgproc.html" target="_top">NO FRAMES</a></li>
    </ul>
    <ul class="navList" id="allclasses_navbar_bottom">
        <li><a href="../../../allclasses-noframe.html">All Classes</a></li>
    </ul>
    <div>
        <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->

        </script>
    </div>
    <div>
        <ul class="subNavList">
            <li>SUMMARY:&nbsp;</li>
            <li>NESTED&nbsp;|&nbsp;</li>
            <li><a href="#field_summary">FIELD</a>&nbsp;|&nbsp;</li>
            <li><a href="#constructor_summary">CONSTR</a>&nbsp;|&nbsp;</li>
            <li><a href="#method_summary">METHOD</a></li>
        </ul>
        <ul class="subNavList">
            <li>DETAIL:&nbsp;</li>
            <li><a href="#field_detail">FIELD</a>&nbsp;|&nbsp;</li>
            <li><a href="#constructor_detail">CONSTR</a>&nbsp;|&nbsp;</li>
            <li><a href="#method_detail">METHOD</a></li>
        </ul>
    </div>
    <a name="skip-navbar_bottom">
        <!--   -->
    </a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
